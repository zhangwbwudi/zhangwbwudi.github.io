{"meta":{"title":"蜗牛","subtitle":"boの博客","description":"硕士 | 计算机科学与技术 | 网络安全","author":"蜗牛","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:02.559Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2023-04-12T13:50:02.598Z","updated":"2023-04-12T13:50:02.598Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://example.com/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2023-04-12T13:50:02.620Z","updated":"2023-04-12T13:50:02.620Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://example.com/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:02.899Z","comments":true,"path":"List/index.html","permalink":"http://example.com/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.183Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.228Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2023-04-12T13:50:06.249Z","comments":true,"path":"census/index.html","permalink":"http://example.com/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2023-04-12T13:50:06.292Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.206Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.270Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:06.313Z","comments":true,"path":"resource/index.html","permalink":"http://example.com/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:06.334Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-04-12T13:50:02.919Z","updated":"2023-04-12T13:50:02.919Z","comments":true,"path":"List/galleries/index.html","permalink":"http://example.com/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:03.201Z","comments":true,"path":"List/movies/index.html","permalink":"http://example.com/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:03.222Z","comments":true,"path":"List/music/index.html","permalink":"http://example.com/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:03.244Z","comments":true,"path":"List/tools/index.html","permalink":"http://example.com/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2023-04-12T13:50:02.940Z","updated":"2023-04-12T13:50:02.940Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://example.com/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-04-12T13:50:02.961Z","updated":"2023-04-12T13:50:02.961Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://example.com/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-04-12T13:50:02.984Z","updated":"2023-04-12T13:50:02.984Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-04-12T13:50:03.006Z","updated":"2023-04-12T13:50:03.006Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-04-12T13:50:03.026Z","updated":"2023-04-12T13:50:03.026Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-04-12T13:50:03.048Z","updated":"2023-04-12T13:50:03.048Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://example.com/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-04-12T13:50:03.068Z","updated":"2023-04-12T13:50:03.068Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://example.com/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-04-12T13:50:03.091Z","updated":"2023-04-12T13:50:03.091Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://example.com/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-04-12T13:50:03.115Z","updated":"2023-04-12T13:50:03.115Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://example.com/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-04-12T13:50:03.138Z","updated":"2023-04-12T13:50:03.138Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://example.com/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-04-12T13:50:03.158Z","updated":"2023-04-12T13:50:03.158Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://example.com/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-04-12T13:50:03.179Z","updated":"2023-04-12T13:50:03.179Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://example.com/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"leetcode","date":"2023-04-25T11:43:01.441Z","updated":"2023-04-25T11:43:01.933Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://example.com/posts/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"spring","date":"2023-04-25T10:26:53.647Z","updated":"2023-04-25T10:26:53.920Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://example.com/posts/0.html","excerpt":"","text":"SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解： 1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。 2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。 springboot内置tomcat","categories":[],"tags":[]},{"title":"jvm","slug":"JVM","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:26:39.764Z","comments":true,"path":"posts/7f1ae6dp.html","link":"","permalink":"http://example.com/posts/7f1ae6dp.html","excerpt":"","text":"Class字节码文件 是一个[二进制](https://so.csdn.net/so/search?q=二进制&amp;spm=1001.2101.3001.7020)文件，包含了JAVA程序执行的字节码，包含的信息有版本、访问标志、常量池、当前类、超级类、接口、字段、方法、属性等，中间没有任何分隔符，文件开头有一个特殊标志，用16进制表示为0xcafebabe。 类的实例化顺序比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序 先静态、先父后子。 先静态：父静态 &gt; 子静态 优先级：父类静态代码块–&gt;子类静态代码块–&gt;父类代码块–&gt;父类构造方法–&gt;子类代码块—&gt;子类构造方法 一个类的实例化过程： 1、 父类中的static代码块，当前类的static（这是类初始化，这个main所在的也会初始化） 2、 顺序执行父类的普通代码块(还有非静态变量)（下面是实例初始化） 3、 父类的构造函数 4、 子类普通代码块(还有非静态变量) 5、 子类（当前类）的构造函数，按顺序执行。 6、 子类方法的执行，、 例子 解释 jvm 常用配置参数 分配堆内存s -Xms 最小堆 -Xmx 最大堆 栈 -Xss 栈大小 如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 类需要同时满足下面3个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。加载该类的 ClassLoader 已经被回收。该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 逃逸分析是对象只在当前函数范围内使用，因而改为在栈上申请空间，因为栈是用完就释放掉，不用等gc，缓解了gc的压力。测试可以用一个while循环创建对象来查看 JVM的GC ROOTS有哪几个地方呢？a. java虚拟机栈中的引用的对象。b.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）c.方法区中的常量引用的对象。d.本地方法栈中的JNI（native方法）引用的对象 GC日志的real、user、sys是什么意思？real:指的是从开始到结束所花费的时间。比如进程在等待I/O完成，这个阻塞时间也会被计算在内。user：指的是进程在用户态（User Mode）所花费的时间，只统计本进程所使用的时间，注意是指多核。sys：指的是进程在核心态（Kernel Mode）花费的CPU时间量，指的是内核中的系统调用所花费的时间，只统计本进程所使用的时间。 real time &gt; sys + user time 的情况 一般的GC事件中，real time是小于sys+user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys+user time的。比如说：user+sys是2秒，如果是有5个GC线程并发的做垃圾回收，那么real time差不多是2000/5=400ms左右。 但是，有时候会见到real time大于sys+user time的情况 原因 IO负载繁重 当服务器的IO负载非常重的时候（网络、磁盘访问、用户交互），real time就会变大。应用做GC日志打印的时候，也需要访问磁盘。当磁盘的负载非常重的时候，GC事件就有可能被阻塞，这会导致real time变长。 注意：就算不是你的应用导致的磁盘负载重，如果服务器上其他的应用导致的磁盘负载重也会导致real time变长。 可以用如下命令来监控服务器的磁盘负载情况： CPU不够用 如果服务器上跑了很多进程，你的应用很不幸没有得到足够的CPU时间，它就需要很多的等待。当你的进程在等待的时候，real time显然就比sys+user时间长了。 safepoint是什么？g1什么时候引发full gcyoung GC触发时机：young区不够用 full GC触发时机: 没有足够的Region 垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器 串行 单线程堆内存较小，适合个人电脑 吞吐量优先 多线程堆内存较大，多核cpu让单位时间内，STW 的时间最短 0.2 0.2 = 0.4 响应时间优先 多线程堆内存较大，多核cpu尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5 解释 接下来我们来学习垃圾回收器，垃圾回收器我们可以把它分为这三类，第一类叫串行的垃圾回收器，第二类叫吞吐量优先的垃圾回收器，第三类叫响应时间优先的垃圾回收器。下面就解释一下，第一个串行的垃圾回收器，这个从名字上也能猜出来，它的底层是一个单线程的垃圾回收器，也就是说，它在垃圾回收发生时，其他的线程都暂停，这时候一个单线程的垃圾回收器就登场了，它一个线程来完成垃圾回收，显然它的适用场景是堆内存较小的时候，而且cpu的核数多了也没用，因为只有一个线程，适合个人电脑这就好比我们有一个居民楼，有一个保洁工人来打扫卫生，一个保洁工人就类似于这种单线程的垃圾回收器，如果楼层比较矮，小三层，那保洁工人可能一天就能把卫生打扫完了，但是如果楼层特别的高，是一个三十几层的高层建筑，那一个保洁工人来打扫，这个工作量可能是非常大的，干好几天都干不完。这是串行垃圾回收器它的适用场景。它适合堆内存小，个人电脑也就是cpu个数少的这么一个工作环境。而下两种吞吐量优先和响应时间优先的这两种垃圾回收器，它们都是多线程的，多线程的好处，还拿刚才那个例子作比喻，这个楼层很高，但是我可以多找几个保洁工人啊，它们每个人打扫一层或者几层，人多力量大，肯定还是可以在规定时间内完成垃圾回收的任务。所以后两种垃圾回收器都适合堆内存较大的场景，并且一般它需要多核的cpu来支持，为什么非要说多核cpu呢，虽然有多个线程，但是假设只有一个cpu，那么工作的时候也是多个线程轮流去争抢这单核cpu的时间片，其实这个效率还不如单线程呢，举个例子，就好比虽然有多个保洁工人来打扫卫生，但是扫帚只有一把，那要打扫卫生必须轮流使用这把扫帚，这个效率显然跟一个人来打扫是一样的，所以后两种垃圾回收器它们的工作适用场景是堆内存很大，但是有一个要求，就是必须是多核cpu才能充分发挥它俩的威力，显然多核cpu都是服务器电脑，所以它们都适合工作在服务器上。后两种吞吐量优先跟响应时间优先它们都是多线程的，那它俩之间又有什么区别呢。我们先说响应时间优先，响应时间优先它就是注重的是让垃圾回收时它的 Stop The World 的时间尽可能的短，我们都知道垃圾回收时它要把其他的线程暂停下来，等打扫完垃圾了，其他线程才能恢复运行，这段时间我们把它叫做 STW，就是世界暂停，这个世界暂停时间显然是越短越好了，那响应时间优先的垃圾回收器它要考虑的就是尽可能的让这个暂停时间变短，尽可能让 STW 的时间最短，这是它的一个目标。那么吞吐量优先呢，它的目标就不太一样，吞吐量优先是指我要在单位时间内让我的垃圾回收所占用的 STW 的时间最短，让单位时间内 STW 的时间最短。吞吐量优先和响应时间优先都是 STW 最短，那么它俩有什么区别呢，这个线程优先它是让单次的 STW 时间最短，举个例子，比如说，单位时间内触发了很多次垃圾回收，每一次垃圾回收都只花了 0.1s，假设1小时内发生了5次垃圾回收，每次都是0.1，那么它们加起来最后等于0.5s，也就是一小时内花费了0.5s，但是每次都很短，这是响应时间优先它的目标。但是吞吐量优先则不同，它可能单次的垃圾回收时间花费的较长，比如说1次花了0.2s，但是在一个小时内它只发生了两次垃圾回收，所以它的总时间来讲只有0.4s，从这一点上来讲，它似乎在总时间上又要优于响应时间优先，所谓的吞吐量就是指垃圾回收的时间占程序运行时间的占比，垃圾回收时间占比越低，那么就指吞吐量越高，这是吞吐量它的一个含义。 都要哪些 对于吞吐量优先的场景，就只有一种选择，就是使用 PS 组合（Parallel Scavenge+Parallel Old ）。 对于响应时间优先的场景，在 JDK1.8 的话优先 G1，其次是 CMS 垃圾回收器，另外还有PN、ZGC、Shenandoah。 jdk1.8新特性1.Lambda表达式 2.函数式接口 3.方法引用 等 类的主动使用和被动使用主动 主动使用，又分为七种情况： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（ 比如：Class.forName(“cn.sxt.Test”) ) 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法） 被动 子类引用父类的静态字段，不会导致子类初始化 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 局部变量、成员变量、类变量栈，堆，方法区 i++和++i栈帧都有哪些数据？JVM的运行是基于栈的，和C语言的栈类似，它的大多数数据都是在堆里面的，只有少部分运行时的数据存在于栈上。 在JVM中，每个线程栈里面的元素，就叫栈帧。 栈帧包含：局部变量表、操作数栈、动态连接、返回地址等。 栈结构 栈帧的内部结构 局部变量表 组成 最基本的存储单元是Slot（变量槽） 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量 在局部变量表里，32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long和double）占用两个slot 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maxmum variables数据项中。在方法运行期间是不会改变局部变量表大小的。 操作数栈每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出（Last-in-first-out）的操作数栈，也可以称之为表达式栈（Expression Stack）操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。比如：执行复制、交换、求和等操作 图解：将8和15出栈，执行求和操作后再将结果进栈操作。 动态链接每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）.比如：invokedynamic指令在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 1.举例栈溢出的情况 答：StackOverflowError，通过-Xss设置大小，1.局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。2.递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。3.指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。 2.调整栈大小，就能保证不出现栈溢出吗？ 答：不能，如果说一个执行6000次递归就结束的程序，在可执行递归5000次的内存空间中会出现StackOverflowError，而在调整为可递归7000次的内存空间时就不会出现StackOverflowError。 如果程序是类似死递归情况无论怎样调整栈大小，都会出现溢出现象，对于这种情况，调整栈的大小理论上只能说是出现异常的时间晚一些而已’ 3.分配栈内存越大越好吗 不是，理论上好像会在一定时间或单位时间内减少StackOverflowError的概率，避免出现StackOverflowError过早，但是避免不了出现StackOverflowError。对栈空间来说是好事，但是这样会导致可执行的线程数减少，对其他内存结构也是有影响的 4.垃圾回收是否会设计到虚拟机栈 不涉及，虚拟机栈会出现StackOverflowError，但是不会出现GC，因为只有进栈出栈，出栈的过程就相当于GC（程序计数器不会Error和GC，堆会GC和ERROR，方法区也会出现GC和ERROR） 标记清除算法标记-清除”算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 它的主要缺点有两个： （1）效率问题：标记和清除过程的效率都不高； （2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，碎片过多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至Stop The World。 复制算法（Copying） 为解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 它的主要缺点有两个： （1）效率问题：在对象存活率较高时，复制操作次数多，效率降低； （2）空间问题：內存缩小了一半；需要額外空间做分配担保(老年代) From Survivor, To Survivor使用的就是复制算法。老年代不使用这种算法， 标记-整理(Mark-Compact) 复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法（Generational Collection） GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 “分代收集”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 你知道哪些垃圾收集器？ serial 串行回收 新生代 采用复制算法 Serial是一个单线程的收集器，Serial的特点是它在进行垃圾收集时，必须“Stop the World”，意思就是当这个垃圾收集器开始工作时，必须停止其他所有的工作线程。听起来似乎很不靠谱，但是对于限定单个CPU的场景下，这种方式简单而高效。对于简单的桌面应用，分配给虚拟机的内存不会很大，对于一两百兆的新生代，Serial的垃圾收集时间可以控制在一百毫秒以内，对于用户来说基本上是无影响的。 serial old 采用标记-压缩算法 老年代 ParNew 并行回收 ParNew垃圾收集器是Serial的多线程版本，使用多条线程进行垃圾收集。除此之外，和Serial基本相同，ParNew在多线程收集垃圾时依旧需要“Stop the World”。ParNew可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数量。 ParNew收集器在新生代使用复制算法 Parallel Old Parallel Scavenge收集器的老年版本，多线程收集器，采用标记-整理算法，也是吞吐量优先。 Parallel Scavenge Parallel Scavenge也是新生代收集器，也同样是多线程的收集器，但是和ParNew不同，Parallel Scavenge收集器关注的是一个可控制的吞吐量（Throughput）。所谓吞吐量指的是CPU用于运行代码的时间和CPU总消耗的时间比例。 吞吐量=运行代码的时间 /（运行代码的时间+垃圾收集时间） 理论上吞吐量越高，用户就越不能感受到停顿时间。 Parallel Scavenge提供了两个参数用来控制吞吐量： -XX:MaxGCPauseMillis和**-XX:GCTimeRatio** -XX:MaxGCPauseMillis设置内存回收花费时间最高毫秒值，但是不要一味地认为只要把值设置很小，垃圾回收就更快了。这个停顿时间是以牺牲吞吐量和新生代空间换来的。 -XX:GCTimeRatio表示垃圾收集时间占总时间的比例，（1~100），也就是吞吐量的倒数。默认这个值是99，就是允许最大百分之1的垃圾手机时间（1/(1+99)）。 还有一个参数**-XX:+UseAdaptiveSizePolicy**，打开这个参数后，就不需要自己设置新生代大小、晋升老年代对象年龄等参数，因此Parallel Scavenge收集器也被叫做吞吐量优先垃圾收集器。 Parallel Scavenge采用复制算法。 cms 主要特点：低延迟 尽可能缩短垃圾收集时候用户线程的停顿时间 采用的标记-清除算法 老年代垃圾回收器 1、初始标记：标记GC Roots可以直接关联到的对象，速度很快（stop the world） 2、并发标记：根搜索算法的过程 3、重新标记：为了修正并发标记期间，因程序运行导致标记产生变动的对象。（stop the world） 4、并发清除：清除垃圾 它的优点就是并发收集、并发清除、低停顿。 但是它有三个显著的缺点： 1、对CPU资源十分敏感，因为并发标记和并发清除都是和程序同时运行，因此会占用CPU导致应用程序变慢。 2、无法处理浮动垃圾，浮动垃圾就是在并发清除过程中新生成的垃圾，这部分垃圾CMS无法在本次被清理，可能出现Concurrent Mode Failed报错，因此需要预留一定的内存空间，无法等到老年代快被占满时再清除。默认情况下，CMS在老年代使用了68%后就会被激活。可以设置-XX:CMSInitiatingOccupancyFraction设置这个值。 3、产生空间碎片，由于采用的是标记-清除算法，那就无法避免会产生空间碎片的问题，这会给分配大对象带来困难。 G1 区域化分代式 同时兼顾新生和老年代 划分为一个个region，region内部采用复制算法，整体是标记压缩算法。没有碎片化。 只选取部分region进行内存回收，这样缩短了回收范围，减少了停顿。 后天有一个优先列表，优先回收大的（这个也根据自己给的限制时间内选择较大的）","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"ShardingSphere","slug":"ShardingSphere","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:39:30.995Z","comments":true,"path":"posts/7f1ae6sd.html","link":"","permalink":"http://example.com/posts/7f1ae6sd.html","excerpt":"","text":"定义 添加事务后均是主库，在没添加事务的时候插入是主，查询是从 主从复制 springboot只需要在配置文件里配置一下，这里配置数据源 只需要配置一下，哪个数据源是读得，那个是写的 配置负载均衡 记录docker 这是映射到主机 修改my。cof","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"java基础","slug":"java基础","date":"2020-03-14T16:00:00.000Z","updated":"2023-05-04T07:36:51.467Z","comments":true,"path":"posts/7f1ae090.html","link":"","permalink":"http://example.com/posts/7f1ae090.html","excerpt":"","text":"Java 中 sleep 方法和 wait 方法的区别？​ 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。 sleep()是Thread类中的方法，而wait()则是Object类中的方法。 程序计数器(线程私有)一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 迭代器 Iterator 是什么？首先说一下迭代器模式，它是 Java 中常用的设计模式之一。用于顺序访问集合对象的元素，无需知道集合对象的底层实现。 Iterator 是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。 缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 // 引入 ArrayList 和 Iterator 类 import java.util.ArrayList; import java.util.Iterator; public class RunoobTest { public static void main(String[] args) { // 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(\"Google\"); sites.add(\"Runoob\"); sites.add(\"Taobao\"); sites.add(\"Zhihu\"); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的第一个元素 System.out.println(it.next()); } } 线程的 sleep()方法和 yield()方法有什么区别？1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态； 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常； 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。 volatile关键字的作用和原理 volatile关键字的作用 1、保证可见性；2、防止指令重排；3、但是不保证原子性； 可见性是什么？ 在JMM（java memory model）java内存模型中，其他线程从主内存空间把值拷贝到自己的工作空间，线程修改之后的值会返回给主内存，主内存会通知其他线程，此为可见性。 指令重排 CPU为了执行效率会并发执行操作指令，volatile可以使指令一个一个的执行。 为什么不保证原子性 //自定义的类 public static class MyTest { //类的内部成员变量num public volatile int num = 0; public void numPlusPlus() { num++; } } 比如说，在多个线程同时执行num++时候，他们都是把num值copy到自己的工作内存中，++后再写回主内存。问题出现了这里，比如说A线程刚要写回内存时候，被抢占挂起了，然后B线程写进去了，然后通知所有线程修改了。但是这个时间太短了，所以A也写进来了，把刚刚的覆盖了。 如何解决原子性问题 1、通过synchronized关键字。(不建议，因为volatile自身就是轻量级的，可以说是乞丐版本的synchronized，加这个太重了)2、通过使用AtomicXX，不加锁,采用CAS（compareAndSet）解决。其本质是使用UnSafe本地方法（CPU原语）。3、使用LongAdder:最快（在线程多的情况下，使用分段锁）1、通过synchronized关键字。 Java 中能创建 volatile 数组吗？可以创建volatile数组，但是volatile只保证对数组的引用可见，即如果是改变引用只向的数组，将受到volatile的保护，但是对多个线程想要去改变数组里面的元素，volatile不能保证。 java equals于== 什么时候不同 对于字符串变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。 “==”比较两个变量本身的值，即两个对象在内存中的首地址。 “equals()”比较字符串中所包含的内容是否相同。 注意 String s1,s2,s3 = \"abc\", s4 =\"abc\" ; s1 = new String(\"abc\"); s2 = new String(\"abc\"); s1==s2 是 false //两个变量的内存地址不一样，也就是说它们指向的对象不 一样，故不相等。 s1.equals(s2) 是 true //两个变量的所包含的内容是abc，故相等。 （上述的是因为string重写了equals方法，比较的是值） 重点1 如果： StringBuffer s1 = new StringBuffer(“a”); StringBuffer s2 = new StringBuffer(“a”); 结果： s1.equals(s2) //是false 解释：StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类， 而Object类中的equals方法是用来比较“地址”的，所以等于false 重点2 对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符 串常量所生成的变量，其中所存放的内存地址是相等的， 所以s3==s4是true(即使没有s3=s4这样一个赋值语句) 重点3 对于非字符串变量来说，”==”和”equals”方法的作用是相同的都是用来比较其 对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。 如何判断对象是否是垃圾？引用计数：在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。 可达性分析：主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。 线程四种创建方式？ 创建线程的四种方式 继承Thread类（Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法）,实现Runnable接口,实现Callable接口,线程池。 线程池的好处 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 形成死锁的四个必要条件是什么1、互斥条件：一个资源每次只能被一个进程使用； 2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺； 4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系； 什么是IoC和DI？IoC(控制反转) 、DI(依赖注入) ioc IOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 di DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 两者关系 在平时的Java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象或者依赖对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，**创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起**，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象B之后，两个人一起协作完成要完成的工作即可。 所以控制反转IOC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IOC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IOC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IOC容器了，通过IOC容器来建立它们之间的关系。 DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结道：控制的什么被反转了？就是获得依赖对象的方式反转了。 Java的内存模型是什么？（JMM是什么？）JMM 是Java内存模型（ Java Memory Model），简称JMM。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范。通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。 计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。 三大特性 1.原子性一个或多个操作，要么全部执行（执行的过程是不会被任何因素打断的），要么全部不执行。 2.可见性只要有一个线程对共享变量的值做了修改，其他线程都将马上收到通知，立即获得最新值。 3.有序性 有序性可以总结为：在本线程内观察，所有的操作都是有序的；而在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as-if-serial 语义：线程内似表现为串行，后半句是指：“指令重排序现象”和“工作内存与主内存同步延迟现象”。处理器为了提高程序的运行效率，提高并行效率，可能会对代码进行优化。编译器认为，重排序后的代码执行效率更优。这样一来，代码的执行顺序就未必是编写代码时候的顺序了，在多线程的情况下就可能会出错。 java类型转换规则自动转换规则 布尔型不参与转换 转换规则（总）： byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double 转换规则（详）3.1 操作数之一为double，则另一个操作数先被转化为double，再参与算术运算；3.2 操作数均不为double，当操作数之一为float，则另一操作数先被转换为float，再参与运算；3.3 操作数均不为double或float，当操作数之一为long，则另一操作数先被转换为long，再参与算术运算；3.4 操作数均不为double、float或long，则操作数先被转换为int，再参与运算。 特殊：4.1 如采用+=、*=等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。4.2 当运算符为自动递增运算符（++）或自动递减运算符（–）时，如果操作数为byte，short或char类型不发生改变； Java的char能否存汉字当然可以 Java的char类型占两个字节，存的是Uicode码，其中就包含了汉字。怎么将 byte 转换为 String？ 怎么将 byte 转换为 String？一、String转化为byte[] //Convert to byte[] byte[] bytes = string.getBytes(); System.out.println(\"bytes输出是：\"+bytes); 二、byte[]转化为string String s = new String(bytes); //Check converted string against original String System.out.println(\"Decoded String : \" + s); 什么是隐式转换，什么是显式转换显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。 Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型Char类型可以隐式转成int,double类型，但是不能隐式转换成string（不能自动转换，一个是值类型，一个是引用类型 ）；如果char类型转成byte，short类型的时候，需要强转。 notify() 和 notifyAll() 有什么区别？notify()只能唤醒一个wait()线程,然而notifyAll()可以唤醒多个wait()线程; Java 中的 LinkedList 是单向链表还是双向链表？双向列表 接口特征接口的特征有：1、接口使用interface关键字修饰；2、接口不可以实例化；3、实现类一定要实现接口的所有方法（抽象类除外）；4、实现类可以实现多个接口；5、接口中的常量都是静态常量 接口中只能有static、final变量,不能有其他变量。 什么是过滤器？怎么创建一个过滤器个人理解，拦截并处理（可能是增强等等） 如何创建过滤器 主要是实现过滤器接口，重写dofilter Java中各种数据默认值1、 Byte,short,int,long默认是都是0 2、 Boolean默认值是false 3、 Char类型的默认值是’’ 4、 Float与double类型的默认是0.0 5、 对象类型的默认值是null synchronized 和 Lock 有什么区别？1、 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； 2、 synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 3、 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 4、 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 5、 synchronized只支持非公平锁,lock支持非公平锁和公平锁; 什么是VectorVector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多 ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。 抽象类必须要有抽象方法吗？不必须 1.如果一个类使用了abstract关键字修饰，那么这个类就是一个抽象类。 2.抽象类可以没有抽象方法 3.一个类如果包含抽象方法，那么这个类必须是抽象类，否则编译就会报错。 4.最关键的一点就是如果一个类是抽象类，那么这个类是不能被实例化的。 抽象类有构造方法吗 可以有构造方法。构造方法的作用有两个，一个是初始化变量，另外一个是实例化对象，抽象类不能实例化，还可以做另外一个作用。 能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化， int 类型的高 24 位将会被丢弃，因为 byte 类型的范围是从 -128 到 127 接口和抽象类的区别是什么？1、抽象类可以有构造方法，接口中不能有构造方法。2、接口的方法默认是 public，所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。3、接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。4、一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。5、接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（不能使用 private 关键字修饰！）。6、从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 如何合理配置线程池大小1、CPU密集型特点：更多的CPU在做计算，一直在工作，等待时间很少推荐：线程数少一点一般：CPU内核数+1 2、IO密集型特点：更多的时候线程在等待响应推荐：线程数多一些一般：CPU内核数 * 2 或者（线程等待时间与线程CPU时间之比 + 1） * CPU数目 3、混合型特点：啥任务都有推荐：将CPU密集和IO密集的操作分成2个线程池去执行一般：2个线程池 直接缓冲区和非直接缓冲区的区别1.直接缓冲区是建立在系统的物理内存的，而非直接缓冲区是建立在jvm内存，jvm内存是有上限的，所以速度会很慢 2使用直接缓冲区会对你的物理内存有一定的影响。而非直接缓冲区不会，但是会慢。 如何决定使用 HashMap 还是TreeMap？HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。两个都是非线程安全 ArrayList的优缺点 ArrayList的优点如下： ArrayList底层以数组实现，是一种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候非常快； ArrayList在顺序添加一个元素的时候非常方便； ArrayList 比较适合顺序添加、随机访问的场景； ArrayList的缺点如下： 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能； 插入元素的时候，也需要做一次元素复制操作，缺点同上； 构造方法能不能重写？能不能重载？不能重写但是可以重载，因为构造方法不能被继承。如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有super();语句,即调用父类不带参数的构造方法。如果类里定义一个或多个构造方法，那么java不提供默认的构造方法(不带参数的构造方法)。 被引用的对象就一定能存活吗？不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收 常见异常 java.lang.NullPointerException(空指针异常) java.lang.IllegalArgumentException( 方法的参数错误) 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 Object obj = new Integer(0); String str = obj; java.lang.NoSuchMethodException方法不存在异常 当程序试图通过来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.OutOfMemoryException内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 如何停止一个正在运行的线程？ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法 使用interrupt方法中断线程 线程池都有哪些状态？线程池的5种状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。 RUNNING：运行状态，线程池创建好之后就会进入此状态，如果不手动调用关闭方法，那么线程池在整个程序运行期间都是此状态。 SHUTDOWN：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。 STOP：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。 TIDYING：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。 TERMINATED：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。 线程的五种状态 1.新建状态（New）： 创建一个新的线程对象。 2.就绪状态（Runnable）: 线程创建对象后，其他线程调用start()方法，该线程处于就绪状态，资源已经准备就绪，等待CPU资源。 3.运行状态（Running）： 处于就绪状态的线程获取到CPU资源后进入运行状态。 4.阻塞状态（Blocked）： 阻塞状态是线程由于某些原因放弃CPU使用，暂时停止运行。 （1）等待阻塞：线程调用start（）方法，JVM会把这个线程放入等待池中，该线程需要其他线程调用notify()或notifyAll()方法才能被唤醒。 （2）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入锁池中。 （3）其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 5.终止状态（Terminated）： 线程run（）方法运行完毕，该线程结束。 怎么检测一个线程是否拥有锁？在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。 Java 中用到的线程调度算法是什么？有两种调度模型：分时调度模型和抢占式（java默认使用）调度模型。 分时调度模型： 平均分配每个线程占用的 CPU 的时间片。 抢占式调度模型： 让优先级高的线程占用CPU，如果线程优先级相同，那么就随机选择一个线程。 session和cookie的区别对象都是优先分配在年轻代上的吗？不是 平时代码创建出来的对象，一般分为两种： ​ 一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收，会分配到年轻代里。 ​ 另一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停地去使用，会分配到老年代里。 JAVA如何判断两个类是否相等？ 两个类是否相等，取决于他们是否由统一个类加载器来加载。如果他们来自不同的类加载器，哪么就算这两个类来自同一Class文件，他们也是不相等的。 同一个加载器，那么要判断两个类是否相等我们则可以简单的通过他们的Class对象是否是同一个对象即可。 Integer和int的区别1、类型不同:Integer是对象类型,int是基本数据类型。Integer是int的包装类。 2、Integer变量需要实例化之后才能使用，int则不需要。 3、Integer的默认值是null,int的默认值是0 4、Integer是对象的引用，当new一个Integer对象时，实际上是生成一个指针指向这个对象；而int则是直接存储数据 注意 对于非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true； 如果两个变量的值不在这个区间，则比较结果为false。 Java线程唤醒与阻塞的常用方法 sleep() 方法 sleep(毫秒)，指定以毫秒为单位的时间，使线程在该时间内进入线程阻塞状态，期间得不到cpu的时间片，等到时间过去了，线程重新进入可执行状态。(暂停线程，不会释放锁) yield() 方法： 会使得线程放弃当前分得的cpu时间片，但此时线程仍然处于可执行状态，随时可以再次分得cpu时间片。yield()方法只能使同优先级的线程有执行的机会。调用 yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。(暂停当前正在执行的线程，并执行其他线程，且让出的时间不可知) wait() 和 notify() 方法 两个方法搭配使用，wait()使线程进入阻塞状态，调用notify()时，线程进入可执行状态。wait()内可加或不加参数，加参数时是以毫秒为单位，当到了指定时间或调用notify()方法时，进入可执行状态。(属于Object类，而不属于Thread类，wait()会先释放锁住的对象，然后再执行等待的动作。由于wait()所等待的对象必须先锁住，因此，它只能用在同步化程序段或者同步化方法内，否则，会抛出异常IllegalMonitorStateException.) 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？1、 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。 2、 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。 频繁fullGc 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁gc) 是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了) 为什么HashTable是线程安全的？HashMap是线程不安全的 Hashtable下面代码 //get它搞成了同步方法，保证了get的安全性 public synchronized V get(Object key) { …… } //synchronized,同样 public synchronized V put(K key, V value) { …… } //也是搞成了同步方法 public synchronized V remove(Object key) { …… } finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。 finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。 。finalize()方法允许被重写，一般在该方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。 用最有效率的方法计算2乘以8？2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方 什么是JDK?什么是JRE？JDK = JRE + Java 开发工具包 [Java,Javac,Javadoc,Javap等] JRE = JVM + Java 的核心类库 [类] JRE顾名思义是java运行时环境 JDK顾名思义是java开发工具包 JDK（Java Development Kit）是Java的开发工具包，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等 如何通过获取和设置对象私有字段的值？import com.fasterxml.jackson.annotation.JsonProperty; public class SysUser { // @JsonProperty(\"roleIdList\") private Long[] roleIds; } public Long[] getRoleIds() { return roleIds; } public void setRoleIds(Long[] roleIds) { this.roleIds = roleIds; } 下面是获取 import com.fasterxml.jackson.annotation.JsonProperty; public static Object getFieldValueByObject(Object object, String targetFieldName) throws Exception { // 获取该对象的Class Class objClass = object.getClass(); // 初始化返回值 Object result = null; // 获取所有的属性数组 Field[] fields = objClass.getDeclaredFields(); for (Field field : fields) { // 属性名称 String currentFieldName = \"\"; // 获取属性上面的注解 import com.fasterxml.jackson.annotation.JsonProperty; /** * 举例： @JsonProperty(\"roleIds\") * private String roleIds; */ try { boolean has_JsonProperty = field.isAnnotationPresent(JsonProperty.class); if (has_JsonProperty) { currentFieldName = field.getAnnotation(JsonProperty.class).value(); } else { currentFieldName = field.getName(); } if (currentFieldName.equals(targetFieldName)) { field.setAccessible(true); result = field.get(object); return result; // 通过拿到该属性在此对象中的值(也可能是个对象) } } catch (SecurityException e) { // 安全性异常 e.printStackTrace(); } catch (IllegalArgumentException e) { // 非法参数 e.printStackTrace(); } catch (IllegalAccessException e) { // 无访问权限 e.printStackTrace(); } } return result; } 主要的 Field[] fields = objClass.getDeclaredFields(); field.setAccessible(true); 并发编程三要素1、原子性 原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操 作打断，要么就全部都不执行。 2、可见性 可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他 线程可以立即看到修改的结果。 3、有序性 有序性，即程序的执行顺序按照代码的先后顺序来执行。 讲讲什么情况下会出现内存泄漏？内存泄漏的原因很简单： 1、 对象是可达的(一直被引用) 2、 但是对象不会被使用 例子 public static void main(String[] args) { Set&lt;Object&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { Object object = new Object(); set.add(object); // 设置为空，该对象不再使用 object = null; } // 但是set集合中还维护object的引用，gc不会回收object对象 System.out.println(set); System.out.println(set.size()); } } 解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。 内存溢出常见原因及解决方法引起内存溢出的原因有很多种，常见的有以下几种： 1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据。 解决方法：检查对数据库查询中，是否有一次获得全部数据的查询；对于数据库查询尽量采用分页的方式查询。 2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。 解决方法：检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。（内存泄露） 3.代码中存在死循环或循环产生过多重复的对象实体。 解决方法：检查代码中是否有死循环或递归调用；检查是否有大循环重复产生新对象实体。 4.使用的第三方软件中的BUG。 解决方法：使用内存查看工具动态查看内存使用情况。 5.启动参数内存值设定的过小； 解决方法：修改JVM启动参数(-Xms，-Xmx)，直接增加内存。 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。 乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 动态代理为什么 Thread 类的 sleep()和 yield ()方法是静态的？Java对象创建过程java创建对象的过程主要分为一下五个步骤：（1）类加载检查Java虚拟机（jvm）在读取一条new指令时候，首先检查能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化。如果没有，则会先执行相应的类加载过程。 （2）内存分配在通过（1）后，则开始为新生的对象分配内存。该对象所需的内存大小在类加载完成后便可确定，因此为每个对象分配的内存大小是确定的。而分配方式主要有两种，分别为： 1.指针碰撞 应用场合：堆内存规整（通俗的说就是用过的内存被整齐充分的利用，用过的内存放在一边，没有用过的放在另外一边，而中间利用一个分界值指针对这两边的内存进行分界，从而掌握内存分配情况）。 即在开辟内存空间时候，将分界值指针往没用过的内存方向移动向应大小位置即可）。 将堆内存这样划分的代表的GC收集器算法有：Serial，ParNew 2.空闲列表 应用场合;堆内存不规整（虚拟机维护一个可以记录内存块是否可以用的列表来了解内存分配情况） 即在开辟内存空间时候，找到一块足够大的内存块分配给该对象即可，同时更新记录列表。 将堆内存这样划分的代表的GC收集器算法有：CMS （3）初始化默认值第（2）步完成后，紧接着，虚拟机需要将分配到的内存空间都进行初始化（即给一些默认值），这将做是为了保证对象实例的字段在Java代码中可以在不赋初值的情况下使用。程序可以访问到这些字段对用数据类型的默认值。 （4）设置对象头初始化（3）完成后，虚拟机对对象进行一些简单设置，如标记该对象是那个类的实例，这个对象的hash码，该对象所处的年龄段等等（这些可以理解为对象实例的基本信息）。这些信息被卸载对象头中。jvm根据当前的运行状态，会给出不同的设置方式。 （5）执行初始化方法在（4）完成后，最后执行由开发人员编写的对象的初始化方法，把对象按照开发人员的设计进行初始化，一个对象便创建出来了。 会导致类初始化 会导致 类初始化 的情况 main 方法所在的类，总会被首先初始化 首次访问这个类的 静态变量 或 静态方法 时 子类初始化，如果父类还未初始化，会引发 子类访问父类的静态变量，只会触发父类的初始化 Class.forName new 会导致初始化 不会导致 类初始化 的情况 访问 类的 static final 静态变量（基本类型和字符型）不会触发初始化 类对象.class 不会触发初始化 创建该类的数组不会触发初始化 类加载的 loadClass 方法 Class.forName 的参数2 为 false 时 final不可变对象，它对写并发应用有什么帮助？不可变对象天生是线程安全的。 Java中操作字符串使用哪个类？操作字符串的类主要用三个,分别是String类,StringBuffer类和StringBuilder类. MyBatis中使用#和$书写占位符有什么区别？#将传入的数据都当成一个字符串，会对传入的数据自动加上引号； # 使用#传入参数是，sql语句解析是会加上””,比如 select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是 select * from table where name = ‘小李’， $ 另外一种场景是，如果你要做动态的排序，比如 order by column，这个时候务必要用${},因为如果你使用了#{},那么打印出来的将会是 select * from table order by ‘name’ ,这样是没用， 注意 目前来看，能用#就不要用$,使用 $ 占位符可能会导致SQL注入攻击 String、StringBuffer、StringBuilder的区别是什么 String：不可变 StringBuffer：可变的，线程安全 StringBuilder：可变的，线程不安全 线程安全： String因为是不可变，也可理解为常量，因此是线程安全的。而StringBuffer 和 StringBuilder 继承自AbstractStringBuilder，而AbstractStringBuilder定义了一些基本字符操作，如append、insert、indexOf等，在StringBuffer的方法中加了同步锁，因此StringBuffer是线程安全的。而StringBuilder没有相应的锁，所以非线程安全。 可变性： 简单而言，String类使用Final关键字字符数组保存字符串，private final char[] value，所以String是不可变的。而StringBuffer 和 StringBuilder 都是继承自AbstractStringBuilder，而AbstractStringBuilder 也是使用使用字符s数组保护字符串，不过没有final关键字，char[] value，所以后两者是可变的 对三者使用的总结： 操作量少：String 单线程操作量大：StringBuilder 多线程操作量大：StringBuffer 如何通过创建对象？1、 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 2、 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 运行时常量池溢出的原因？不断创建常量，比如字符串等。 什么是JSON？json的全称为：JavaScript Object Notation，是一种轻量级的数据交互格式。 优点 1、方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是xml、纯字符串的方式，但json有其独到的好处。google有个自己的协议，叫protobuf，有兴趣可了解一下。2、方便转换。有很多的json api提供了json字符串转成对象、对象转换成json串的方法。3、易于阅读。json代码的良好结构，可以很直观地了解存的是什么内容。 Minor GC与Full GC分别在什么时候发生？ Minor GC / Young GC 首先我们先来看下 Minor GC / Young GC，大家都知道，新生代(Young Gen)也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。 此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC，这两个名词，相信大家就理解了，说白了，就专门针对新生代的 GC。 Full GC 对于 Full GC，其实这里有一个更加合适的说法，就是说 Full GC 指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为 Full GC。 从字面意思上也可以理解，Full 就是整体的意思，所以就是对 JVM 进行一次整体的垃圾回收，把各个内存区域的垃圾都回收掉。 MajorGC 老年代 什么是可重入锁synchronized、ReentrantLock都是可重入的锁，可重入锁相对来说简化了并发编程的开发。 可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。synchronized 和 ReentrantLock 都是可重入锁。 可重入锁的意义之一在于防止死锁。 Java常见的锁总结 可重入锁、乐观锁、悲观锁、公平锁、非公平锁、自旋锁等 自旋锁在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。 为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 缺点 ​ 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。 如果锁被占用的时间很短，自旋等待的效果就会非常好；如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置） 实现原理 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 public final int getAndAddInt (Object var1, Long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while( !this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 线程同步和线程异步有什么区别同步和异步的区别，比如说某一次测验：同步：老师派科代表去办公室拿试卷，然后一直等到拿回来试卷，没错就是干等什么都不做，然后发卷子。老师一直等到卷子都发完，才开始说明测验内容。等到说明完了之后，学生才开始做卷子。。。异步：老师派科代表去办公室拿试卷，然后老师简单的介绍测验内容（此时介绍测验内容和科代表拿试卷是同时进行的），科代表拿回试卷后“通知”老师试卷已经拿回来了。老师可以暂停讲解，让科代表发卷子并继续讲解（老师比较嘴碎）。发完卷子学生一遍开始做卷子一遍听老师讲解（老师比较嘴碎，讲了这么久都没讲完）。 什么是线程同步和互斥同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。 OOP中的组合、聚合和关联有什么区别？如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的 关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指 一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在， 但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 理解 比如A类中包含B类的一个引用b，当A类的一个对象消亡时，b这个引用所指向的对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫做组合，反之b所指向的对象还会有另外的引用指向它，这种情况叫聚合。 在实际写代码时组合方式一般会这样写：A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡。聚合方式则是这样：A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它传给它的这个对象不是A类创建的。 代码 聚合 class Driver { //使用成员变量形式实现聚合关系 Car mycar; public void drive(){ mycar.run(); } } 组合(上面的代码加上这些) public Driver(Car car){ mycar = car; } 自动装箱和自动拆箱自动装箱和自动拆箱自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。JDK1.5后，Java引入了自动装箱(autoboxing)/拆箱(unboxing)。自动装箱：基本类型的数据处于需要对象的环境中时，会自动转为“对象”。自动拆箱：每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用Integer 设计模式六大原则：1、单一原则（Single Responsibility Principle）：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化； a、业务对象（BO business object）、业务逻辑（BL business logic）拆分； 2、里氏替换原则（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能；（本质其实就是c++的多态） （目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。 3、依赖倒置原则（dependence inversion principle）：面向接口编程；（通过接口作为参数实现应用场景） 抽象就是接口或者抽象类，细节就是实现类 含义： 上层模块不应该依赖下层模块，两者应依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象； 通俗点就是说变量或者传参数，尽量使用抽象类，或者接口； 【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】 4、接口隔离原则（interface segregation principle）：建立单一接口；（扩展为类也是一种接口，一切皆接口） 定义： a.客户端不应该依赖它不需要的接口； b.类之间依赖关系应该建立在最小的接口上； 简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用） 【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】 5、迪米特原则（law of demeter LOD）：最少知道原则，尽量降低类与类之间的耦合； 一个对象应该对其他对象有最少的了解 6、开闭原则（open closed principle）：用抽象构建架构，用实现扩展原则； url一般有哪几部分组成？一般标准的URL由协议、主机名、路径及文件名三部分00组0成。 comparable和comparator的区别 相同点： 两个都是接口都是实现比较的返回值都是a&gt;b返回正整数,a=b返回0，a&lt;b返回负数。 不同点： comparable位于java.lang包下面，而comparator位于java.util包下comparable实现的是自连接（比如String类），就是将自己和指定的一个对象进行比较，而comparator是另外的一个类的一个方法将两个不相关的对象进行比较，很显然comparator的耦合性比comparable的耦合性要低。 注意 在一些集合里面要对类进行排序，而这些类在设计的时候没有考虑到要进行排序，那么这时候我们唯一的办法就是传递一个comparator的接口给他让他进行比较。 为什么代码会重排序？重排序的好处：提高处理速度 如何写一段简单的死锁代码？public class DeadLockDemo { public static void main(String[] args) { Object object1 = new Object(); Object object2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (object1) { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (object2) { } } }, \"deadlock-demo-1\"); t1.start(); Thread t2 = new Thread(() -&gt; { synchronized (object2) { synchronized (object1) { } } }, \"deadlock-demo-2\"); t2.start(); } } float f=3.4;是否正确？答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 我们可以在 hashcode() 中使用随机数字吗？ 为什么要有hashcode总结:如果一个对象 不往 与hash有关的集合中放 那么hashcode()方法 写不写无所谓, 否则必须写hashcode方法 ,hashcode能加快比较的速度 , equals 相等 hashcode 必须相等 hashcode不相等 equals 必不相等 因为如果两个对象相等，hashcode一定相同，不可能是个随机数 你所知道网络协议有那些？TCP/IP协议、UDP协议、HTTP协议、FTP协议、Telnet协议、SMTP协议、NFS协议等。 FTP：文件传输协议 SMPT：简单邮件协议 程序的结构有那些？由顺序结构、选择结构、循环结构 如何打破双亲委派模型自定义类加载器，重写loadclass方法。 linkedlist和arraylist的区别是什么1、数据结构不同 ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。 2、效率不同 当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。 当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。 3、自由性不同 ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 4、主要控件开销不同 ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。 hashcode和equals如何使用hashcode冲突了，jdk1.7是采用链式继续存，这时候用equals比较 方法传参机制 string、包装类不可变性 例如上面的字符串s，它是指向与常量池，在传参后也是另一个方法也是指向与常量池。在另一个方法进行修改的时候，因为字符串的不可变性，它会产生一个新的字符串，然后把这个新的字符串重新赋值给这个参数，原来方法所指向的不变。（interger包装类也是一样的，它会产生一个新的，所以原来的不会改变，但注意interger 127这个范围） 成员变量与局部变量 作用域 布隆过滤器 布隆过滤器是一个二进制数组，只有0和1.在存储的时候根据多个hash函数计算位置，把对应位置改成1.判断的时候也是这样判断，要查到所有hash函数对应的都是1才存在 缺点 第一个缺点是误判，哈希冲突 第二个是不适合删除，因为可能多个映射到一个位置，删除的话是把对应值改成0，这样把其他的也删除了 优点 安全，都是0和1，谁也不晓得是啥 快，数组随机存储，快的一批 可重入锁指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，目的为了避免死锁 java泛型 java的static方法无法被重写 静态方法是无法被重写（Override）的，如果强行加上 @Override 注解，编译时会报错 “java: 方法不会覆盖或实现超类型的方法”。原因：重写的作用是为了父类和子类的相同签名的方法，具有不同的行为，从而实现了 多态 。但是静态方法是被类直接调用的，和对象无关，不存在父子类对象之间的相同方法不同行为，所以也没有多态。 子类可以直接调用父类的静态方法。虽说子类无法重写父类的静态方法，但是却可以直接调用父类的静态方法，调用方式是 子类名.父类静态方法() ，当然，也可以 **子类对象.父类静态方法()**，不过没必要，也不建议。 字符串创建对象个数面试题：String str4 = new String(“abc”) 创建多少个对象？ 在常量池中查找是否有“abc”对象 有则返回对应的引用实例 没有则创建对应的实例对象 在堆中 new 一个 String(“abc”) 对象 将对象地址赋值给str4,创建一个引用 所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用 根据字面量，往往会提出这样的变式题： String str1 = new String(“A”+”B”) ; 会创建多少个对象?String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象? str1：字符串常量池：”A”,”B”,”AB” : 3个堆：new String(“AB”) ：1个引用： str1 ：1个总共 ： 5个 str2 ：字符串常量池：”ABC” : 1个堆：new String(“ABC”) ：1个引用： str2 ：1个总共 ： 3个 运行时常量池和字符串常量池的区别常量池每个class一份，存在于字节码文件中。常量池中有字面量(数量值、字符串值)和符号引用(类符号引用、字段符号引用、方法符号引用)，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型 运行时常量池每个class一份，存在于方法区中(元空间)。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是下面的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。 字符串常量池每个JVM中只有一份，存在于方法区中(堆)。全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串（用双引号括起来的引用而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份 jdbc连接数据库的步骤是什么1、加载jdbc驱动程序； ​ 在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），这通过java.lang.Class类的静态方法forName(String className)实现。 2、创建数据库的连接； ​ •要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。​ •使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和密码来获得。 //连接MySql数据库，用户名和密码都是root String url = \"jdbc:mysql://localhost:3306/test\" ; String username = \"root\" ; String password = \"root\" ; try{ Connection con = DriverManager.getConnection(url , username , password ) ; }catch(SQLException se){ System.out.println(\"数据库连接失败！\"); se.printStackTrace() ; } 3、创建preparedStatement； •要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：1、执行静态SQL语句。通常通过Statement实例实现。2、执行动态SQL语句。通常通过PreparedStatement实例实现。3、执行数据库存储过程。通常通过CallableStatement实例实现。•具体的实现方式： Statement stmt = con.createStatement() ; PreparedStatement pstmt = con.prepareStatement(sql) ; CallableStatement cstmt = con.prepareCall(\"{CALL demoSp(? , ?)}\") ; 4、执行SQL语句；5、遍历结果集；6、处理异常，关闭JDBC对象资源。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"linux","slug":"linux","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:21:54.981Z","comments":true,"path":"posts/7f1ae6do.html","link":"","permalink":"http://example.com/posts/7f1ae6do.html","excerpt":"","text":"目录结构bin sbin etc home usr root tmp vim快捷键 关机和重启的命令shutdown -h now 立刻进行关机 shutdown -h 1 ”hello，1分钟后会关机了“ shutdown -r now 现在重新启动计算机 halt 关机 reboot 重新启动 syn 把内存的数据同步到磁盘 注意：目前的shutdown/reboot/halt 等命令均已经在关机前进行了sync，但是在执行关机或重启前sync一下，小心驶得万年船 用户管理 用户切换 [halo@zwb-lucky root]$ su root Password: [root@zwb-lucky ~]# su - 用户名“命令来切换 注意 1.从权限高的用户切换到权限低的用户时，不需要输入密码，反之需要 2.当需要返回到原来用户时，使用exit/logout指令 添加用户 基本语法 useradd 用户名 实列(root权限下) useradd hucheng 添加一个用户chucheng，默认该用户的家目录在/home/hucheng 细节说明 1、当用户创建成功后果，会自动的创建和用户同名的家目录 2、也可以通过useradd -d 指定目录 新的用户名 来给新创建的用户指定家目录 12 新建用户zhanzhiwen的home目录下的文件夹名称是muluming 指定/修改密码 passwd 用户名 注意：修改密码要在root下 [zhangsan@zwb-lucky home]$ passwd zhangsan passwd: Only root can specify a user name. 删除用户 userdel 用户名 userdel -r 用户名 查询用户信息指令 id 用户名 [root@zwb-lucky ~]# id root uid=0(root) gid=0(root) groups=0(root) [root@zwb-lucky ~]# id halo uid=1000(halo) gid=1000(halo) groups=1000(halo),10(wheel) 查看当前用户/登录用户 whoami/who am i 用户组 类似于角色，系统可以对有共性/权限的多个用户进行统一的管理 新增组 指令：groupadd 组名 删除组 指令（基本语法）：groupdel 组名 注意：如果当添加用户时没有指定组，会默认创建和这个用户同名的组，同时把用户放到该组里 增加用户时直接加上组 指令：useradd -g 用户组 用户名 移动组 usermod -g 组名 用户名 运行级别说明：0：关机 1：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，也可以指定默认运行级别 帮助指令 man获得帮助信息 基本语法：man [命令或配置文件]（功能描述：获得帮助信息） 在linux下隐藏文件是以 “.” 开头的 help指令 基本语法：help 命令 （功能描述：获得shell内置命令的帮助信息） 文件目录类 pwd指令 基本语法：pwd （功能描述：显示当前工作目录的绝对路径） ls指令 基本语法：ls [选项] [目录或是文件] 常用选项 -a ： 显示当前目录所有的文件和目录，包括隐藏的 -l ： 以列表的方式显示信息 cd指令 基本语法：cd [参数] （功能描述：切换到指定的目录） 理解：绝对路径和相对路径（相对路径是针对当前位置的路径） cd ~ 或者cd 回到自己的家目录 cd … 回到当前目录的上一级目录 mkdir指令 基本语法：mkdir [选项] 要创建的目录 理解：mkdir指令用于创建目录（默认只能创建一级目录） -p :创建多级目录 rmdir指令（用于删除空目录） 基本语法：rmdir [选项] 要删除的空目录 使用细节： rmdir删除的是空目录，如果欲删除的目录下有内容则无法删除 ==如果需要删除非空目录，需要使用rm -rf 要删除的目录 touch指令（用于创建空文件） touch 文件名称 cp指令（copy拷贝文件导指定目录） cp [选项] source dest 常用选项：-r 递归复制真个文件夹 应用实例: 将 /home/hello.txt 拷贝到 /home/bbb 目录下 cp /home/hello.txt /home/bbb 递归复制整个文件夹，将/home/aaa 目录下的文件全部拷贝到/home/bbb下 cp -r /home/aaa /hom/bbb (是将整个目录和目录本身拷贝进来) rm指令（remove，移除文件或目录）=一定要小心！！！ 基本语法：rm [选项] 要删除的文件或目录 常用选项 -r : 递归删除整个文件夹 -f ：强制删除不提示 使用细节：强制删除不提示的方式，带上-f参数即可 cat指令（查看文件内容） cat [选项] 要查看的文件 常用选项： -n 显示行号 使用细节：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 |more cat -n /etc/profile |more 输入到控制台 查看历史 过滤查找，带行号","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"mysql","slug":"mysql","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:35:38.666Z","comments":true,"path":"posts/7f1ae6dh.html","link":"","permalink":"http://example.com/posts/7f1ae6dh.html","excerpt":"","text":"什么是存储过程？用什么来调用？存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 用什么调用？ 可以用一个“execute 存储过程名 参数”命令来调用存储过程。 好处 由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。 完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 1、实体完整性：规定表的每一行在表中是惟一的实体。 2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 使用B树的好处B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。 视图有哪些特点？哪些使用场景？ 什么是视图 是虚拟的表 使用和普通的表一样 mysql5.1后出现的新特性，是通过表动态生成的 特点 临时 可重复用 应用场景 多个地方用到了同样的查询结果 该查询结果比较复杂 好处 简化sql查询，提高开发效率，兼容老的表结构。 索引有哪几种类型？1、 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 2、 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 3、 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。 4、 全文索引：是目 前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。 5、 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行 6、 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并 好处 提高数据的搜索速度 坏处 在我们建立数据库的时候，需要花费的时间去建立和维护索引，而且随着数据量的增加，需要维护它的时间也会增加。在创建索引的时候会占用存储空间。在我们需要修改表中的数据时，索引还需要进行动态的维护，所以对数据库的维护带来了一定的麻烦。 MySQL自增主键用完了怎么办？一般都是int，一般用不完 用完了可以用bigint 可以考虑提前分库分表的。 mysql如何显示前50行？在Mysql中，使用以下代码查询显示前50行： SELECT*FROM LIMIT 0,50; sql执行速度慢怎么办可以加索引 原因 主要原因： sql写的烂 索引失效 关联查询多，比如join这些 加索引为啥快 如果没有索引，需要在所有的数据一点点查，与磁盘i/o多。加上索引，大大减少I/O操作。 二叉树 缺点：有序的时候不行 红黑树 虽然他进行了平衡，但数太多了，高度也很大 InnoDB和MyISAM有什么区别? 建立索引 默认索引是idx_开头 什么时候建立索引 对频繁使用的字段建立索引 索引失效原因 比如上面的name，email做了复合索引，这个是先按照name排序查在按照email查。如果查询语句没有name，只写了whare email = ？，这样就会失效 sql执行顺序 SQL语句中order by和group by一起使用的注意事项 1.order by 的列，必须是出现在group by 子句里的列2.order by 要 放在 group by的后面 join 左连接 两张表的高度要一致，不一致要补null 左边的全部查出来，根据on进行连接，右表没有的补null 右链接 内链接 on是跟的join的条件 1 去除AB公共部分，就是B.key is null 1 全连接 索引 什么是索引 索引是帮助mysql高效的获取数据的数据结构 MySQL中，用的最多的是InnoDB存储引擎，InnoDB中的索引采用B+Tree这种s数据结构 (排好序的快速查找的数据结构) 会影响查找和排序（比如orderby） 一般来说，索引也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上 有哪些索引 单值索引 唯一索引 复合索引 基本语法 哪些适合建立索引 主键自动建立唯一索引 频繁查询 查询中排序的字段，索引可以大大提升速度 不适合索引 where用不到的字段 频繁更新的字段（因为更新也要更新索引） 表记录很少就算了 数据重复率高，又或者类别很少（比如说ture，false）就不建立了 事务四大特性 并发情况下引发的问题 脏读：A事务还没提交，B事务就读到了A事务的结果。（破坏隔离性） 例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（破坏一致性，update，delete）例如：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（破坏一致性，insert）例如：目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 解决 四种隔离级别，隔离程度不同，副作用也不同 读未提交（Read uncommitted）： ​ 这种事务隔离级别下，select语句不加锁。 ​ 此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。 读已提交（Read committed）： ​ 可避免 脏读 的发生。 ​ 在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。 3 .可重复读（Repeatable read）： ​ MySql默认隔离级别。 ​ 可避免 脏读 、不可重复读 的发生。 串行化（Serializable ）： ​ 可避免 脏读、不可重复读、幻读 的发生。 实现（innoDB） 隔离级别就是依赖锁和MVCC实现的。 锁 InnoDB中的行锁 ① 记录锁（Record Locks） 锁住某一条记录 ② 间隙锁（Gap Locks） 比如幻读，一开始没有数据，没办法加记录锁，可以加间隙锁 (3, 8)这个区间被锁 ③ 临键锁（Next-Key Locks） 是上两个锁的组合，间隙锁是开区间（3，8），如果我们也想锁住8，那么用临键锁（3，8] innodb默认的锁就是Next-Key locks。 ④ 插入意向锁（Insert Intention Locks） 为什么索引用b+不用bb+数非叶子叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。IO次数更少 b+高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5， 为什么MySQL 没有用hash作为索引的数据结构呢？1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。 2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。 数据库常用得命令 超键、候选键、主键、外键超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 候选键(candidate key):不含有多余属性的超键称为候选键 主键(primary key):用户选作元组标识的一个候选键程序主键 外键(foreign key)如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。 结合实例的具体解释： 假设有如下两个表： 学生（学号，姓名，性别，身份证号，教师编号） 教师（教师编号，姓名，工资） 超键： 由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。 候选键： 候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。 主键： 主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。 外键： 外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。 sql五种约束 主键约束：不重复、唯一、非空 设置主键的列不允许为空， 唯一约束用来保护表中某列数据不允许重复， char与varchar的区别 char的长度不可变，而varchar的长度可变 这就表示，存储字符串’abc’，使用char(10)，表示存储的字符将占10个字节（包括7个空字符） 使用varchar(10),则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储 char类型的效率比varchar的效率稍高 varchar比char节省空间，但是在效率上比char稍差些。既要获得效率即必须牺牲一点空间，这就是设计上的””以空间换时间”” 三范式 一范式 不重复，原子 数据冗余 插入异常 比如说你新建一个系，这个时候没有学生就插入不了 二范数 消除部分依赖， 完全依赖，通过一个候选码可以确定其他码 比如id可以确定姓名等但是id和课名才能确定分数 分数完全依赖于（id和课程），可以说（id和课程）就是候选码，但是name只需要id就可以，所以说name部分依赖于（id和课程）消除 解决了1范式的数据冗余，修改异常 3范式 消除传递依赖 插入和删除没问题 事务原子性 undo log 持久性 redo log mysql数据是写入磁盘的，但写入磁盘比较慢，所以出现了一个缓存buffer，再写的时候是先写入buffer，在慢慢同步到磁盘。找的时候也如此。如果这时候宕机，buffer嗝屁，不能持久性，这时候有个日志redo log，在放buffer时候也在redo log记录一下，它记录了修改，根据它回复 隔离性 写-写：锁 写-读：mvcc mvcc主要是处理读请求，是快照读而不是当前读 目的是读写得时候不用去竞争锁，提高性能 读已提交和可重复读的快照读都是基于mvcc实现的 基于三个实现 undo log 、版本连、ReadView 如图，把di为1的一直修改，有事务id，这个是自增的，然后回滚指针，指向之前修改的 undo log记录之前修改的 readview啥用 你看版本连里面这么多版本，不知道取哪一个啊 其实readview在代码里就是一个对象 m_ids 表示活跃的，啥是活跃的，就是没有commit creator_trx_id 谁生成了这个readview 例子 读已提交RC：这个级别下每次select都会产生一个readview。 可重复读RR：这个级别下readview是以事务为单位，第一个select产生一个readview，后面不产生了 redolog保证持久性 当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。 为啥不直接写入磁盘 写入redolog快，写入的方式是在文件后面追加，不需要找位置。但是写入磁盘需要找的写入的具体位置，这个比较慢 redolog写满怎么办 它是写满了就从头开始写，像一个环状 redolog和binlog区别 主从复制springboot怎么使用 springboot是自动装配的，你好几个数据库，它怎么知道链接哪一个 在aplication.apropeity里分别定义主从的密码，用户名，链接这些 然后这里仿照springboot配置文件自己定义了一个配置类，取出aprlicaotion中的文件 配置数据源 设置链接工厂这些","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"spring","slug":"spring5","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:44:31.538Z","comments":true,"path":"posts/7f1ae6sp.html","link":"","permalink":"http://example.com/posts/7f1ae6sp.html","excerpt":"","text":"ioc为了降低耦合度 底层原理 xml解析、工厂模式、反射 工厂模式 它的出现就是为了解耦合 ioc 工厂不在new了，通过反射来创建对象，这样我们只需要修改xml就可以了 Spring提供的IOC容器实现的两种方式（两个接口） BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。） ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！ 注入 set &lt;!--（2）spring方式： set方法注入属性--&gt; &lt;bean id=\"book\" class=\"com.atguigu.spring5.Book\"&gt; &lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --&gt; &lt;property name=\"bname\" value=\"Hello\"&gt;&lt;/property&gt; &lt;property name=\"bauthor\" value=\"World\"&gt;&lt;/property&gt; &lt;/bean&gt; construct &lt;!--（2）spring方式：有参数构造注入属性--&gt; &lt;bean id=\"orders\" class=\"com.atguigu.spring5.Orders\"&gt; &lt;constructor-arg name=\"oname\" value=\"Hello\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"address\" value=\"China！\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 注入空值和特殊值 &lt;bean id=\"book\" class=\"com.atguigu.spring5.Book\"&gt; &lt;!--（1）null值--&gt; &lt;property name=\"address\"&gt; &lt;null/&gt;&lt;!--属性里边添加一个null标签--&gt; &lt;/property&gt; &lt;!--（2）特殊符号赋值--&gt; &lt;!--属性值包含特殊符号 a 把&lt;&gt;进行转义 &amp;lt; &amp;gt; b 把带特殊符号内容写到CDATA --&gt; &lt;property name=\"address\"&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 注入外部bean &lt;!--1 service和dao对象创建--&gt; &lt;bean id=\"userService\" class=\"com.atguigu.spring5.service.UserService\"&gt; &lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userDaoImpl\" class=\"com.atguigu.spring5.dao.UserDaoImpl\"&gt;&lt;/bean&gt; xml 注入集合属性 &lt;!--（2）在 spring 配置文件进行配置--&gt; &lt;bean id=\"stu\" class=\"com.atguigu.spring5.collectiontype.Stu\"&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=\"courses\"&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list类型属性注入--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map类型属性注入--&gt; &lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"JAVA\" value=\"java\"&gt;&lt;/entry&gt; &lt;entry key=\"PHP\" value=\"php\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set类型属性注入--&gt; &lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 在集合里面设置对象类型值 &lt;!--创建多个course对象--&gt; &lt;bean id=\"course1\" class=\"com.atguigu.spring5.collectiontype.Course\"&gt; &lt;property name=\"cname\" value=\"Spring5框架\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"course2\" class=\"com.atguigu.spring5.collectiontype.Course\"&gt; &lt;property name=\"cname\" value=\"MyBatis框架\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--注入list集合类型，值是对象--&gt; &lt;property name=\"courseList\"&gt; &lt;list&gt; &lt;ref bean=\"course1\"&gt;&lt;/ref&gt; &lt;ref bean=\"course2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 自动装配 两个的弊端：byname必须名字一样，要不不行 bytype，两个同类型的容器不行，直接报错 注解实现 当然要首先开启注解的支持 @Autowired @Qualifier @Resource Bean 的作用域有哪些?Spring 中 Bean 的作用域通常有下面几种： singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。（单例） prototype : 每次请求都会创建一个新的 bean 实例。（原型） request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。 单例 Bean 的线程安全问题了解吗？大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。 常见的有两种解决办法： 在 Bean 中尽量避免定义可变的成员变量。 在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。 (换成原型模式就安全了)（加锁当然也可以不过会降低效率） 代理模式这是spring aop的底层 aop切面编程 AOP(Aspect Oriented Programming)：面向切面编程，一种编程范式，AOP弥补了OOP的不足，基于OOP基础之上进行横向开发。 OOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型；AOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行， springmvc的执行流程 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。（被它拦截，拦截什么可以配置，比如配置/nihao，就拦截/你好）(一般写/，全拦截就行了) DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。（这个是根据url获取handler） url分为什么 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样： if(mappedHandler.getHandler() instanceof MultiActionController){ ((MultiActionController)mappedHandler.getHandler()).xxx }else if(mappedHandler.getHandler() instanceof XXX){ ... }else if(...){ ... } 这样假设如果我们增加一个 HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof HardController)，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。 HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器 什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 转发和重定向1、请求次数 重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次； 2、地址栏不同 重定向地址栏会发生变化，转发地址栏不会发生变化； 3、是否共享数据 重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）； 4、跳转限制 重定向可以跳转到任意URL，转发只能跳转本站点资源； 5、发生行为不同 重定向是客户端行为，转发是服务器端行为； 请求转发：request.getRequestDispatcher(“info.html”).forward(request, response); 请求重定向：response.sendRedirect(“1.html”); 项目构建 先创建一个父工程 删除父工程src，因为用不到 导入自己知道的公共依赖 创建子工程，一个普通的maven即可 servlet继承httpservlet，重写doGet、depost 乱码问题过滤器解决乱码 配置文件配置 (上面的/换/*) springmvc自带过滤器（在配置文件上配置就可以了） jison它是一种数据格式，现在都是前后端分离开放，需要这样一种格式约定 requestbody了解http请求 第一行是请求url；包含请求类型，地址等 第二行是请求头；包含身份信息，请求内容的类型等 然后空行 第四行请求体： get请求是url传参的，例如上面？后面的 post请求体传参的，比如上面两个，可能是json或者字符串（表单）等等 测试 加上requestbody get请求不行，post请求表单不行，jsion可以 不加requestbody get，post表单都可以。jsion不行 所以处理传来的是jison的时候加上requestbody 注意 用requestbody修饰字符串的时候，会接收整个jsion 所以requestbody尽量修饰一个实体参数，或者map requestparam其实这个在参数上加和不加是一样的，只不过加上可以解决前端和后端传递参数名不一致的情况 跨域问题1.使用注解 (局部跨域) 在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。 @RestController @CrossOrigin(origins = \"*\") public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"hello world\"; } } 2.手动设置响应头(局部跨域) 使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。 @RequestMapping(\"/index\") public String index(HttpServletResponse response) { response.addHeader(\"Access-Allow-Control-Origin\",\"*\"); return \"index\"; } 3.使用自定义filter实现跨域 package cn.wideth.aop; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; @Component public class MyCorsFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with,content-type\"); chain.doFilter(req, res); } public void init(FilterConfig filterConfig) {} public void destroy() {} } get请求和post请求的区别1.get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。 2.get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；post请求是没有的长度限制，请求数据是放在body中； 3.get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。 4.get请求可以被缓存，post请求不会被缓存。 5.get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。 6.get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。 requestbody和RequestParamRequestBody注解的主要作用就是用于接收前端的参数，当我们使用post请求的时候，我们会将参数放在request body中，此时我们就需要在Controller的方法的参数前面加上@RequestBody用来接受到前端传过来的request body中的值，举个栗子： @Controller @RequestMapping（“/test”） public class test{ public void testMethod(@RequestBody String string)\"{ System.out.println(\"测试\"); } } 一个请求只能有一个RequestBody，也就是说，当一个方法中有两个参数的时候，最多只能有一个参数加@RequestBody注解用来接受request body中的参数； @RequestParam接收的参数主要是来自request Header中，即请求头中。通常用于get请求中，我们都知道get请求的参数都是写在url中的，例如：http://localhost:8080/my/api/testMethod?name=雷神&amp;age=3 该url我们可以看到有那么和age两种属性，那么当我们将此请求发送到后台服务以后，Controller写法如下： @Controller @RequesMapping（“/api”） public class test{ public void testMethod(@RequestParam(value=\"name\",required=false,defaultValue=\"雷神\")String name,@RequestParam(value=\"age\")Int age){ System.out.println(\"年仅\"+age+“岁肥宅”+name); } } 注意 RequestBody的作用是将前端传来的json格式的数据转为自己定义好的javabean对象，需要注意的是传入数据的属性名称要和后端javabean中定义的一致，发送请求后可以看到在控制台中我们通过javabean对象的get方法打印出了前端传来的值，说明json数据已经成功被转换为了javabean对象，将对应的属性进行了赋值。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"反射","slug":"反射","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:31:23.836Z","comments":true,"path":"posts/7f1ae6fg.html","link":"","permalink":"http://example.com/posts/7f1ae6fg.html","excerpt":"","text":"动态语言和静态语言动态语言是在运行的时候可以改变其结构的语言，比如说c#、javascript、PHP、Python等 静态比如说C、JAVA、C++ java不是动态语言，但java可以有一定的动态性，可以通过反射机制获得类似动态语言的特性，让编程更加灵活。 反射java reflection 反射获得类的class对象三种方式若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 Class clazz = Person.class; 已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class clazz = person.getClass(); 已知一个类的全类名，且该类在路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException static Class&lt;?&gt; aclass = Class.forName(\"绝对路径\"); 内置基本类型可以通过类名.Type(例 Integer、Long) 还可以利用ClassLoader 哪些类型有可以有class对象？ Object //类 Comparable //接口 String[] //一维数组 int[] [] // 二维数组 Override //注解 ElementType //枚举 Integer //基本数据类型 void //void Class //class 快捷键alt可以竖着复制多行，方便快捷 要遍历的时候直接（遍历对象）.for 类加载 什么时候类会初始化 执行过程 通过反射能够获取到什么 package com.text; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.concurrent.atomic.AtomicInteger; public class test32 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //获取Class类 Class&lt;?&gt; c1 = Class.forName(\"com.text.Animal\"); //获取类名 System.out.println(\"--------------------获取类名--------------------\"); System.out.println(\"类名\" + c1.getSimpleName()); System.out.println(\"包名+类名:\" + c1.getName());//包名+类名 //获取类的属性 System.out.println(\"--------------------获取类的属性--------------------\"); Field[] fields = c1.getFields();//只能获取公共的字段表示属性 Field[] declaredFields = c1.getDeclaredFields();//获取所以的字段属性(包括私有的等等) for (Field declaredField : declaredFields) { System.out.println(declaredField); } //获取指定属性的值 System.out.println(\"--------------------获取指定属性的值--------------------\"); Field name = c1.getDeclaredField(\"name\"); System.out.println(name); //获取方法 System.out.println(\"--------------------获取类的方法--------------------\"); Method[] declaredMethods = c1.getDeclaredMethods();//获得本类全部方法(无关修饰符) Method[] methods = c1.getMethods(); //获得本类及父类的全部public方法 for (Method method : declaredMethods) { System.out.println(method); } //获取指定方法 System.out.println(\"--------------------获取指定方法--------------------\"); Method getNames = c1.getMethod(\"getName\", null); System.out.println(getNames); //获取Class全部的公有构造方法 System.out.println(\"---------------------获取所有公共的构造函数---------------------\"); Constructor&lt;?&gt;[] constructors = c1.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) { System.out.println(constructor); } //获取Class全部的构造方法 System.out.println(\"---------------------获取所有全部的构造函数(包括：公共的,默认的,受保护的,私有的)---------------------\"); Constructor&lt;?&gt;[] declaredConstructors = c1.getDeclaredConstructors(); for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) { System.out.println(declaredConstructor); } //获取公共构造方法v System.out.println(\"---------------------获取公共无参构造方法---------------------\"); Constructor&lt;?&gt; constructor = c1.getConstructor(null);//这里必须是一个参数类型的class,默认为null System.out.println(constructor); Object o = constructor.newInstance();//调用构造方法 // System.out.println(\"o:\"+o.toString()); // User user=(User)o; // user.user2(); //获取私有构造放 System.out.println(\"---------------------获取私有构造方法---------------------\"); Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class); System.out.println(constructor); declaredConstructor.setAccessible(true); Object test = declaredConstructor.newInstance(123); System.out.println(test); //获取指定构造方法 System.out.println(\"---------------------获取指定构造方法---------------------\"); Constructor&lt;?&gt; declaredConstructor1 = c1.getDeclaredConstructor(int.class, String.class); System.out.println(declaredConstructor1); } } class Animal { private int age; private String name; public Animal() { } //这个是测试 private Animal(int a){ } private void test() { System.out.println(\"私有方法\"); } public Animal(int age, String name) { this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Animal{\" + \"age=\" + age + \", name='\" + name + '\\'' + '}'; } } class Dog extends Animal { private String name; public Dog() { this.setName(\"小狗\"); this.setAge((int) (Math.random() * 7)); } } class Cat extends Animal { public Cat() { this.setName(\"猫\"); this.setAge((int) (Math.random() * 7)); } } 反射创建对象 package com.text; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; public class test34 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { //1.创建class对象 Class&lt;?&gt; c1 = Class.forName(\"com.text.personnel\"); //2.获取构造方法 Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(); //3.通过构造方法new类(这里知道是什么类就可以强行转换了) personnel o = (personnel)(declaredConstructor.newInstance()); //4.这里获取字段(也可以获取方法全看需要) Field id = c1.getDeclaredField(\"id\"); //5.因为是私有的属性所以关闭安全检测 id.setAccessible(true); //6.设置属性，参数是(设置属性的对象,属性值) id.set(o,\"1234\"); //7.查看调用方法查看是否设置成功 System.out.println(o.getId()); } } //账号类 class personnel{ private String id; private String password; public String getId() { return id; } public String getPassword() { return password; } }","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"算法思想","slug":"算法","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:41:17.394Z","comments":true,"path":"posts/7f1ae6sf.html","link":"","permalink":"http://example.com/posts/7f1ae6sf.html","excerpt":"","text":"搜索二叉树遍历数组重建树 最后得节点是整棵树得头，然后想着左右树建立出来，搜索左边小右边大无重复值 （进阶：不需要一直遍历，可以二分） （无序怎么二分？这个我们可以分后与最后一个节点比较，看他大概在哪个区间。毕竟有这样一个简单得规律，后面一大堆比前面一大堆大） 左小右大，直接与根节点（最后一个节点）比较就行了 怎么确立左右树呢，一样得道理 复杂的（遍历得最差是o（n^2）（什么时候最差，单支，每一层都遍历，共n层），二分得最差是o(nlogn)） 前缀树 代码里每个节点有pass代表经过几次，还有end代表是不是结尾。 查询的时候只需要从上往下查，怎么加入的就怎么查，看end有没有 根节点的pass代表着一共多少字符串，根节点end代表空串数量 package class07; public class Code01_TrieTree { public static class TrieNode { public int path; public int end; public TrieNode[] nexts;//这个是用数组代表路，如果字符种类特别多，那可以用hash表 public TrieNode() { path = 0; end = 0; nexts = new TrieNode[26]; } } public static class Trie { private TrieNode root; public Trie() { root = new TrieNode(); } //插入 public void insert(String word) { if (word == null) { return; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { node.nexts[index] = new TrieNode(); } node = node.nexts[index]; node.path++; } node.end++; } public void delete(String word) { if (search(word) != 0) { char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (--node.nexts[index].path == 0) { node.nexts[index] = null; return; } node = node.nexts[index]; } node.end--; } } //查找加入的次数 public int search(String word) { if (word == null) { return 0; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { return 0; } node = node.nexts[index]; } return node.end; } //查有多少字符串以***作为前缀 public int prefixNumber(String pre) { if (pre == null) { return 0; } char[] chs = pre.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { return 0; } node = node.nexts[index]; } return node.path; } } public static void main(String[] args) { Trie trie = new Trie(); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuo\"); trie.insert(\"zuo\"); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuoa\"); trie.insert(\"zuoac\"); trie.insert(\"zuoab\"); trie.insert(\"zuoad\"); trie.delete(\"zuoa\"); System.out.println(trie.search(\"zuoa\")); System.out.println(trie.prefixNumber(\"zuo\")); } } 贪心在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到 一个答案的算法，叫作贪心算法。 也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解 例题1一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数 组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。 返回这个最多的宣讲场次 思考 我们先想按时间最早分配，显然，如果有一个项目最早开始，但贯穿一天，这种策略不行。然后考虑按时间最短分配，经过思考，也不行，比如下面中间的最短，但是他的开始时间和结束时间卡住了其他 最后我们按照结束时间最早分配，每次把不符合的给删除（因为我们的目的就是数量最多） 代码 package class07; import java.util.Arrays; import java.util.Comparator; public class Code04_BestArrange { public static class Program { public int start; public int end; public Program(int start, int end) { this.start = start; this.end = end; } } public static class ProgramComparator implements Comparator&lt;Program&gt; { @Override public int compare(Program o1, Program o2) { return o1.end - o2.end; } } public static int bestArrange(Program[] programs, int start) { Arrays.sort(programs, new ProgramComparator()); int result = 0; for (int i = 0; i &lt; programs.length; i++) { if (start &lt;= programs[i].start) { result++; start = programs[i].end; } } return result; } public static void main(String[] args) { } } 例题2给一个字符串数组，然后进行拼接成一个，要求拼接后的字典序最小 思考 每次都把最小字典序的字符串放前面，经过举例这个不对，例如。b的字典序小于ba，如果谁小谁在前，那么是bba，但是很明显bab更小。 代码 package class07; import java.util.Arrays; import java.util.Comparator; public class Code02_LowestLexicography { // 定义一个比较器，比较策略 public static class MyComparator implements Comparator&lt;String&gt; { @Override public int compare(String a, String b) { return (a + b).compareTo(b + a); } } public static String lowestString(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } //怎么比较排序，自己定义下 Arrays.sort(strs, new MyComparator()); String res = \"\"; for (int i = 0; i &lt; strs.length; i++) { res += strs[i]; } return res; } public static void main(String[] args) { String[] strs1 = { \"jibw\", \"ji\", \"jp\", \"bw\", \"jibw\" }; System.out.println(lowestString(strs1)); String[] strs2 = { \"ba\", \"b\" }; System.out.println(lowestString(strs2)); } } 例3 哈夫曼树解决 例题3 给一堆项目，有他的花费和利润，然后你有启动资金去投资它，怎么获利最大 解题思路： 如上面所示，先建立一个小根堆，这个小根堆按照所需投资钱数排，它的目的是根据我们的启动资金找出可以投资哪些项目。然后再建立一个大根堆，根据小根堆筛选出来的放进大根堆，大根堆按照利润排序，毕竟在钱够的情况下做利润大的，得到利润的钱后，在去小根堆瞅瞅哪些现在可以做了，筛选出来放大根堆，以此类推 package class07; import java.util.Comparator; import java.util.PriorityQueue; public class Code05_IPO { public static class Node { public int p; public int c; public Node(int p, int c) { this.p = p; this.c = c; } } //小根堆比较器 public static class MinCostComparator implements Comparator&lt;Node&gt; { @Override public int compare(Node o1, Node o2) { return o1.c - o2.c; } } //大根堆比较器 public static class MaxProfitComparator implements Comparator&lt;Node&gt; { @Override public int compare(Node o1, Node o2) { return o2.p - o1.p; } } //w是启动资金，k是最多处理几个项目 public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) { Node[] nodes = new Node[Profits.length]; for (int i = 0; i &lt; Profits.length; i++) { nodes[i] = new Node(Profits[i], Capital[i]); } //定义堆，通过比较器来看大小 PriorityQueue&lt;Node&gt; minCostQ = new PriorityQueue&lt;&gt;(new MinCostComparator()); PriorityQueue&lt;Node&gt; maxProfitQ = new PriorityQueue&lt;&gt;(new MaxProfitComparator()); //所有节点放在小根堆里 for (int i = 0; i &lt; nodes.length; i++) { minCostQ.add(nodes[i]); } for (int i = 0; i &lt; k; i++) { while (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) { maxProfitQ.add(minCostQ.poll()); } //剩下的都做不了了，提前 if (maxProfitQ.isEmpty()) { return W; } W += maxProfitQ.poll().p; } return W; } } 动态规划 啥是动态规划 空间换时间 如何你发现计算中有重复的部分，就把重复的给记录下来，下次不用重复算","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"集合常用api","slug":"集合常用api","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:39:05.068Z","comments":true,"path":"posts/7f1ae6ui.html","link":"","permalink":"http://example.com/posts/7f1ae6ui.html","excerpt":"","text":"String获取功能1）length():获取字符串的长度，其实也就是字符个数2）charAt(int index):获取指定索引处的字符 3）indexOf(String str):获取str在字符串对象中第一次出现的索引4）substring(int start):从start开始截取字符串5）String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end 判断功能1）equals(Object obj):比较字符串的内容是否相同 2）isEmpty()：判断指定字符串是否为空 3）compareTo(String anotherString)：比较字符串的大小，前者大返回整数，后者大返回负数，相等返回0 转换方法1）toCharArray():把字符串转换为字符数组 2）toLowerCase():把字符串转换为小写字符串 3）toUpperCase():把字符串转换为大写字符串 其他方法1）replace(char oldChar, char newChar)：将指定字符替换成另一个指定的字符 2）replaceAll(String regex,String replasement)：用新的内容替换全部旧内容 replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\\d”, “*”)把个字符串所有的数字字符都换成星号; String src = new String(\"ab43a2c43d\"); System.out.println(src.replace(\"3\",\"f\"));=&gt;ab4f2c4fd. System.out.println(src.replace('3','f'));=&gt;ab4f2c4fd. System.out.println(src.replaceAll(\"\\\\d\",\"f\"));=&gt;abffafcffd. 3）replaceFirst(String regex,String replacement)：替换首个满足条件的内容 4）contains(CharSequence s)：查看字符串中是都含有指定字符 hashmap1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。 3：remove方法：remove(key)，主要用来删除map中对应的key及其value值。 4：clear方法，用法：clear()，会清空map中的数据。 5：containsKey(key)，判断map集合中是否包含某个key。 6：containsKey(value)，判断map集合中是否包含某个value。 7：entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。 8：keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。 TreeMap构造方法 TreeMap()：创建一个空TreeMap，keys按照自然排序 TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(); TreeMap(Comparator comparator)：创建一个空TreeMap，按照指定的comparator排序 TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(Comparator.reverseOrder()); map.put(3, \"val\"); map.put(2, \"val\"); map.put(1, \"val\"); map.put(5, \"val\"); map.put(4, \"val\"); System.out.println(map); // {5=val, 4=val, 3=val, 2=val, 1=val} TreeMap(Map m)：由给定的map创建一个TreeMap，keys按照自然排序 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"val\"); ... TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(map); TreeMap(SortedMap m)：由给定的有序map创建TreeMap，keys按照原顺序排序 常用方法V put(K key, V value)：将指定映射放入该TreeMap中 void clear()：清空TreeMap中的所有元素 V remove(Object key)：从TreeMap中移除指定key对应的映射 V replace(K key, V value)：替换指定key对应的value值 boolean containsKey(Object key)：判断该TreeMap中是否包含指定key的映射 boolean containsValue(Object value)：判断该TreeMap中是否包含有关指定value的映射 Set&lt;Map&lt;K, V&gt;&gt; entrySet()：返回由该TreeMap中的所有映射组成的Set对象 int size()：返回该TreepMap中包含的映射的数量 遍历方式 for循环 for (Map.Entry entry : treeMap.entrySet()) { System.out.println(entry); } 迭代器循环 Iterator iterator = treeMap.entrySet().iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 自定义比较器Map&lt;Integer, Object&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); map.put(5, new Object()); map.put(10, new Object()); map.put(8, new Object()); map.put(12, new Object()); System.out.println(map); ArrayList1、add(Object element) 方法add(Object element) 方法用于向ArrayList集合中的添加元素。 2、size() 方法size()方法用于返回ArrayList集合中元素个数 3、get(int index) 方法get(int index)方法用于返回集合中对应位置的元素 4、add(int index, Object element) 方法add(int index, Object element) 方法用于在集合指定位置添加元素，原集合中从指定位置开始的元素全部后置 5、set(int i, Object element) 方法set(int i, Object element) 方法用于将索引i位置元素替换为元素element并返回被替换的元素 6、clear() 方法clear() 方法用于清空集合中元素 7、isEmpty() 方法isEmpty() 方法用于判断集合容器是否为空，如果为空，则返回true，否则返回false。 8、iterator()iterator（）不是一个方法而是一个用于返回按适当顺序在列表的元素上进行迭代的迭代器可以用它遍历集合元素 9、contains(Object o) 方法contains(Object o) 方法用以判断集合容器中是否含有指定元素，有返回值，且为boolean型。 10、remove(int index) 方法remove（int index）方法用于移除列表中指定位置的元素，并返回被删元素 11、remove(Object o) 方法remove(Object o) 方法用于移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。 转字符串数组方法一、 String[] arr = new String[list.size]; list.toArray(arr);//此时arr就有了list中的值了` 方法二、 String[] arr = (String[])list.toArray(new String[0]);` 构造方法List&lt;String&gt; list3 = new ArrayList&lt;&gt;(list2); List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); //构造一个具有指定初始容量的空列表。 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(6); StringBufferStringBuffer对象的初始化StringBuffer s = new StringBuffer(); StringBuffer s = new StringBuffer(“abc”); StringBuffer对象和String对象之间的互转String s = “abc”; StringBuffer sb1 = new StringBuffer(“123”); StringBuffer sb2 = new StringBuffer(s); //String转换为StringBuffer String s1 = sb1.toString(); //StringBuffer转换为String 常用方法1、append方法StringBuffer sb = new StringBuffer(); String user = “test”; String pwd = “123”; sb.append(“select * from userInfo where username=“) .append(user) .append(“ and pwd=”) .append(pwd); 这样对象sb的值就是字符串“select * from userInfo where username=test and pwd=123” 2、deleteCharAt方法该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字 StringBuffer sb = new StringBuffer(“Test”); sb. deleteCharAt(1); 该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变为”Tst” 3、delete方法public StringBuffer delete(int start,int end) StringBuffer sb = new StringBuffer(“TestString”); sb. delete (1,4); 4、insert方法public StringBuffer insert(int offset, boolean b) StringBuffer sb = new StringBuffer(“TestString”); sb.insert(4,false); 该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"马哲","slug":"马哲","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T10:24:16.944Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"http://example.com/posts/7a46f93c.html","excerpt":"","text":"第一天立德树人是教育之本 民主党派成员最多的是民盟 新民主革命的动力包括：工人、农民、小资产阶级、民族阶级 马克思主义哲学是无产阶级世界观 我党把马列主义和中国实际相结合的最初成果：《中国社会各阶级的分析》、《湖南农民运动考察报告》 1956年4月，毛泽东同志提出“百花齐放，百家争鸣”是我国发展科学、繁荣文学艺术的方针 习近平外交思想始终坚持实践第一的观点 古田会议决议了中心思想是要用无产阶级思想进行军队和党的建设（第九次党代表大会） 八七会议结束了陈独秀右倾投降主义在中央的统治，确立了土地革命和武装反抗国民党反动派的总方针，并发动了农民进行秋收起义（大革命失败后） 洛川会议为了动员一切力量抗日，并具体指定、建立党领导抗战的纲领和政府。 遵义会议是中国共产党第一次独立自主地运用马克思列宁主义解决自己路线、方针和政策的会议。挽救党、挽救红军、挽救新中国，是生死攸关转折点，提出红军应该采取积极防御的战略方针 邓小平提出了一国两制 陈独秀上海创办《青年杂志》，后改名《新青年》（它也是中国共产党第一个公开性机关刊物），迁往北京成为新文化运动的主要阵地，标志着新文化运动的兴起，口号为民主和科学，没有参加中共一大 董必武参加了上海兴业路一大会址纪念馆。为纪念馆写下了“作始也简，将毕也钜”。他出席了中共一大 李大钊是中国传播马克思主义最早的革命先驱，被称为“引来天火的人”，没有参加中共一大 《中国革命和中国共产党》一文中，毛泽东指出现阶段的敌人是帝国主义和封建地主阶级，主要任务也是干这两个，但最主要的是干帝国主义 党员开除党籍，五年内不得重新入党 生产实践、社会实践、科学实践，最基础的最重要的是生产实践 两个务必是毛泽东提出来的，在七届二中全会（务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续地保持艰苦奋斗的作风） 三湾改编首次提出官兵平等 毛泽东思想初步形成的标志是农村包围城市 1927年8月1号，八一南昌起义，让南昌获得了英雄城市的美誉 第二天十三大概况“一个中心、两个基本点”基本路线（一个中心，指以经济建设为中心；两个基本点，指坚持四项基本原则，坚持改革开放。），第一次比较系统地概述了社会主义初级阶段理论。 十二大提中特 十五大邓小平指导 十六大三个代表 十七大科学发展观 十八大全面建成小康 一大建党，二大立岗 三大国共合作 一大立党二立纲，三大国共要合作。四大领导工农忙，五大批评陈独秀。六大苏联求帮忙，南昌打响第一枪。八七枪杆出政权，三湾军队要听党。古田军队建新军，遵义军事与组织。瓦統洛后。毛六六论马🐎，七大确定毛指导。七届二中转城市，八大主矛和建设。十一三中要开放，十二小平提中特。十三阶段路线定，南方三猫论本质。十四目标在市场，十五小平成指导。十六提出三代表，十七科学发展观。十八科学成指导，十九走进新时代。 党的一大在莫斯科召开 陈独秀和李大钊都未参加一大 我国对资本主义工商业进行社会改造的基本政策是“和平赎买” 科学发展观第一要义是发展，核心是以人为本，基本要求是全面协调可持续性，根本方法是统筹兼备 马克思主义中国化的第一个重要理论成果是毛泽东思想 我国经济已经由高速增长转向高质量发展 红船精神是敢为人先的首创精神 长征精神是把全国人民和中华民族的根本利益看得高于一切 意识反作用于物质的基本途径是实践 我国进行土地改革的基本原因是封建土地制度阻碍了农村经济和社会的发展 社会主义的根本方向是消灭剥削、消灭两级分化 《实践论》《矛盾论》标志着毛泽东哲学思想形成 邓小平邓小平南方谈话内容是‘三个有利于标志’（两力一平）（是否提高生产力、综合国力、生活水平）（黑猫白猫，能抓老鼠就好） 一国两制是邓小平提出来的 十五大将邓小平理论写入党章 《星星之火可以燎原》毛主席回复林彪的，林彪问毛主席红旗还需要打多久 《论联合政府》是七大提出的，主要弄了三大作风，（理论和实践相结合，与人民群众紧密联系在一起，自我批评） 实践决定意识，是因为实践具有直接现实性（通过实践，直接可以变成现实，比如盖一个房子，直接就有了） 实践具有主观能动性，因为它是有目的有意思的去实践，这是和动物区分的，比如动物也会盖房子，它们没有目的和意识 实践具有社会历史性，具有社会性受到历史条件的制约，比如你实践割麦子，有条件用机器，没条件用手 意识是对客观世界的主观反映，意识的内容是客观的，表现形式是主观的 所有的意识都要来源于客观存在 无产阶级领导的中心问题是农民问题（农民也是最多的，主力军） 外因要通过内因起作用（比如说你妈妈天天唠叨你好好学习，这是个外因，但如果你不听，也起不到作用） 党的性质是先进性和纯洁性 毛泽东最先提出马克思主义中国化（马66论马） 社会的基本矛盾是社会发展的基本动力（社会基本矛盾包括：生生经上。生产力和生产关系，经济基础和上层建筑） 生产力决定生产关系，生产关系反作用于生产力（反作用是两面的，好的促进，坏的抑制） 生产力是人类改造自然的能力（人与自然），生产关系是人们之间的关系（人与人） 马克思的两大发现：唯物史观、剩余价值学说 红船精神包括：开天辟地、敢为人先的首创精神，坚定理想、百折不挠的奋斗精神，立党为公、忠诚为民的奉献精神 第三天神州十号载人飞船，男的有聂海胜、张晓光，女的有王亚平，其中，聂海胜担任指令长 中华名族由危亡走向振兴的转折点是抗日战争的胜利（党的是遵义会议） 主次矛盾与矛盾的主要方面（主次矛盾讲的是不同的事情，至少是两件事，比如发展面对经济、环境、人口问题等）（矛盾的主要方面是讲的一件事情，例如科技是把双刃剑） 群众路线的核心是一切为了群众，一切依靠群众 延安精神的核心是自力更生、艰苦奋斗 中共七大还没有建国，八大规模大 机械唯物主义（形而上学）（原子是事物的属性） 朴素唯物主义（看到的） 物质的唯一特性是客观实在性（不随人的意志改变），唯一属性是运动 实践是认识的来源，一切认识归根到底是从实践中获得（实践是认识的唯一源泉）（但实践不是认识的唯一途径，也可通过视频、图片等认识） 实践是认识的发展动力。实践中遇到的新问题需要新认识去解决，从而推动认识的发展 （前两个实践：先有实践。后面两个是先有认识。这样来做题） 实践是认识的目的，从实践中来，到实践中去，认识的目的是改造世界，到实践中去 实践是检验真理的唯一标志 毛泽东中国革命最后一个农村根据地是西柏坡（七届二中，提出了两个务必，进京赶考），像北平进发，进了北平香山，标志着中国革命重心从农村转向城市 意识具有目的性和计划性（比如想上岸，一天计划做多少题） 意识具有主动创造性（比如龙） 意识能指导实践改造世界（指导是中心词，包含正确和错误，考的时候要都说） 意识对人体的生理活动具有调节和控制作用（比如笑一笑十年少）（望梅止渴） 意识只有人有 意识没有客观实在性，物质才有 意识受到主题的影响（比如不同人看到同一个问题意识不同） 发展是前进性和曲折性的统一 发展有其自身的客观规律，不以人的意志为转移（种啥得啥） 毛泽东思想和中国特色社会主义的区别：毛不改革，中特不革命 建设现代化经济体系，着力点放在实体经济上 中华苏维埃第一次在瑞金召开 一国两制 ”爱国者治港“ 毛泽东思想围绕的主题是革命和建设 邓小平理论主题是什么是社会主义，怎样建设社会主义 十九大报告：以人民安全为宗旨，以政治安全为根本 三大规律：对立统一；质量互变规律；否定之否定规律 辩证否定的实质是扬弃。矛盾是事物发展的源泉和动力。辩证否定是事物联系和发展的环节。 大革命失败后，中国共产党建立的第一个农村根据地是井冈山根据地 中国革命农村包围城市、武装夺取政权根本在于处理好土地革命、武装斗争、农村革命根据地之间的关系 新民主主义的三大法宝：统一战线、武装斗争、党的建设 人民统一战线：工人阶级、农民阶级、名族资产阶级三者之间的关系 抗战统一战线：进步势力、中间势力、顽固势力 瓦窑堡会议确定了建立抗日民族统一战线方针 1938年《论持久战》提出了民兵是胜利之本 延安整风：反对主观主义以整顿学风（中心任务）、反对宗派主义以整顿党风、反对党八股文以整顿文风 意识对于客观事物的反映是主动的、有选择的（每个人看同一件事物的意识不同，比如蛋糕，艺术家看到的和普通人不一样） 第四天十八届三中全会提出市场在配置中发挥决定性作用（2013年习总书记主持） 十八届四中（2014）提出了依法治国 十八大（一选举，二宪法，三改革，四法律，五经济，六党建） 毛泽东思想灵魂包括：实事求是（根本点，出发点），群众路线（工作路线），独立自主（立足点）。 本本主义也是教条主义，就是做什么事情都不从实际出发，生搬硬套 在党的纪律中，政治纪律最重要、最根本、最关键 画梅不能止渴反映了观念东西不能代替物质东西 精神和物质的同一性，这个是你认为这个世界是否是可知的，如果你认为是可知的，就是同一的，这也是可知论 精神对物质的相对独立性：意识可能超前，也可能落后 精神可以转化成物质，通过实践 小康：邓小平提出放入国家。十二大提出，十六大建设，十八大建成 家庭是道德建设的起点，学校是道德建设的阵地 经济特区：生下三头猪（深圳、厦门、汕头、珠海）去海南度假，结果去了新疆喀什（kā shí）霍尔果斯 伟大载人航天精神：淡泊名利，默默奉献 实践高于理论认识，是因为实践具有直接现实性 第五天主要矛盾对事物发展起决定性作用 中国精神包括民族精神（核心爱国主义）和时代精神（核心改革创新） 爱国主义始终是把中华民族坚强团结在一起的精神力量，改革创新始终是鞭策我们在改革开放中与时俱进的精神力量 整体与部分关系：1.整体居于主导地位 2.关键部分对整体起决定性作用 3.整体是各部分的有机构成，具有部分没有的功能（比如说钟表，有计时功能，但是拆开后每个指针没有该功能） 中国共产党主题就是为了实现中华民族伟大复兴 实事求是的“是”为规律性","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"秋招","slug":"面","date":"2020-03-14T16:00:00.000Z","updated":"2023-05-04T07:35:45.655Z","comments":true,"path":"posts/7f1ae999.html","link":"","permalink":"http://example.com/posts/7f1ae999.html","excerpt":"","text":"秒杀测试jmeter 请求组 http请求 结果在监听器显示 redis引入redis setIfAbsent 和 setnxsetIfAbsent 是java中的方法setnx 是 redis命令中的方法 BoundValueOperations boundValueOperations = this.redisTemplate.boundValueOps(redisKey); flag = boundValueOperations.setIfAbsent(value); // flag 表示的是否set boundValueOperations.expire(seconds, TimeUnit.SECONDS); if(!flag){ // 重复 repeatSerial.add(serialNo); continue; }else{// 没有重复 norepeatSerial.add(serialNo); } 问题 b线程释放a线程的锁 可以在value随机值，然后删的时候判断一下还是原来的随机值吗，但是这个是一个过程，先查是不是原来的，再删，这不是一个原子操作。用lua脚本、 如何用lua 可以在服务器写好，然后调用，优点是方便，但是修改了或者调用有资源消耗了 在java代码里直接写麻烦 java代码里写 先在resources中创建一个lock.lua（要和application.yml同级目录） 在测试 threadlocal和synchronized区别 threadlocal原理 spring bean生命周期1.创建前准备，比如调用工厂的后置处理器2.对象实例化，根据bean定义，找到类信息，使用反射创建对象（默认用无参构造，如果没有无参(有一个有参，则用有参；如果有多个有参，报错)（有参参数是在spring容器里面找，先bytype后byname）） 3.对象属性装填，装填成员变量，如果成员变量有其他bean，则加载其他bean（比如autoware resource这些）4.执行初始化，某些对象可能有初始化方法，在此时调用 5.销毁 首先初始化，因为spring容器中都是存放的一个个对象。这个初始化是用反射创建，默认使用无参构造，（如果没有看上面）。然后对对象进行属性填充（依赖注入），比如autowire、resource等。然后某些对象可能有初始化方法，比如实现initiallizingbean方法，实现afterproperitiesset进行初始化。然后判断是否存在aop切入点，如果有，则创建aop代理类，放进spring容器里的也是aop代理类。最后销毁。 单例bean和单例模式不是一回事 spring事务加这样一个注解 数据库表设计规范 字段 加注释 3范式 建议有创建时间和修改时间 固定的用char 线程同步的四种方式一，什么是线程同步和互斥 同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。 解决 方法一：使用synchronized关键字 方法二：wait和notify 线程间通信的几种实现方式方式一：使用 volatile 关键字 方式二：使用Object类的wait() 和 notify() 方法 Session的执行流程浏览器发起一个请求到服务器，服务器先检查是否携带了一个叫做JSEESIONID的Cookie。 如果有携带，会将此cookie值取出来（比如abc），然后从服务器的session池中找到ID为abc的session返回给调用者。如果没有携带JSESSIONID 这个Cookie，服务器就会自动创建一个session对象并且生成一个随机字符串（abc）作为此sessionID保存到session池中，在服务器为客户端响应时会自动创建一个键为“JSESSIONID”，值为“abc”的cookie对象让浏览器存储起来，以便下次访问的时候带着 怎么看走没走索引 解释Explain得到的结果 type 反应查询语句的性能我们主需要注意一个最重要的的 type 的信息很明显地体现出是否用到了索引： type 结果值从好到坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到 range 级别，最好能达到 ref 级别，否则就可能出现性能问题。 possible_keys: SQL查询时用到的索引。可以看到，没加索引时，possible_keys 的值为 NULL，加了索引后的值为 address，即用到了索引address(索引默认为(column_list)中的第一个列的名字). key 显示SQL实际决定查询结果使用的键(索引)。如果没有使用索引，值为NULL可以看到，没加索引时，key 的值为 NULL，加了索引后的值为 address，即决定查询结果用到了索引address rows 显示MySQL认为它执行查询时必须检查的行数可以看到，没加索引时，rows 的值为17，即数据表student中所有数据，说明没加索引时的SQL查询是全表扫描； 加了索引后，rows 的值为6，数据库表中address以“北京市”开头的一共也就6条，SQL在执行查询操作时，一共也检查了6行，不必进行全表扫描查询，可以很容易得出结论：加索引的SQL查询性能远高于不加索引的情况。 模糊查询不走怎么解决 通过业务手段避免，举个实际栗子，博主之前做了一个汽车仓储项目，需求要求汽车表查询时候，车架号要有模糊查询操作，但是实际上对于车架号这个东西有个特殊的业务属性，就是车架号的后六位，基本可以在全省锁定到某一台车，全国不会超过三台车。所以业务人员在实际使用系统的时候，也只是输入后六位进行模糊查询，因此，在表设计的时候就将车架号字段冗余了一个字段，用于存储倒序的车架号，在进行模糊查询的时候，使用这个倒序字段进行右模糊查询，从而达到走索引的目的。有些时候，通过业务手段是可以达到一个优化要求的。 内连接 解决地址https://www.cnblogs.com/Marydon20170307/p/15866354.html synchronizedhttps://blog.csdn.net/m0_53474063/article/details/112389756 循环依赖 （属性相互赋值） 自己写出来的比较好解决 ioc的话比较难解决，主要有两个问题 从单例池中，属性注入b，由于b没有，去创建b，创建的过程有需要注入a。此时a没有，死循环了 解决方法 半成品池 a一旦被实例化，就把他放在半成品池中（二级缓存解决，为啥用三级缓存，因为解决不了aop代理） aop代理问题 等于说有一个前置方法，在调用的时候提前创建这个代理类 负载均衡1、轮询法 轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。 2、随机法 随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子[5]。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。 3、最小连接法 最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。 Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用 Ribbon默认负载轮询算法原理默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。 注解LoadBalancer 查看内存使用情况1 查看系统内存freenetstat -anp |grep 端口号 top 查看进程 cup使用情况 内存的使用情况 ** Load Average**load average: 1.79, 2.10, 2.28 系统负载，三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。如1.79，表示最近一分钟平均负载。 free -h ps 可以看pid 这个杀死用，也可以看cup使用情况内存使用情况 断开通信除了四次挥手还有什么方式？ 如果主机需要尽快关闭连接（或连接超时，或端口、主机不可达）时，发送RST包（RST表示复位）强制关闭TCP连接。 发送RST包关闭连接时，可以丢弃缓存区的包直接发送RST包，而接收端收到RST包后，也不必发送ACK包来确认。 线程池场景https://www.bilibili.com/video/BV1dt4y1i7Gt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc（B站） 报警那块 我是把每个传感器作为一块子的，每一个子的都用线程池 这里设置了一个计数器来阻止主线程继续，让主线程等线程池中弄完再走 CountDownLatch 这个是同步工具类中的计数器，有几组（我这里是传感器的数量（这里就16了））设置初始值为多少","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}]}