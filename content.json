{"meta":{"title":"蜗牛","subtitle":"boの博客","description":"硕士 | 计算机科学与技术 | 网络安全","author":"蜗牛","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:02.559Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2023-04-12T13:50:02.620Z","updated":"2023-04-12T13:50:02.620Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://example.com/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.183Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:02.899Z","comments":true,"path":"List/index.html","permalink":"http://example.com/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.206Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-12T13:50:02.598Z","updated":"2023-04-12T13:50:02.598Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://example.com/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2023-04-12T13:50:06.249Z","comments":true,"path":"census/index.html","permalink":"http://example.com/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2023-04-12T13:50:06.292Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.270Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:06.334Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.228Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-04-12T13:50:02.919Z","updated":"2023-04-12T13:50:02.919Z","comments":true,"path":"List/galleries/index.html","permalink":"http://example.com/List/galleries/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:06.313Z","comments":true,"path":"resource/index.html","permalink":"http://example.com/resource/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:03.244Z","comments":true,"path":"List/tools/index.html","permalink":"http://example.com/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:03.201Z","comments":true,"path":"List/movies/index.html","permalink":"http://example.com/List/movies/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-04-12T13:50:02.961Z","updated":"2023-04-12T13:50:02.961Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://example.com/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2023-04-12T13:50:02.940Z","updated":"2023-04-12T13:50:02.940Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://example.com/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-04-12T13:50:02.984Z","updated":"2023-04-12T13:50:02.984Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-04-12T13:50:03.006Z","updated":"2023-04-12T13:50:03.006Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:03.222Z","comments":true,"path":"List/music/index.html","permalink":"http://example.com/List/music/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-04-12T13:50:03.026Z","updated":"2023-04-12T13:50:03.026Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-04-12T13:50:03.048Z","updated":"2023-04-12T13:50:03.048Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://example.com/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-04-12T13:50:03.091Z","updated":"2023-04-12T13:50:03.091Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://example.com/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-04-12T13:50:03.068Z","updated":"2023-04-12T13:50:03.068Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://example.com/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-04-12T13:50:03.115Z","updated":"2023-04-12T13:50:03.115Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://example.com/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-04-12T13:50:03.179Z","updated":"2023-04-12T13:50:03.179Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://example.com/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-04-12T13:50:03.138Z","updated":"2023-04-12T13:50:03.138Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://example.com/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-04-12T13:50:03.158Z","updated":"2023-04-12T13:50:03.158Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://example.com/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"宪法","slug":"宪法","date":"2023-12-24T09:02:53.000Z","updated":"2023-12-24T09:09:02.038Z","comments":true,"path":"posts/f868c5a6.html","link":"","permalink":"http://example.com/posts/f868c5a6.html","excerpt":"","text":"重点有宪法民法行法刑法我们国家的统治阶级是人民，被统治阶级是敌人(那些被关进监狱的人)，对敌人要实行专政。无产阶级是领导。民主国家就是针对于专政来说的。比如说古代呢都是这个专政，那个专政，我们建立民主就可以保护更好的保护公民。宪法是政治法。我们国家的根本制度是社会主义制度。我们国家的根本政治制度是人民代表大会制度。根本任务就是解决现阶段的矛盾，比如说现在的现阶段的矛盾呢就是穷，所以说呢要解放生产力用具，官方的语言来说呢就是集中力量现代化建设。宪法的核心价值理念是保障公民的基本利益。(其实就是限制国家的权利，保护公民的权利。)民主事实化，法律是宪法是让每一个公民都拥有了权利，是限制，比如说国王啦这些等等。宪法为什么是国家的根本法？我们可以从内容和形式上进行回答。内容上他有几个章节，第一章呢是纲要，写了一些重要的改革了这些等等。第二章呢是公民所应该尽的义务和权利。第三章呢写的一些国家的机构。第四章呢写的就是一些国徽了，国歌这些(这里呢会考一些每章内容是什么，也可能会让你排序啦。)在形式上，宪法的具有的法律效力是最高的。宪法的制定和修改原则更为的严格。宪法要修改，首先要先有人提出来(全国人大常务委员会（这个是什么会呢？就是全国人大呃开的次数比较少，然后其他时间呢他都会有这个会来代替他，相当于说)还有1/5的全国人的代表)，然后再有修改主体(全国人大)，最后表绝（全体人员代表的2/3通过才行。注意，这里不是出席的，而是全体的。）我国宪法的基本原则人民主权原则这个原则非常好理解，就是说权力属于人民人，但人民太多了，所以说呢要选出代表，因为后来他们在开大会就是人民代表大会。基本人权原则这里呢就是生存权和发展权。法治原则比如说依法治国这些。权力制约原则这个在中西方是不一样的，在西方的更多的表现是权力的制衡，比如说他们有多个派这些等等。我们国家呢是相互监督。把权力的分散在各个部门儿，他们之间相互密切合作，相互监督。下面就是一些制约原则中的监督。比如说人民和人大代表，人大代表呢是由人民选出来的，他反映了就是人民的一个意愿，但是如果他做不好，人民可以罢免他。又比如说人民代表对那些国务院里面的当官儿的。又比如说公检法部门都有一些监督相互，举一个例子。公安机关的在调查一件犯罪事件，他先到现场去调查，调查完成之后呢，比如说他确定了一个人，这个时候他就要把这个交给检察院了（他进行审查)，然后检察院呢再就是交给法院。世界宪法注意，这里最早的是英国，但是第一部法典确实就是美国的。中国宪法历史1982年的是现行宪法后面的五次修改呢都是在1982年，那是宪法进行基础上进行修改的。这样记就行，6565。1982年加上六就是1988年这样算。国家基本制度国体与政体国体决定政体，政体体现国体。土地要么归国家所有，要么归集体所有，只有使用前才可以转让，他不可能归个人所有的。这个地如果在城市，那么就是寸土寸金，这个是归国家所有的，如果是在农村呢大部分是归集体所有，也有一部分呃在法律写字务之内的呃归国家所有。特别行政区制度行政管理权里面并没有国防和外交。立法权立的法要到全国人大常委进行备案。而且基本法不能进行自己立法。注意最后一条外事权并不等于外交权。与根本有关的找全国人大代表代表会。像备案了法律的备案了和基本法的一些解释因为法律是特别的抽象的啊，这些找常委会，因为常委会开的次数比较多嘛。剩下的国务院是搞管理的，就是说国防和那个外交，嗯，他们不能独立拥有，国务院可以管这个东西。民族区域自治制度注意这里的民族区自治和刚才的高度资质是不相同的，没有之前的那个权利高。这里要要看一些自治地方，和自治的机关。两个都符合才行，举个例子比较说。某某自治村算不算民族区域自治？答，这个是不算的，因为没有村这个组织。内蒙古自治区人民法院算不算？答，这个也不算的，虽然内蒙古自治区属于这个呃自治区，但是最高法院它并不属于自治机关。这个第三条考的是比较多的，呃，这里简单的解释一下，就是说这个常委会呢里面的主任或副主任至少得有一个是民族的人进行担当，另外下面呢是一些自治区的一些领导，他们必须有这个当地的一个民族的一个人去管理。简单的说呢就是干部优先权自治权简单的说明一下，比如说这个立法如果是国家层面的，那基本上要找全国人大和全国人大常委会这些，但对一些地方的呢啊，我们就可以呃分为普通的和民族民族自治的，普通的话就是说比如说山东这种啊，这种属于普通的，呃，对于民族自治的呢，就是我们说的这个第一条。哦，基本上就是呃就是上街的就是往上面报，就是全在人大常委会，嗯，然后呢不用备案啊，对于州和县呢，呃是对省里进行一个呃批准就行，嗯。村委会要设立啊，是要有那个乡政府进行一个牵头的哦，他们在由县进行一个批准。但是要注意呀，这个乡政府呢只能说是引导支持村委员会，但并不能是领导，你想想他们要自制呀，所以说不能领导，只能能支持。政协是干啥的？首先是政治协商，民族监督和参政社政选举制度基本原则犯罪不一定被剥夺政治权利，这个看题目上，嗯，有没剥夺这个权利？这里只能在一个地方进行选举票，呃，他的意思是如果这这个地方属于就是上下级关系啊，就比如说历城区济南市，山东省这些我们可以一级一级往上弄，但是山东省呢比河南省这样的话就不可以了。直接选举和间接选举，直接的话一般来说都是乡和县，其他的一般都是间接选举这个匿名的话是可以委托给其他人的，但是要注意委托给其他人，那要那个人也有选举权利国家机构权力机关地域代表制就是一级一级选上来的，职业代表就是军队里面的。职权宪法要2/3的通过才行，普通法了一半就行。这样机三席两长一主任。注意，如果是领导关系，那么既可以改变也可以撤销，如果只是监督关系，那我只能撤销，不能改变。全国人大与全国人大常委会是一种领导关系。12和14条考的常委会注意这里面的委员长和副委员长。他们不能连任超过两件之前的全国人大里面的都是可以连任的，还有上述这些官员都是全国人大选举出来的。职权也就是解释和制定非基本法律，什么是非基本法律呢？就是除了民事，刑事法这些等等。这里要注意乡是没有乡人常的。监督只能撤销第八条注意，除了总理不能任免，其他的都可以，这是在与全国人大的不同，但他是在避讳几点。人大代表注意人的代表并不是不能够逮捕，而是会比较麻烦，如果说他不受逮捕一定是错误的。还有就是县级以上对于乡的人大代表，报告一下就行了，权利没那么大。国家主席注意，政府首脑是国务院主席，并并不是国家主席。你可以看出国家主席任免的都是国务院里面的人。这里需要注意的是首先乡镇是只有乡镇政府的，其次要注意是派出机关和派出机构派出机构呢，就比如说是派出所，他是上面派下来的，呃，加强这个地方的管理，它并不属于这个地方。啊，比如说乡镇南派出所。他就属于县了这些。派出机关呢，它更有自己的独立性，它可以自己的名义去招收了这些啊，比如说我们所说的街道办事处。国务院注意这里的最高权利执行机关是国务院，决定的机关那就是全国人大了。这里如果有谁出了问题，都是一把手负责。宪法是全国人大，法律是全国人大和人常，行政法规是国务院，地方法规呢一般就是省和设区的市的人大和人常制定，规章制度呢，就一般的可以有部门规章和地方规章，这个地方规章呢也只有省和设区的市制定看三四条就可以看出来，我国国家的行政部门都是领导关系，上下级关系。领导他都是可以改变和撤销的。对于建设和区域划分这些全国人大他只负责一省一级的建制。什么是神一级的建制呢，就比如说有没有山东这个省？省一级政府他主要决定是乡镇的这些。剩下的都是国务院的。举个例子，省一级的区域划分，这是归谁管？归国务院管。因为全人大，他只负责建制。还有紧急状态。全正常呢，它是决定全国进入竞争状态或者是呃个别省就是个别省，这个个别省的就是省全体。。国务院呢是决定个别地区进入。中央军委委员会注意，全国人大常委会里面的呃有任期限制是两届。还有国务院里面的也有，根据限制也是两届监察委员会的主任也是不得投两届司法机关注意，公安机关不属于司法机关，他属于行政机关。我国的司法机关只有人民法院和人民检察院。人民法院国家级别的有最高法院。省级的有省高法院，比如说呃什么什么省最高法院，这个法院里一个省最多有一个。市的话，就一般来说是市中院。县的话，比如说是基层人民法院。注意上下级法院是监督关系，并不是领导关系。最多就二审，比如说你先提交，那就到基层，你不服就到市里面。检察院他是法律监督机关。他对本层负责和对上层负责。检察院也是领导制度。监察委员会监察委员会上下级是领导关系。和检察院呃整体的知识框架基本上是一样的，除了他的行政功能不一样。这里的任期届数，全身长，国务院他们的正的和负的都是有任期的。最高人民法院，最高人民检察院，国家监察委他们的老大是有任期的这里的上下级关系有有上下级政府。分为领导和监督。对于领导：全人大和全人常，还有行政系统里面的，比如说国务院和地方政府，我上下级检察院，上下级监察委。对于监督关系主要是同级权力机关和其他机关，比如说全国人大和全国人大常委会与国务院，这个国务院是由全国人大产生，嗯，对全国人大负责，受全国人大监督。还有上下级权力机关，比如说山东省人大和济南人大，这个省的肯定肯定对济南有监督关系。还有上一级法院也是建立关系。最高人民检察院他行驶的是法律方面的监督。中共中央纪律检查会看到中共中央，它就是属于党的一个东西。","categories":[],"tags":[]},{"title":"公文常识","slug":"公文常识","date":"2023-10-12T12:32:42.000Z","updated":"2023-10-28T14:37:56.015Z","comments":true,"path":"posts/c70ef8c4.html","link":"","permalink":"http://example.com/posts/c70ef8c4.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"历史","slug":"历史","date":"2023-08-19T07:37:54.000Z","updated":"2023-10-28T14:37:56.015Z","comments":true,"path":"posts/7f288e9.html","link":"","permalink":"http://example.com/posts/7f288e9.html","excerpt":"","text":"原始社会 陕西蓝田这里有玉 四大名玉：新疆和田玉、陕西蓝田玉、河南南阳独山玉、辽宁岫岩玉 这里到了农耕文明了 河姆渡 河姆渡这个在浙江宁波发现的，是母系社会 干栏式房屋，这个是两层，上层住人，下层放东西，动物啥的（南方空气湿热，第一层不好，所以） 半坡遗址 半坡遗址是陕西西安，属于北方了，也是母系为主 这里的粟（shu）其实就是小米 半地穴住屋，由于北方比较冷 大汶口遗址 在山东泰安，是父系社会了 有私有制了，有贫富差距了 五谷 水稻、黄米（黍shu）、小米（稷ji（江山社稷），也叫粟）、小麦、大豆（叔shu） 六畜马牛羊鸡狗猪 三皇五帝 三皇 伏羲主要成就八卦 八卦包括：乾(qián)、坤(kūn)、坎(kǎn)、离(lí)、震(zhèn)、巽(xùn)、艮(gèn)、兑(duì)*。代表古人最敬畏的天、地、山、泽、雷、风、水、火 五帝 皇帝vs炎帝（他两个是两个部落的首领）（他两打了一场阪泉之战，最终皇帝赢了） 皇帝被称人文初祖、或者轩辕氏也是他 涿鹿之战炎帝、皇帝联盟打蚩尤部落 舜，小时候老惨，但后来品格高尚、技术高超，农业、商业等都很牛，所以就有人给尧举荐他，尧就考察了一下他，把两个女儿嫁给了舜，最后发现这小子确实不错 ，就禅让给了他 夏商周时期夏朝 禹 大禹治水（以前都靠堵，禹靠疏通） 三过家门而不入 夏历 是看月亮的运行轨迹定的 太阳称阳、月亮称阴，所以夏历又称阴历 商朝 中国文中演变 甲骨文–》金文–》大篆–》小篆（秦）–》隶属–》草书–》楷书（正书）–》行书 隶属（他是古今汉字的分水岭，之前是象形文字）（隶属的特点是蚕头燕尾，一淑三折） 记忆：甲骨金文大小篆，隶草楷行一大串 甲骨四堂 研究甲骨文比较多的四人 罗振玉、王国维、郭沫若、董作宾 四大古文字 甲骨文、象形文字（古埃及那边）、楔（xie）形文字、玛雅文字（美洲那边） 灭亡 商纣王最后一代国君 牧野之战：武王伐纣 临阵倒戈：这个就是出现在牧野之战，商纣王的军队叛变了，来干自己。 西周都城在西安一带 井田制 归国家所有 宗法制 嫡长子（正妻之子）继承。其他的儿子降级 爵位 西周比较重视爵位，包括：公侯伯子男 爵位是可以世袭的 国人暴动 周厉王时期，比较残暴 然后周厉王逃了，可以周公和邵工共同行政 灭亡 周幽王成谜美色 褒姒平时不爱笑，周幽王就逗她，用烽火台。古代烽火台是战争用的，然后各路诸侯都一位周幽王遇到困难了，就都来了，然后褒姒就笑了。 逐渐周幽王在诸侯当中就失去了信用 东周春秋标志着奴隶的结束 这时候有铁器和牛耕了，可以自己开拓土地了 春秋五霸 第二种说法常见点 齐桓公 齐桓公是第一个称霸的，用管仲做的宰相 管饱之交：管仲、鲍叔牙他们是好友，但辅佐的公子不一样，鲍叔牙辅佐的是齐桓公、管仲是另外一个公子，当时说这两个公子谁先回来谁当王，管仲射了齐桓公一剑，但没有射死。后来齐桓公先回来了，他称王了，鲍叔牙就举荐管仲，说他虽然射你，但人不坏，还很有才，后来齐桓公也用管仲了，齐桓公肚量大啊。（这也是后来说的一箭之仇） 长勺之战：之前的齐国和鲁国战斗（山东那里，现在山东称齐鲁）(这里有个曹刿论战，曹刿是鲁国的)（最终以鲁国取胜） 老马识途：形容阅历比较足。 晋文公 退避三舍：这个发生在晋楚两国。晋文公受到过楚国的恩惠，说以后和楚国如果打仗，就退避三舍（一舍就是30里）（但后来打起来了，就是城濮之战，晋王公是以退为进，诱敌深入） 秦晋之好：这个就是联姻 寒食节：纪念一个重要人物，叫做介子推（这个人辅佐晋王公，从上位到发展，后来和母亲归隐，晋王公想让他继续辅佐，就放火烧山，但介子推也没有出来，为了纪念他）（寒食节是个节日，这个节日不能用火） 楚庄公 一鸣惊人：楚庄王前期不怎么治理过来，后来奋发图强，一鸣惊人 问鼎中原：、饮马黄河：都代表想统治中原 勾践 鸟尽弓藏、鹿死狗烹：勾践的两个谋士（文种和范蠡），勾践就是能和他们共患难，不能同富贵，后来范蠡去经商了 积累 半斤八两：古代的半斤就是八两，形容差不多 一日不见，如隔三秋：三秋是三个季度 战国标志着封建社会的开始 秦灭其他国的顺序 韩、赵、魏、楚、燕、齐（喊赵薇去演戏） 主要战争 桂林之战 齐国孙膑、魏国的庞涓（pangjuan） 马陵之战 当时魏国想打韩国、韩国求助齐国 减灶诱敌 长平之战 赵国廉颇（后来被秦国使用离间之计，器用廉颇，改用赵括（他懂得多，但实践不行，就纸上谈兵）） 主要变法 商鞅 贡献很大，让秦强大起来，干掉了六国。但他比较自负，后期变法得罪了不少人，死的比较惨 徙（xi）木立信：一开始缺少群众基础，他说谁能把木头从一个城门搬到另一个城门，就给丰厚奖金，一开始没人相信，后来真的有人去做，也得到了奖金，取得了百姓的信任 作法自毙：动摇了贵族的利益，贵族是世袭，商鞅说要按照军工授予爵位，得罪了很多人，后来被流放。（作法自毙这个就是说自己设的规矩，后来自己被这个规矩套住了。商鞅想出城门，但看门的说商总有令，到点了不让出去。然后住店，店家要他身份证明，他是逃跑不能说，这个规矩也是他立下的，所有他出门就说自做自毙） 五马分尸：他的下场 郡县制 中央加强县的管理 第一部比较系统的法典 《法经》李愧（kui）魏国人 这是第一部地主阶级法典 战国四君子 信凌君 秦国打赵国，赵国求魏国，魏国也害怕 ，偷兵符救赵 孟尝君 齐国的 他出使秦国，被扣了，装狗装鸡跑了 春申君 想获得楚王的信任，为了楚王有后代煞费苦心，给了很多美女，但是楚王不行，多少美女都不行。后来这点心思被李园发现了，就把自己的妹妹给了春申君，给楚王也没用，给春申君后三个月就怀孕了，这时候就再给楚王，哈哈 其他 都江堰 非常牛，抗洪 黄帝内经 最早的医书 中医四大经典：《黄帝内经》、《难经》扁鹊做的、《伤寒杂病论》、《神农本草经》 岐黄、青囊、杏林、悬壶 这些词与医术有关 秦汉时期秦朝统一全国 是第一个统一的中央集权封建国家 正月为啥叫（zhen一声，不叫四声，主要是为了避讳嬴政） 沙丘之变 三公九卿 三公是丞相（掌管行政）、太尉（掌管军事）、御史大夫（监察） 统一货币 半两钱 修建长城 基本都在修，就元代、唐代、清代没修 孟姜女,他不信孟，他的丈夫也不信孟（因为古代有的女子是把丈夫的信放前面），这里的孟是排行，（伯（孟）、仲、叔、季），表明这个孟姜女应该是大老婆（但可能是庶出，正出的话是伯） 四大民间传说：孟姜女哭长城、牛郎织女、梁山伯与祝英台、白蛇传 灭亡秦朝是比较短命的，有修这修那，比较暴力 第一次农民起义 大泽乡起义是当时弄东西，去晚了得死，陈胜他们赶不到了，去了也是死，不如造反 揭竿而起、鸿鹄之志 巨鹿之战 这个是项羽起义打的，这里面有个典故叫破釜沉舟 约法三章 这是刘邦的 垓下之战 楚汉之间的决战 四面楚歌、霸王别姬 西汉 汉高祖（开国皇帝叫什么祖） 汉初三杰张良（运筹帷幄（有计谋，刘邦夸赞张良的）、孺子可教（之前有个老头，鞋掉桥东了，让张良捡，张良虽不情愿、但尊老爱幼还是捡了，老头说明天给你个好东西，但是第二天张良迟到了，老头说你咋是个这，过两天再给你吧，然后张良为了不迟到，天不亮就去等老头，老头看到，说孺子可教也。然后给了张良一本兵书，这本兵书帮了张良很多）） 萧何（萧规曹随（他制定的政策后面的人跟随）） 韩信（胯下之辱、背水一战、多多益善、明修栈道暗度陈仓）（国士无双（一开始跟着项羽，但得不到重用，后来萧何举荐给刘邦，刘邦也敷衍他，萧何就给刘邦说，这个人国士无双）） 诸吕之乱吕氏一党（吕雉，刘邦之妻） 刘邦死后，他儿子比较懦弱，大权都在吕后手里了 文景之治这时候是道家的黄老之术（与民休息，减少税啥的，让老百姓休息休息） 汉武帝 政治上 汉武帝幼年继位，那时候相都笼权了，他为了削弱相权，在频繁换相 之前秦的三公九卿，这些称外朝，就是皇帝不信任他们，然后选出一部分身份低微的（士大夫），让他们进入宫殿公事，直接指挥，削弱三公九卿权力。 刘邦在早期实行郡国并行制度（由于分封制导致诸侯权力太大，郡县制（中央集权太大）又太大约束），这个也导致了后面的七国之乱 推恩令：之前只能给嫡长子，现在说可以给老二、老三了，这样相当于越分越小 经济上 五铢钱：铢是个单位 盐铁官营：那时候盐和铁是不能买卖的 思想上 罢黜百家、独尊儒术（董仲舒提出的） 董仲舒写的《春秋繁露》，里面三纲五常 三钢：君为臣钢、父为子纲、夫为妻纲 五常：仁义礼智信 三年不窥园（说董仲舒非常好学，家里的园子三年没看） 张塞出使西域 丝绸之路 大秦在现在地中海那边（罗马） 霍去病 甘肃酒泉这个和霍去病有关 在霍去病打败匈奴后，喝酒庆祝，但甘肃这里酒很少，霍去病就把酒倒入泉水中，三军共饮 山丹马场 昭君出塞 青冢有情尤使路，平沙无处可招魂 青冢与王昭君墓有关 马致远《汉宫秋》与昭君有关 四大美女之一。落雁 东汉 班超 投笔从戎（弃文投武） 不入虎穴、焉得虎子 三国到两晋三分天下 两晋 西晋和东晋 西晋是司马炎、东晋是司马睿 官渡之战 曹操以少胜多 作用：奠定了统一北方的基础 赤壁之战 也是以少胜多 作用：魏蜀吴三国鼎立 夷陵之战 蜀吴两国交战 火烧联营（陆逊） 诸葛亮三次火烧时间 火烧波望坡（干曹操） 火烧新野（干曹操） 火烧赤壁（干曹操） 新官上任三把火就是这个典故 三国位置魏 洛阳 蜀 成都 吴 南京 典故 曹操 孟德献刀 煮酒论英雄：曹操问刘备 官渡、赤壁 华容道 十八路诸侯起义 杀吕伯奢 白门楼收张辽 刘备 桃园三结义 三英战吕布 三让徐州（徐州太守陶谦） 跃马檀溪（的卢马） 白帝城托孤（把儿子托福给诸葛亮诸葛亮） 关羽 单刀赴会 败走麦城 诸葛亮 七擒孟获 六出祁山 挥泪斩马谡 五丈原（病逝到这里） 南北朝 投鞭断流（形容强大，兵如果把马鞭扔河里，就能断流） 王与马共天天：王氏强大起来和司马家族共天下 北魏改革 汉化，迁都洛阳 隋唐时期大一统了 隋文帝 定都长安 开皇之治 隋文帝取代了北周 一衣带水：隋文帝统一了北方，当野心不止于此。他把北方治理的可好，就说，和南方一水之隔，怎么忍心南方受苦。（这里的水是指长江，现在多指两个地方离得近） 隋炀帝 第二代皇帝 杨广 开通大运河、科举考试他创立的 中国三大工程 万里长城、坎儿井、大运河 唐代 开国皇帝 李渊，年号伍德。定都长安 唐太宗 李世民，玄武门之变让李渊立他太子，本来是李建成，给人家干嗝屁了 他治理的期间也是比较太平的盛世 他治理的是贞观之治，这也是他的国号 他也知人善用、虚心纳谏（比如魏征） 凌烟阁 这是李世民给他一起打江山的功臣进行纪念 给24位功臣画像 武则天 武则天是唐太宗招过来的，但招过来没多久就去世了，武则天就去当和尚了，但又被唐高宗（李志，唐太宗的儿子，第九子）看上了 贞观遗风 唐玄宗 唐高宗的孙 开元盛世是他的 进入了全盛时期，也开始由盛转衰了，物极必反 安史之乱 这是由盛转衰的转折点 唐玄宗立即推，杨贵妃，一人得道，鸡犬升天 黄巢起义 加快了唐朝灭亡 黄巢失败了，后来朱温拿下 黄巢爱写诗，爱写菊花。 唐朝制度科举制度 三省六部 注意之前朝代有五官 分别位司马（管军事）、司空（管建筑、水库这些）、司徒（管民）、司士（督察百官）、司寇（管刑狱） 其他 农业 曲辕犁 茶叶 陆羽（被称为茶圣），还写了茶经 还有国际茶日：521 商场 市 宋朝 开国皇帝 宋太宗（赵匡胤） 靖康之变，这里的靖康就是岳飞的靖康耻 文天祥抗元，被腐乳，过零丁洋，人生自古谁无死，留取丹心照汗青 金：是女真族，很强大 崖山海战 （南宋）宋朝不行了，被元朝打的嗷嗷叫 先北宋在南宋 其他 汴京就是开封 上京，内蒙古一代 会宁，黑龙江 兴庆（宁夏）","categories":[],"tags":[]},{"title":"经济学","slug":"经济学","date":"2023-07-12T12:26:30.000Z","updated":"2023-11-25T10:15:25.461Z","comments":true,"path":"posts/d315c0a7.html","link":"","permalink":"http://example.com/posts/d315c0a7.html","excerpt":"","text":"物质资料生产三要素劳动者的劳动 劳动资料（生产工具）（生产工具体现生产力，而非生产力的决定性因素。在生产力诸要素中，最活跃、起决定作用的要素是劳动者。） 劳动对象 物质资料生产过程生产 &gt; 分配 &gt; 交换 &gt; 消费 &gt; 生产（消费了，有钱了，再生产） 分配 、 交换 、 消费 对生产都具有反作用 消费是是物质生产的最终目的和动力 消费为生产创造出新的劳动力（可以这么理解，你买买买，没钱了，就去赚钱吧，就成了新的劳动力） 商品 含义 商品必须用于交换，必须投入人类的劳动 （武汉疫情捐赠物品是商品吗？不是，因为没有交换） 二要素 使用价值和价值 使用价值（就是有用性，比如水可以解渴）（有使用价值，商品才能交换）（使用价值是价值的物质承担着）（使用价值是商品的前提） 价值（凝结在商品中的无差别人类劳动） 有价值的东西一定具有使用价值 商品的价值依赖商品的流通 关系 比如说，你种菜，没有去卖，自己吃，这里有使用价值，是人与自然的 价值，比如说，你生产了一个东西，你觉得有价值不行，要别人也觉得，这展现了人与人 劳动的二重性商品的使用价值和价值是由劳动二重性决定的 二重 具体劳动（看的见的，比如你干活） 抽象劳动（撇开具体形式的无差别劳动，不管脑力还是体力） 与商品的关系 具体劳动创造商品的使用价值 抽象劳动创造商品的价值 货币概念货币是一般等价物 先有商品，再有货币 何为一般等价物 在古代，两个物品进行交换，比如说，我有小麦，你有蔬菜，我需要你的，你需要我的，咱两个进行交换。 但如果我需要蔬菜，但你不需要小麦，就很难受，这时候出现了一般等价物，类似于媒介 一般等价物固定后就是货币 一般等价物本质就是商品 职能 价值尺度：比如你买东西，上面有标价，这就是价值尺度（为什么货币有价值尺度？因为货币自身有价值，它也是一种商品）（只需要观念上的就行，这个价值高，这个价值低） 流通手段：充当商品交换的媒介（一手交钱，一手交货）（货到付款） 支付手段：延期支付（时间差，不同步）（比如税收、工资、利息） 贮藏手段：只针对金属货币（金子、银子） 世界货币：世界都能用 总结 价值尺度最基本，然后是流通手段。纸币的话只有流通手段和支付手段，没有价值尺度，因为本身没有价值 流通规律 总结 商品的价格水平与商品流通中需要的货币量成正比。 货币的流通速度与商品流通中需要的货币量成反比。 商品的流通数量与商品流通中需要的货币量成正比。 价值规律商品价值量和社会必要劳动时间有关，成正比，与社会必要生产率成反比 价值总量与个别劳动时间成反比，与个别劳动生产力成正比，与社会无关 商品交换要以价值量进行等价交换（但不是每一次的交换都是等价交换，比如说超市打折） 表现形式 价值决定价格，供求影响价格 等价交换是从整体来说，从上面的图可以看出，针对某一部分来说，可能高也可能低，但整体是一样的 价值的货币表现形式 价格 价值的表现形式 交换价值 交换价值是价值的表现形式，价值是交换价值的基础 交换价值是指一种商品与另一种商品相交换的量的比例或关系。 剩余价值资本不变资本（不发生增值，比如原材料） 可变资本（这里劳动力是可变资本） 剩余价值 注意 凡事提到剩余价值，都跟利润相关联 来源 工人劳动时间分为必要劳动时间（付给你工资，应该干的）和剩余劳动时间（被压榨的） 劳动力和劳动 不一样，劳动力的使用才是劳动，这里的劳动会有剩余价值，压榨 劳动力成为商品的条件 自己的自由 除了劳动力别的没啥可卖了（农民不是，农民有地）（无产阶级是） 资本家钱生钱 必须通过劳动力 剩余价值率 这里的可变资本是买你的价格（因为可变资本才能有剩余） 例题 资本有机构成 有机构成=不变资本/可变资本 产生方法绝对剩余（加时长，加班） 相对剩余（提高效率，针对整体）效率都提高了 超额剩余（个别资本家通过提高劳动生产率，使自己的商品价值低于社会价值的，这个差额就是超额剩余价值）（针对个别） 资本周转 基本主义基本矛盾 生产过剩是相对的，买不起，和卖不出去 （上面是资产阶级）收入分配 初次分配就是有钱的出钱，没钱的出力，然后按照产生的效率分配（这种分配会拉大贫富差距） 因此有了再分配，再分配比如交税，赚的多交的多，缩小差距，尽量让中等收入者占大多数 第三次分配，比如捐赠这些 初次分配一般与企业和社会有关（比如最低工资标准）（手段就是市场机制） 再分配一般是政府（手段是宏观机制、税收等）（比如税收、社会保障、转移支付） 总结 初次分配=社会，再分配=政府，第三次=慈善相关初次分配：最低工资标准、企业职工正常增长机制 再分配：税收、社会保障、政府转移支付（财政划拨等无偿支出） 第三次分配：社会公益事业：民间捐款、志愿者行动 只有公有制（国有经济，集体经济）才有按劳分配（多劳多得） 非公有制： 个体经济（按个人劳动进行分配） 私企、外企（按生产要素进行分配）（生产要素：管理、劳动、土地、技术） 现代企业制度 这里的法人是可以承担责任的，不是一个人（公司就是法人） 现在企业制度的基本特征是：产权清晰、权责明确、政企分开、管理科学 有限公司和股份有限公司主要区别：是否将公司划分为等额的股份 股东会是谁投的钱多听谁的 董事会是看投票的人头数 价值机制是核心供求是主体竞争是动力风险是基础 需求 收入是消费的前提和基础 互补商品（比如汽车和汽油） 边际效应 你特别饿，吃第一个包子带来的效应大，第二个就会减少（再吃就吐了） 边际效应随着需求量（或者消费数量）的增加而减少 随着需求量的增加，收获效益小了，所以顾客愿意付钱也少了 总效用和边际效应 效应就是满足感 总效应就是总满足感 边际效应就是新增的满足感 当达到一定的度时，总效用会减少，边际效应会为负数（比如吃包子，吃饱了再吃就难受了，总效应减少，边际效应为负数） 需求弹性 需求的价格弹性&gt;1，证明富有弹性（需求量对价格变动敏感），反之，是缺乏弹性，不敏感，等于1是单一弹性 大于1的基本都是昂贵的物品，比如珠宝，价值变动一点，大家都会觉得有利可图 小于1的基本都是生活必须品 正负的 需求收入弹性是指收入变动幅度所引起的需求量的变动幅度，即需求量的变化率与收入之间的变化率之比。生活必需品和奢侈品都属于需求收入弹性为正的正常品，劣等品的需求收入弹性才为负。 供给 商品价格：越高就赚钱越多，供给增加 技术：技术牛，产生的多，供给多 相关产品：替代品价格增加，替代供给增加，本产品供给下降（厂家更愿意制造利润大的） 市场失灵 外部性 生产和消费都会产生（正的和负的） 生产： 比如养蜜蜂在果园旁边，则果园给养蜜蜂的正外部 化工厂排污水对稻田有负外部性 消费： 正向的（你买了声控灯，你自己费电，人家经过也能用） 负的（比如吸烟） 信息不对称 这个针对买卖双方 比如说你买到了假货，卖方肯定知道的多 公共物品 比如说路灯，你消费的时候人家也可以消费，而且不会有额外成本 竞争类型 完全竞争，比如卖土豆，都一样，对价格完全没有控制，人家说的算（自由流动、产品无差别，数量多，交易零成本，几乎很难实现，农业近一点）（不需要打广告） 垄断竞争，比如买衣服的，每个厂家的衣服可能不一样，对价格有一点点控制 判断 垄断竞争市场存在着大量规模较小的企业，垄断竞争市场存在着较多的替代品，垄断竞争市场中的产品是有差别的产品，所以一家公司的降价，不会造成题干所表述的那么大的影响。如果说由一家企业降低了物价。其他企业受到很大影响那么这就是一个寡头垄断 宏观调控 原因 自发性：损人利己，比如违法犯罪，发国难财，造假 盲目性：盲目跟着人家 滞后性：时间差， 手段 经济：财政（收或者放）、货币（中国人民银行）法律： 政治：命令、举报打击 最主要的手段是经济手段 目标 两增一稳保平衡 两增（经济增长、增加就业）（经济增长就行，没说加速增长） 稳定物价 保持国际收支平衡（避免过多的顺差或者逆差） 宏观调控的一个目标就是增加就业以达到充分就业，在实际统计中，一般用失业率来衡量一国的就业状况。 总结 国家宏观调控的主要手段有行政手段、经济手段和法律手段。行政手段是采取强制性的命令、指示、规定等行政方式来调节经济活动，以达到宏观调控目标的一种手段；经济手段是指政府在自觉依据和运用价值规律的基础上借助于经济杠杆的调节作用，对国民经济进行宏观调控，财政政策、货币政策、价格、税收、信贷等都属于经济手段；法律手段是国家通过立法和司法，调节和规范经济活动的一种手段。 失业和通货膨胀 周期性事业 一般是出现经济危机 摩擦性事业 比如说跳槽 比如怀孕 毕业即失业 结构性事业 技能不匹配，比如技能更新了 能力不足 技术性事业 比如科技进步了，出现了机器，代替了手工劳动 季节性事业 比如旅游业 通货膨胀 供不应求 只有全面的、持续的商品物价上涨才会通货膨胀。 全面的是不仅一种物品价格上涨了，是很多 原因 成本上升，羊毛出在羊身上，物价会上涨 生活水平下降并不是针对所有人，主要是针对固定收入的人群 上面事业率和通货膨胀反方向关系，通货膨胀了，物价上涨，供不应求，要求员工造东西，失业率下降。反过来，失业率高，则经济萧条，说明卖不出去，供过于求，通货膨胀低。找到两者合适点最好 通货膨胀率 10%以内是温和。百分之百以上是超级通货膨胀。其他的都是奔放通货膨胀 宏观调控 行政手段是强制的 财政收入 税 是政府收入最主要的部分 是强制的、无偿的、固定的 取之于人，用之于人 上面拉弗曲线，税太高了也不行，企业交不起，那嗝屁 流转税：生产经营所得消费税，增值税，关税所得税：收益所得个人所得税，企业所得税，工资、稿费、彩票财产税：财产分配缴纳契税，房产税资源税：开采自然资源开采天然气石油行为税：行为特定土地增值税，印花税，车辆购置税，耕地占用税 利 利润，国家分红，或者出租啥 债 国债 增加国债属于扩张性政策（是把老百姓的钱集中到国家手里，再通过政策投入到建设中，这样市场中的钱就多了） 注意：要区分国家发行国债（财政政策）和央行买卖有价证券（公开市场业务，货币政策）；发行国债一般是基建型收回来就会花出去，属于扩张性财政政策；买卖有证券属于货币政策，出售的目的就是把钱收回来，属于紧缩性货币政策。 费 财政支出 购买性支出 看商品有没有回到政府手里，比如军需，有商品回去 转业性支出 没有回到政府手中，比如补助 总结 转移性支出指政府无偿向居民和企业、事业以及其他单位供给财政资金，这里比如说补助购买性支出也称消耗性支出，是政府用于购买为执行财政职能所需要的商品和劳务的支出，包括购买政府进行日常政务活动所需要的商品与劳务的支出和购买政府进行投资所需要的商品与劳务的支出。公共事业支付与公共投资支出都属于购买性支产性支出是国家财政用于同社会生产直接有关的各项支出。包括生产性基本建设投资、 公共投资支出指在政府财政支出项目中具有投资性质的支出，如修建公共设施，经营公用事业，主持公共工程等方面的支出公共预防性支出用于维持社会秩序和保卫国家安全、保障人民生命财产安全与生活稳定等方面的支出，包括国防、司法、公安与政府行政部门的支出 财政政策 货币政策 利率：存款利率、贷款利率 再贴现： （贴现：企业之间往来一般使用证券、汇票、支票这些），到期了再周转。但有的企业没到期就想周转，商业银行要扣除利息等， 比如说张三存款10w，存一年，但急用钱，所以提前取出来要，这时候就是贴现（银行扣除利息啥的，可能给你9w） 如果银行也急用钱，可以拿条去央行，这叫再贴现 目的：干预和调节市场利率和供求 总结： 法定存款准备金率是中央银行对商业银行规定的向中央银行交纳存款的比率，提高法定存款准备金率，商业银行上交的准备金就多，可支配的资金就减少了，属于紧缩性货币政策。 再贴现率是商业银行将其贴现的未到期票据向中央银行申请再贴现时的预扣利率。提高再贴现率意味着商业银行向中央银行预扣利率增加，从而减少了货币投放，直接减少货币供应量，属于紧缩性货币政策。 存款准备率 商业银行的钱必须一部分存到央行，这个比例（比如这个存款准备率是百分之十，那么商业银行有存款1000w，要想央行缴纳100w（为了保证人家取款的需要），这样放贷的钱就少了，提高这个率，可以抑制流动性过剩造成的通货膨胀） 目的：抑制流动性过剩造成的通货膨胀 公开 调节货币供应量，央行少了就卖，多了就买回来 调节货币供应 中介目标和操作目标和选择标准 中介目标是间接的，上述的都是中介目标 操作目标是直接的，但要等政策上后才能看到效果，是特殊型的 价格歧视就是差别定价 一级：按照每个的“心理价位”定价（比如讨价还价，比如你是卖东西的，看到一个穿的不好，就便宜卖，看到开好车的，卖他贵点） 二级：按照购买的量（比如，买多了便宜） 三级：按“人/市场”歧视（比如老人和小孩票便宜。比如说车子在中国和外国卖价不一样） 记忆：一级挨个坑；二级批量坑；三级分类坑 考察系数 基尼系数 对象：收入分配差异 结论：越低差距越小【0，1】 恩格尔系数 对象：生活水平 结论：恩格尔系数和生活水平成反比 他是食品的支出/总支出 小康（40%-50） 富裕（30%-40） 市场机制价值是核心 供求是主题 竞争是动力 风险是基础 价值规律最重要 价值规律—筛子【筛选，优胜劣汰】鞭子【抽打鞭策，刺激提高】棒子【指挥，调节配置】 政府是监管者 市场是主导者 市场经济 市场经济的核心是公平竞争 公正监管是公平竞争的保障 市场经济的构成要素:市场主体、市场体系、市场机制; 现代市场经济的构成要素:市场主体、市场体系、宏观调控体系。 市场经济构成三要素 市场主体（政府、企业等，其中企业是主体）（市场主体：个人，企业，农户，政府，境外个人企业政府 市场【主要】主体：个人，企业，农户 市场【最主要】主体:企业） 市场体系（市场体系三大支柱：商品市场（商品）、资本市场（钱）、劳动力市场（人）） 市场机制 现代市场经济构成三要素 市场主题 市场体系 宏观调控体系 现在市场机制 供求、竞争、价格 与计划经济对比 计划经济：国家管控 市场经济：市场决定(优胜劣汰) 计划经济 是国家（政府）发布指定的经济，国家都分配好了，生产啥，生产了卖给谁 肉票、粮票这些都是 市场经济是市场配置的 与商品经济关系 商品经济与市场经济，其中商品意在前，市场经济在后。 商品经济是市场经济存在和发展的前提和基础，市场经济是商品经济存在和发展的必然结果。 市场经济是发达的商品经济 市场经济两个基本方向 **供给和需求 **是市场经济内在的两个基本方向 公开市场是什么 公开市场业务：买进或卖出证券等，调节货币供应 GDP 国内生产总值 国土原则 中国人在中国+外国人在中国 这个是GDP 国民生产总值 国民原则 中国人在中国+中国人在外国 这个是GNP 必须按当期最终产品，中间的不能算（比如二手产品），要不就重复了 仅仅市场活动，黑市不算 绿色GDP 扣除资源消耗和环境降级 标志 经济增长的标志是GDP增加。 GDP支算类型 支出法核算GDP时，食品、服装的支出被统计在GDP的哪个项目？衣服是非耐用品。耐用品是指比如汽车加电这些非耐用品是食品，服装这些。 注意 二手商品不能计入，但二手商品交易费要计入 股票债券属于转移，不能计入（但服务费用算） 政府转移支付不能计入（比如救助） 最终产品 核算要算最终的，比如你做面包，需要鸡蛋，这个鸡蛋不能算了，这个在蛋糕里算了 当期生产 核算哪一年的核算到哪一年去，比如二手商品不能算 市场价值 要经过市场交换，比如你打扫卫生，自己干不算，请保姆才算 正常经济活动 黄赌毒不算 成本 机会成本 企业为了某个东西放弃了另一种的机会 比如说有一个1w、5w、10w的项目，你选择了10w的，这里放弃中最高的5w就是放弃成本 经济成本 投入的物资资源，比如项目需要的成本 沉默成本 已经付出的，并且无法回收的成本 “赔了2万元”属于不可收回的成本，属于沉没成本。“电影不好看选择中途离场”，购买电影票的钱属于不可收回的成本，属于沉没成本。 可变成本和固定成本 可以成本：在一定范围呢，随着业务量的变化而变化 例子：比如家具厂生产家具 生产一件和生产100件所需要的原材料肯定不同，所以原材料是可变成本 比如房租，生产1件和100件都是一样的，是固定成本（借款利息也是，设备折旧也是） 金融工具期限短、流动性强、对利率敏感 又短又快又敏感 名人亚当斯密（看不见的手）（富国论） 凯恩斯（就业、利息和货币通论）（看的见的手）（国家对市场的干预） 大卫李嘉图，他提出了比较优势原理。决定国际贸易的因素是两个国家产品的相对生产成本，而不是生产这些产品的绝对生产成本。每个国家都应集中生产并出口具有比较优势的产品，进口具有比较劣势的产品（即“两优相权取其重，两劣相衡取其轻”），双方均可节省劳动力，获得专业化分工提高劳动生产率的好处（比李） 亚当米斯提出了绝对优势原理，该理论认为国际贸易的原因是国与国之间的绝对成本的差异，如果一国在某一商品的生产上所耗费的成本绝对低于他国，该国就具备该产品的绝对优势，从而可以出口；反之则进口。 效应收入效应（由价格变动引起实际收入的变动，进而影响需求量） 挤出效应（政府为了平衡预算，采取发放政府债券） 口红效应（口红便宜，指在经济萧条而导致低价产品偏爱的趋势）代替效应（收入不变的情境下，代替物品的价格变了） 马太效应（强者愈强、弱者愈弱） 溢出效应（不仅达到了预期，对组织之外的人也产生了影响） 追赶校园（穷逼上升空间大） 牧童经济（这个和环境相关，说牧童放牧的时候只关心放牧，忽略草原破坏程度）（不好） 宇宙飞船经济（是循环利用的，这个是和牧童经济向背的）（好的） 丰收悖论（丰收了，农民的总收入反而下降，粮食是生活必需品，丰收了，量多了，但人的需求没变，便宜了） 熊彼特利润（创新） 消费影响 影响需求最重要的因素 价格 影响消费最重要的因素 国民收入 拉动经济投资、消费、出口 （笑出头） 社会财富两极分化 原因 资本积累（资本积累是剩余价值转化成资本，是两极化的重要原因，也是社会失业的根源） （ 资本 ）是价值的一种特殊形式，是不断地在运动中谋求自身增殖的价值 其他（易错概念）（不是原因了） 资本集中（这个是大资本吞并小资本，只是个别资本富起来了） 分配混合所有制企业（这个是按资本要素分配） 农民承包土地（按劳分配，这个属于集体经济）（国企也是）（收费所） 第三产业除了农业和工业都是 第一产业 第一：自然界（农林牧渔）；第二：再加工（工业，建筑，采矿）；第三：服务（物流客流旅游餐饮））等特点。 IS曲线针对产品市场均衡时收入（Y）和利率（r）组合点轨迹 负相关 LS左移或者右移动都是陡峭的 LM曲线针对货币市场均衡时收入（Y）和利率（r）组合点轨迹 正相关 LM左移变平缓、右移动变陡峭 LS和LM 的交点就是平衡点 公有制和非公有制 公有制在社会总资产中占优势（是总资产，不是资产） 非公有制是社会主义市场经济重要组成部分（注意是社会主义市场，不是社会主义经济，社会主义经济是公有制） 国有经济是主导，它才是我国国民经济的支柱（而不是公有制经济） 国民经济 国民经济中起主导作用的是国有经济，起基础作用的是农民土地经济。 全民所有制 全民所有制指的国有经济，全民所有制=国家所有制 社会救助为了保障最低生活需要 把保证最低生活所需要的商品和服务金额作为基数 注意 不是劳动者收入的最低标准（这个太高了） 公司记账民营都是借贷记账法 事业单位是收付实现制 CPI消费者物价指数（居民消费物价指数）（你购买商品在今天和过去的差别）（当期价格/基期价格）（这里的商品都是与生活息息相关的商品）（消费和服务的加权平均价格方法） 可以反映通货膨胀 CPI上涨说明物价上涨，购买力下降 CPI下跌说明物价下跌，购买力增强 社会保险是国家强制实行，用人单位和个人必须参加 （必须五险） 政府调控 财政投资：政府想扶持哪个行业，就投哪个 财政信用：有偿借款 限制价格和支持价格限制价格一般低于均衡价格（保护消费者） 支持价格一般高于均衡价格（扶持） 最低限制价格 最低限价是国家用行政手段规定的价格下限。主要适用于米面粮油等需求价格弹性小、和人们生活关联较大的物品。 总结 限制价格一般低于均衡价格，是政府为保护消费者利益而制定的最高限价。 支持价格是政府为了扶植和保护某一产品或者某一行业的生产，对该产品或行业的产品规定高于市场均衡价格的价格。 社会经济自然经济（自给自足，不存在物质交换） 商品经济（价值规律） 产品经济（按需分配，不存在交换） 剩余价值规律是资本主义固有的，社会主义没有 借贷资本太有钱了，花不完，根本花不完，不如借出去钱生钱 这里只是短暂的给了使用权（时间到了还钱和利息），所有权没有给 信用贷款受理、审查与审批风险点主要是（ 借款用途 ）。银行看你借钱用途是什么以考察还款能力并判断风险，如借钱炒股，一般银行不同意；借钱买房（房子跑不掉），银行很乐意借。 所有制 公有制 公有制为主体 包括： 国有经济（生产资料归国家所以，国家主人人民，归人民所有）（国企，比如中石化）—–主导地位 集体经济（生产资料归一部分人所有）（合作社） 混合所有制中国有成分和集体成分（例如一汽大众） 非公有制 个体经济 私营经济 外资经济 对他们的态度是：鼓励、支持、引导 注意 全面所有制是国家所有制 农业是社会注意国民经济的基础作用 产品定价产品加定价（成本加上利润） 渗透定价（初期价格低，来吸引消费者，后面长） 心里定价（价值与消费者心理感受有很大联系）（比如超市9.98，而不是10块） 差别定价（歧视性定价，同样的产品，对于人的不同，定价不同）（比如杀熟，新用户便宜） 股票交易一级市场（初级市场，大额） 二级市场（小额，进出比较简单） 投资高风险高回报 买进基金（中国风险） 股票（高风险高回报） 存银行（低风险） 买国债（低风险，比银行收益高一点点） 按劳分配 前提 生产资料公有制 根本原因 生产力发展水平 直接原因 劳动力性质和特点 定价 成本加成定价 安产品成本上增加部分盈利的方法 渗透定价 初期低（吸引消费者） 心里定价 价值和消费者的心里感受有很大联系（比如尾数定价，9.99一斤，而不是十块） 差别定价 歧视性定价，根据顾客不同定价不同 存款 大额存单 比如存折 比银行理财产品门槛高，适应于有钱人，起点是30w 收益高于银行定存 低于不保本银行理财成品（不保本是最高的） 大额存单可以转让 固定资产定义：总额在一段时间内不受业务量增减变动而影响 折旧 是对固定资产使用过程中的价值补偿 比如说你买机器花1100元，用了10年，机器卖废品卖了100，这样1000就是折旧。但折旧公式是价值差额/年限，所以这个是一年折旧100 折旧是固定资产使用寿命内进行分摊的 折旧原因 固定资产损耗 弥补利润损耗 折旧也是一种费用（比如你买了个二手的，虽然便宜，但折旧了） 生产要素包括实体和智能 实体 劳动者、劳动资料、劳动对象 智能 科学 注意 生产方式=生产关系+生产力 生产力=劳动者+劳动资料+劳动对象+科学 生产关系=分配形式+所有制形式+地位关系 政策银行中国进出口银行 中国农业发展银行 社会主义经济解放生产力（根本任务） 共同富裕（根本目标） 市场价格在完全竞争中，随着需求的增加 价格是先增后减（增加了，厂子也就多了，所以价格也就降低了） 居民收入 按劳分配 多劳多得 按生产要素分配 按资本要素分配（用钱赚更多的钱）（存款利息）（比如存在银行的利息） 按劳动力要素分配（按劳动）（私企工资） 按土地要素分配（租金） 总的来说，得有依靠的东西，比如你的劳动（你上班）、你的土地（自己买的房子）、你的资本（你存下来的钱），养老金这些可不是 剩余价值劳动者被压榨的部分 包括利润和平均利润（利用是基本） 货币升贬值紧缩银根（市场上的货币少了，物以稀为贵，自然升值） 国际收支逆差（这个导致货币贬值）（出口&lt; 进口，花的钱多，但花的都是外币，外币花出去导致外币少了，外币升值，本币贬值） 降低利息（这个导致货币贬值）（都不愿意存银行了，钱多了，贬值） 通货膨胀率下降（升值）(市场钱少了，物以稀为贵，升值) 经济分类 实体经济 能生产实实在在的产品或者服务 虚拟经济 比如股票、债券（钱生钱这种） 简称WTO为世界贸易组织的简称世界卫生组织（World Health Organization，简称WHO）世界银行（WorldBank，简称WB）经济合作与发展组织（Organization for Economic Co-operation and Development，简称OECD）国际货币基金组织（International Monetary Fund，简称IMF） 经济全球化 实质 资源配制国际化。发达国家主导的，以跨国公司为载体 主导力量 跨国公司 国企重大事项可简单理解为，国企的从0到1（重组）从1到0（破产）从1到2（分立），而核算不过是任何企业都要进行的家常便饭的事。 产业类型划分 根据生产要素在各产业中的相对密集度的不同，可以将产业划分为不同类型 土地密集型产业 在生产要素的投入中需要使用较多的土地等自然资源才能进行生产的产业 与土地资源关系最为密切是农矿业，包括种植业、林牧渔业、采掘业等 资本密集型产业 资本密集型产业是指在其生产过程中劳动、知识的有机构成水平较低，资本的有机构成水平较高，产品物化劳动所占比重较大的产业。例如，交通、钢铁、机械、石油、化学、电力等基础工业和重化工业都是典型的资本密集型产业 技术密集型产业 。在生产结构中，技术知识所占比重大，科研费用高，劳动者文化技术水平高，产品附加价值高，增长速度快。包括新兴的电子计算机工业、机器人工业、航天工业、生物技术工业、新材料工业、微电子工业、现代制药业等 刮刮乐“刮刮乐”的风靡主要是利用了（ 参与者具有风险偏好 ）的原理。 中央银行中央银行选择货币政策中介目标和操作目标的主要标准有三个，即可测性、可控性、相关性。范围可控，统计可测 证券证券市场:涨了，很牛b（牛市）跌了，真熊（熊市） 比特币比特币。它不依靠特定货币机构发行，而是依据特定算法，通过大量的计算产生 等价形式诺手=1.5猴，此时诺手是相对等价形式，猴是等价形式。诺手=1.5猴=锐文。此时猴哥是一般价值形式。猴哥就是等价形式，换算单位，诺手锐雯就是相对等价单位。这样的话大家都能更好理解了。x=y，x在=左边，表示主动换y，是相对价值形式，y在右边，作为等价形式被换x=y=z 此时 y作为中间物交换，是一般价值形式 名词解释规模经济”是指由于生产专业化水平的提高等原因，使企业的单位成本下降，从而形成企业的长期平均成本随着产量的增加而递减的经济 经济周期”是指经济运行过程中经济扩张和经济收缩、景气和不景气的交替，是不可避免的经济现象 产业结构是指国民经济中各产业之间及产业内部各部门之间的比例关系和结合状况。产业结构也叫产业体系，是社会经济体系的主要组成部分。 产业布局是指产业在一国或一地区范围内的空间分布和组合的经济现象。 产业比例是指第一、第二、第三产业的占比。 小知识市场主导，政府监督。 直接标价法：1美元=n人民币 间接标价法：1人民币=n美元 解放发展生产力是社会主义市场经济的根本任务，共同富裕是目标","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"政治学","slug":"政治学","date":"2023-06-30T07:58:16.000Z","updated":"2023-07-16T15:01:23.637Z","comments":true,"path":"posts/398ed5cf.html","link":"","permalink":"http://example.com/posts/398ed5cf.html","excerpt":"","text":"毛泽东思想直接理论来源马克思列宁主义 物质基础新的社会生产力的增长和工人运动 实践基础中国共产党领导的人民革命 形成和发展 1921年 一大 1927年八七会议召开，毛主义讲话了，枪杆子里出政权 1935年遵义会议，毛主义确立了领导低位 1945年毛泽东思想确立党章 1956年三大改造完成，标志进入社会主义社会 后面的二十年开始犯错了，不会考 达到成熟的标志是新民主主义理论科学体系形成 萌芽阶段 这里主要是调查报告 第二阶段 这个时候写文章还不规范，比如本本主义，其实外语里是教条，由于不懂，写为本本 这里还没建国，是斗争多 《星星之火，可以燎原》是毛泽东在1930年给林彪的一封信，提出了农村包围城市、武装夺取政权，标志着毛泽东思想基本形成 《反对本本主义》论述了“从斗争中创造新局面”，“没有调查就没有发言权”，反对教条，做任何事情都要从实际出发 第三阶段 大佬级别，学术牛逼，比如战略问题、各种论，用词专业 论联合政府（1945）—目的为了建国（在七大上做的报告，全心全意为人民服务，一刻也不脱离群众，一切从人民利益出发）（三大优良作风）（快打败小日本了，建立一个什么样的国家呢） 毛泽东思想的成熟(1935—1945):1935年遵义会议后到抗日战争时期 标志**:新民主主义论**革命理论形成 1939年10月，中共中央主办的党内刊物《共产党人》创刊，毛泽东撰写了《〈共产党人〉发刊词》。在《〈共产党人〉发刊词》中，毛泽东指出，统一战线、武装斗争、党的建设是中国共产党在中国革命中的三个基本问题，也是中国共产党在中国革命中战胜敌人的三个法宝。 论持久战–它是针对党内部分“中国速亡论”、“中国速胜论”，持久抗日。强调“民兵是胜利之本”“武器是重要因素，但不是绝对因素，决定因素是人而不是物” 《中国革命和中国共产党》首次提出新民主主义概念（与国民党的区分），这个时候的首要任务是推翻帝国主义（1939年） 论人民民主专政—国家已经建立起来了，但里面啥政府都有，要建立社会主义国家，剔除其他党派 毛泽东在《在晋绥干部会议讲话》中第一次全面、系统地提出了反对帝国主义、封建主义和官僚主义 1956年《论十大关系》，这个时候三大改造完成了，关于建设的文章，把国内外一切关系调动起来。这里提出了“长期共存、互相监督”，标志着人民民主统一战线发展到了一个新的阶段 1957年《关于正确处理人民内部矛盾问题》，改造完成后，有点不适应，学生罢课啥的，为了解决这，划分了敌我矛盾（残余国民党，武力解决），人民内部矛盾（学生罢课等，用非对抗的方式去解决） 1949年《论人民民主专政》主要介绍了新中国的性质。 新民主主义革命1919-1949 1919新民主主义运动（五四） 明珠主义革命是反帝反封建的 马克思主义在中国实现了两次飞跃，第一次是毛泽东思想，第二次是中国特色（这里面包括邓小平理论） 三座大山是：帝国主义；封建主义；官僚主义 三个活灵魂 邓小平添加了解放思想 江泽民添加了与时俱进 胡锦涛添加了求真务实 群众路线：一切为了群众，一切依靠群众 实事求是是精髓，独立自主是基本立足点 三大经济纲领 三大法宝 统一战线 三大作风 三大改造 军队建设 南昌起义标志着军队的诞生 三湾改编是党最早领导军队 古田会议是军队新型建设思想形成 延安整风反对主观主义（中心，也就是学风） 反对宗派主义 反对党八股 （猪排骨） 党的处分警告 严重警告 撤销党内职务 留党察看 开除党籍 新民主主义核心问题是党（无产阶级领导） 基本问题是农民 根本问题是政权 首要问题是分清敌我 红军长征最壮烈的战役湘江战役 社会主义核心价值观个人：爱国、敬业、诚信、友善 国家：富强、民主、文明、和谐 社会：自由、平等、公正、法治 中国特色社会主义 邓小平理论78-97 97年邓小平去世 邓小平理论大部分诞生于十三大 活的灵魂解放思想，实事求是 社会主义本质和根本任务1992年南方谈话，南方谈话为了搞市场经济 社会主义本质：共同富裕，消除两极分化 根本任务：解放生产力 邓小平说马克思经济学犯错了，一个是经济制度，一个是经济体制，制度是有阶级性的。但体制没，它包括市场和计划，这就好比两只猫，黑猫和白猫，能抓老鼠就是好猫，老鼠是生产力 社会主义初期阶段理论87年党十三大提出 78-87近十年，中国还是很穷，没有达到社会主义，怀疑邓小平领导能力不行，所以邓小平说目前我们处于社会主义初期阶段，并长期处于这个阶段 邓小平说要处于社会主义初期阶段100年，人家不信，那说可以分以下三步走 三步走 江泽民又把第三阶段进行划分 习近平又把江泽民的第三阶段划分为两个阶段 党的基本路线和基本纲领也是十三大提出 这里主要是给党下任务书 要领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放 一国两制79年提出 经济特区广东省的深圳、珠海、汕头 福建的厦门 海南 新建的喀什经济特区、霍尔果斯经济特区 注意没有上海 重要事件先后顺序 取消农业税 2006年1月1日，我国全面取消农业税 北京奥运会 2001年申报成功 2008年北京举行 上海浦东新区 1992年 经济特区 1980年 南方谈话判断改革开发姓“社”还是姓“资”，主要看 是否有利于发展社会主义生产力（这个是最基本的） 是否有利于增强社会主义国家的综合国力 是否有利于提高人民生活水平 中特道路是途径 理论是指南 制度是保障 文化是精神力量 积累中国特色社会主义的道路是根本途径，理论是指南，制度是保障，文化是精神力量 全心全意为人民服务是人民军队的唯一宗旨，实行官兵一致、军民一致、瓦解敌军 刘少奇安源党校是第一个党校，延安中学是第一个中学 小康十二大提出，十六大建设，十八大建成","categories":[],"tags":[]},{"title":"","slug":"leetcode","date":"2023-04-25T11:43:01.441Z","updated":"2023-04-25T11:43:01.933Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://example.com/posts/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"spring","date":"2023-04-25T10:26:53.647Z","updated":"2023-04-25T10:26:53.920Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://example.com/posts/0.html","excerpt":"","text":"SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解： 1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。 2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。 springboot内置tomcat","categories":[],"tags":[]},{"title":"jvm","slug":"JVM","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:26:39.764Z","comments":true,"path":"posts/7f1ae6dp.html","link":"","permalink":"http://example.com/posts/7f1ae6dp.html","excerpt":"","text":"Class字节码文件 是一个[二进制](https://so.csdn.net/so/search?q=二进制&amp;spm=1001.2101.3001.7020)文件，包含了JAVA程序执行的字节码，包含的信息有版本、访问标志、常量池、当前类、超级类、接口、字段、方法、属性等，中间没有任何分隔符，文件开头有一个特殊标志，用16进制表示为0xcafebabe。 类的实例化顺序比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序 先静态、先父后子。 先静态：父静态 &gt; 子静态 优先级：父类静态代码块–&gt;子类静态代码块–&gt;父类代码块–&gt;父类构造方法–&gt;子类代码块—&gt;子类构造方法 一个类的实例化过程： 1、 父类中的static代码块，当前类的static（这是类初始化，这个main所在的也会初始化） 2、 顺序执行父类的普通代码块(还有非静态变量)（下面是实例初始化） 3、 父类的构造函数 4、 子类普通代码块(还有非静态变量) 5、 子类（当前类）的构造函数，按顺序执行。 6、 子类方法的执行，、 例子 解释 jvm 常用配置参数 分配堆内存s -Xms 最小堆 -Xmx 最大堆 栈 -Xss 栈大小 如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 类需要同时满足下面3个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。加载该类的 ClassLoader 已经被回收。该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 逃逸分析是对象只在当前函数范围内使用，因而改为在栈上申请空间，因为栈是用完就释放掉，不用等gc，缓解了gc的压力。测试可以用一个while循环创建对象来查看 JVM的GC ROOTS有哪几个地方呢？a. java虚拟机栈中的引用的对象。b.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）c.方法区中的常量引用的对象。d.本地方法栈中的JNI（native方法）引用的对象 GC日志的real、user、sys是什么意思？real:指的是从开始到结束所花费的时间。比如进程在等待I/O完成，这个阻塞时间也会被计算在内。user：指的是进程在用户态（User Mode）所花费的时间，只统计本进程所使用的时间，注意是指多核。sys：指的是进程在核心态（Kernel Mode）花费的CPU时间量，指的是内核中的系统调用所花费的时间，只统计本进程所使用的时间。 real time &gt; sys + user time 的情况 一般的GC事件中，real time是小于sys+user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys+user time的。比如说：user+sys是2秒，如果是有5个GC线程并发的做垃圾回收，那么real time差不多是2000/5=400ms左右。 但是，有时候会见到real time大于sys+user time的情况 原因 IO负载繁重 当服务器的IO负载非常重的时候（网络、磁盘访问、用户交互），real time就会变大。应用做GC日志打印的时候，也需要访问磁盘。当磁盘的负载非常重的时候，GC事件就有可能被阻塞，这会导致real time变长。 注意：就算不是你的应用导致的磁盘负载重，如果服务器上其他的应用导致的磁盘负载重也会导致real time变长。 可以用如下命令来监控服务器的磁盘负载情况： CPU不够用 如果服务器上跑了很多进程，你的应用很不幸没有得到足够的CPU时间，它就需要很多的等待。当你的进程在等待的时候，real time显然就比sys+user时间长了。 safepoint是什么？g1什么时候引发full gcyoung GC触发时机：young区不够用 full GC触发时机: 没有足够的Region 垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器 串行 单线程堆内存较小，适合个人电脑 吞吐量优先 多线程堆内存较大，多核cpu让单位时间内，STW 的时间最短 0.2 0.2 = 0.4 响应时间优先 多线程堆内存较大，多核cpu尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5 解释 接下来我们来学习垃圾回收器，垃圾回收器我们可以把它分为这三类，第一类叫串行的垃圾回收器，第二类叫吞吐量优先的垃圾回收器，第三类叫响应时间优先的垃圾回收器。下面就解释一下，第一个串行的垃圾回收器，这个从名字上也能猜出来，它的底层是一个单线程的垃圾回收器，也就是说，它在垃圾回收发生时，其他的线程都暂停，这时候一个单线程的垃圾回收器就登场了，它一个线程来完成垃圾回收，显然它的适用场景是堆内存较小的时候，而且cpu的核数多了也没用，因为只有一个线程，适合个人电脑这就好比我们有一个居民楼，有一个保洁工人来打扫卫生，一个保洁工人就类似于这种单线程的垃圾回收器，如果楼层比较矮，小三层，那保洁工人可能一天就能把卫生打扫完了，但是如果楼层特别的高，是一个三十几层的高层建筑，那一个保洁工人来打扫，这个工作量可能是非常大的，干好几天都干不完。这是串行垃圾回收器它的适用场景。它适合堆内存小，个人电脑也就是cpu个数少的这么一个工作环境。而下两种吞吐量优先和响应时间优先的这两种垃圾回收器，它们都是多线程的，多线程的好处，还拿刚才那个例子作比喻，这个楼层很高，但是我可以多找几个保洁工人啊，它们每个人打扫一层或者几层，人多力量大，肯定还是可以在规定时间内完成垃圾回收的任务。所以后两种垃圾回收器都适合堆内存较大的场景，并且一般它需要多核的cpu来支持，为什么非要说多核cpu呢，虽然有多个线程，但是假设只有一个cpu，那么工作的时候也是多个线程轮流去争抢这单核cpu的时间片，其实这个效率还不如单线程呢，举个例子，就好比虽然有多个保洁工人来打扫卫生，但是扫帚只有一把，那要打扫卫生必须轮流使用这把扫帚，这个效率显然跟一个人来打扫是一样的，所以后两种垃圾回收器它们的工作适用场景是堆内存很大，但是有一个要求，就是必须是多核cpu才能充分发挥它俩的威力，显然多核cpu都是服务器电脑，所以它们都适合工作在服务器上。后两种吞吐量优先跟响应时间优先它们都是多线程的，那它俩之间又有什么区别呢。我们先说响应时间优先，响应时间优先它就是注重的是让垃圾回收时它的 Stop The World 的时间尽可能的短，我们都知道垃圾回收时它要把其他的线程暂停下来，等打扫完垃圾了，其他线程才能恢复运行，这段时间我们把它叫做 STW，就是世界暂停，这个世界暂停时间显然是越短越好了，那响应时间优先的垃圾回收器它要考虑的就是尽可能的让这个暂停时间变短，尽可能让 STW 的时间最短，这是它的一个目标。那么吞吐量优先呢，它的目标就不太一样，吞吐量优先是指我要在单位时间内让我的垃圾回收所占用的 STW 的时间最短，让单位时间内 STW 的时间最短。吞吐量优先和响应时间优先都是 STW 最短，那么它俩有什么区别呢，这个线程优先它是让单次的 STW 时间最短，举个例子，比如说，单位时间内触发了很多次垃圾回收，每一次垃圾回收都只花了 0.1s，假设1小时内发生了5次垃圾回收，每次都是0.1，那么它们加起来最后等于0.5s，也就是一小时内花费了0.5s，但是每次都很短，这是响应时间优先它的目标。但是吞吐量优先则不同，它可能单次的垃圾回收时间花费的较长，比如说1次花了0.2s，但是在一个小时内它只发生了两次垃圾回收，所以它的总时间来讲只有0.4s，从这一点上来讲，它似乎在总时间上又要优于响应时间优先，所谓的吞吐量就是指垃圾回收的时间占程序运行时间的占比，垃圾回收时间占比越低，那么就指吞吐量越高，这是吞吐量它的一个含义。 都要哪些 对于吞吐量优先的场景，就只有一种选择，就是使用 PS 组合（Parallel Scavenge+Parallel Old ）。 对于响应时间优先的场景，在 JDK1.8 的话优先 G1，其次是 CMS 垃圾回收器，另外还有PN、ZGC、Shenandoah。 jdk1.8新特性1.Lambda表达式 2.函数式接口 3.方法引用 等 类的主动使用和被动使用主动 主动使用，又分为七种情况： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（ 比如：Class.forName(“cn.sxt.Test”) ) 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法） 被动 子类引用父类的静态字段，不会导致子类初始化 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 局部变量、成员变量、类变量栈，堆，方法区 i++和++i栈帧都有哪些数据？JVM的运行是基于栈的，和C语言的栈类似，它的大多数数据都是在堆里面的，只有少部分运行时的数据存在于栈上。 在JVM中，每个线程栈里面的元素，就叫栈帧。 栈帧包含：局部变量表、操作数栈、动态连接、返回地址等。 栈结构 栈帧的内部结构 局部变量表 组成 最基本的存储单元是Slot（变量槽） 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量 在局部变量表里，32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long和double）占用两个slot 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maxmum variables数据项中。在方法运行期间是不会改变局部变量表大小的。 操作数栈每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出（Last-in-first-out）的操作数栈，也可以称之为表达式栈（Expression Stack）操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。比如：执行复制、交换、求和等操作 图解：将8和15出栈，执行求和操作后再将结果进栈操作。 动态链接每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）.比如：invokedynamic指令在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 1.举例栈溢出的情况 答：StackOverflowError，通过-Xss设置大小，1.局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。2.递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。3.指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。 2.调整栈大小，就能保证不出现栈溢出吗？ 答：不能，如果说一个执行6000次递归就结束的程序，在可执行递归5000次的内存空间中会出现StackOverflowError，而在调整为可递归7000次的内存空间时就不会出现StackOverflowError。 如果程序是类似死递归情况无论怎样调整栈大小，都会出现溢出现象，对于这种情况，调整栈的大小理论上只能说是出现异常的时间晚一些而已’ 3.分配栈内存越大越好吗 不是，理论上好像会在一定时间或单位时间内减少StackOverflowError的概率，避免出现StackOverflowError过早，但是避免不了出现StackOverflowError。对栈空间来说是好事，但是这样会导致可执行的线程数减少，对其他内存结构也是有影响的 4.垃圾回收是否会设计到虚拟机栈 不涉及，虚拟机栈会出现StackOverflowError，但是不会出现GC，因为只有进栈出栈，出栈的过程就相当于GC（程序计数器不会Error和GC，堆会GC和ERROR，方法区也会出现GC和ERROR） 标记清除算法标记-清除”算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 它的主要缺点有两个： （1）效率问题：标记和清除过程的效率都不高； （2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，碎片过多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至Stop The World。 复制算法（Copying） 为解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 它的主要缺点有两个： （1）效率问题：在对象存活率较高时，复制操作次数多，效率降低； （2）空间问题：內存缩小了一半；需要額外空间做分配担保(老年代) From Survivor, To Survivor使用的就是复制算法。老年代不使用这种算法， 标记-整理(Mark-Compact) 复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法（Generational Collection） GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 “分代收集”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 你知道哪些垃圾收集器？ serial 串行回收 新生代 采用复制算法 Serial是一个单线程的收集器，Serial的特点是它在进行垃圾收集时，必须“Stop the World”，意思就是当这个垃圾收集器开始工作时，必须停止其他所有的工作线程。听起来似乎很不靠谱，但是对于限定单个CPU的场景下，这种方式简单而高效。对于简单的桌面应用，分配给虚拟机的内存不会很大，对于一两百兆的新生代，Serial的垃圾收集时间可以控制在一百毫秒以内，对于用户来说基本上是无影响的。 serial old 采用标记-压缩算法 老年代 ParNew 并行回收 ParNew垃圾收集器是Serial的多线程版本，使用多条线程进行垃圾收集。除此之外，和Serial基本相同，ParNew在多线程收集垃圾时依旧需要“Stop the World”。ParNew可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数量。 ParNew收集器在新生代使用复制算法 Parallel Old Parallel Scavenge收集器的老年版本，多线程收集器，采用标记-整理算法，也是吞吐量优先。 Parallel Scavenge Parallel Scavenge也是新生代收集器，也同样是多线程的收集器，但是和ParNew不同，Parallel Scavenge收集器关注的是一个可控制的吞吐量（Throughput）。所谓吞吐量指的是CPU用于运行代码的时间和CPU总消耗的时间比例。 吞吐量=运行代码的时间 /（运行代码的时间+垃圾收集时间） 理论上吞吐量越高，用户就越不能感受到停顿时间。 Parallel Scavenge提供了两个参数用来控制吞吐量： -XX:MaxGCPauseMillis和**-XX:GCTimeRatio** -XX:MaxGCPauseMillis设置内存回收花费时间最高毫秒值，但是不要一味地认为只要把值设置很小，垃圾回收就更快了。这个停顿时间是以牺牲吞吐量和新生代空间换来的。 -XX:GCTimeRatio表示垃圾收集时间占总时间的比例，（1~100），也就是吞吐量的倒数。默认这个值是99，就是允许最大百分之1的垃圾手机时间（1/(1+99)）。 还有一个参数**-XX:+UseAdaptiveSizePolicy**，打开这个参数后，就不需要自己设置新生代大小、晋升老年代对象年龄等参数，因此Parallel Scavenge收集器也被叫做吞吐量优先垃圾收集器。 Parallel Scavenge采用复制算法。 cms 主要特点：低延迟 尽可能缩短垃圾收集时候用户线程的停顿时间 采用的标记-清除算法 老年代垃圾回收器 1、初始标记：标记GC Roots可以直接关联到的对象，速度很快（stop the world） 2、并发标记：根搜索算法的过程 3、重新标记：为了修正并发标记期间，因程序运行导致标记产生变动的对象。（stop the world） 4、并发清除：清除垃圾 它的优点就是并发收集、并发清除、低停顿。 但是它有三个显著的缺点： 1、对CPU资源十分敏感，因为并发标记和并发清除都是和程序同时运行，因此会占用CPU导致应用程序变慢。 2、无法处理浮动垃圾，浮动垃圾就是在并发清除过程中新生成的垃圾，这部分垃圾CMS无法在本次被清理，可能出现Concurrent Mode Failed报错，因此需要预留一定的内存空间，无法等到老年代快被占满时再清除。默认情况下，CMS在老年代使用了68%后就会被激活。可以设置-XX:CMSInitiatingOccupancyFraction设置这个值。 3、产生空间碎片，由于采用的是标记-清除算法，那就无法避免会产生空间碎片的问题，这会给分配大对象带来困难。 G1 区域化分代式 同时兼顾新生和老年代 划分为一个个region，region内部采用复制算法，整体是标记压缩算法。没有碎片化。 只选取部分region进行内存回收，这样缩短了回收范围，减少了停顿。 后天有一个优先列表，优先回收大的（这个也根据自己给的限制时间内选择较大的）","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"ShardingSphere","slug":"ShardingSphere","date":"2020-03-14T16:00:00.000Z","updated":"2023-05-28T09:18:39.979Z","comments":true,"path":"posts/7f1ae6sd.html","link":"","permalink":"http://example.com/posts/7f1ae6sd.html","excerpt":"","text":"定义 添加事务后均是主库，在没添加事务的时候插入是主，查询是从 主从复制 springboot只需要在配置文件里配置一下，这里配置数据源 只需要配置一下，哪个数据源是读得，那个是写的 配置负载均衡 记录docker 这是映射到主机 修改my。cof 主键生成策略雪花 水平分库分表策略 如上图所示，定义好数据库的放置，这里是通过userid，偶数放在1号库，奇数放在2号库。定义完成后再定义每个库中表的策略，这里是根据cid进行划分，偶数放在1号表，奇数放在2号表。 公共表 何为公共表 不长变的，经常需要做关联工作，比如地表沉降系统中的传感器节点信息表。（要在每个库中创建同样一张表） 这里也是通过shardingsphere做的，在papertie里设置公共表，如下 这样的话，插入和删除都是对每个数据的公共表同时操作。 读写分离 修改这个文件 改端口号 修改文件路径（存数据的） 分布式事务 TCC 分布式事务可以通过TCC来解决，分别是上面三个单词的缩写。使用TCC需要给表加上冗余列，例如上述订单表和库存表，需要在订单表中添加预增金额和状态，库存服务里需要添加冻结库存。 在执行TCC时候，Try是对资源进行锁定，在这一步预增金额这里设置一下（比如买10瓶水，一瓶水3块钱，这里的预增金额就设置为30，把状态改为初始），库存表也是这样（因为要取，所以库存要减少，这里是冻结库存设置为10，因为要取10瓶水）。 Confirm进行提交，这里如果提交成果，就把上面的预增金额和冻结库存给真正处理。状态设置为完成。 cancel取消，取消的话放弃预设金额和冻结库存，状态码设置为取消。 分布式ID可以使用UUID和雪花算法，但一般使用的是雪花算法。 原因 UUID 生成的是一个无序的字符串（影响查询效率） 雪花算法（SnowFlake）雪花算法的原理就是生成一个的 64 位比特位的 long 类型的唯一 id。 最高 1 位固定值 0，因为生成的 id 是正整数，如果是 1 就是负数了。 接下来 41 位存储毫秒级时间戳，2^41/(1000606024365)=69，大概可以使用 69 年。 再接下 10 位存储机器码，包括 5 位 datacenterId 和 5 位 workerId。最多可以部署 2^10=1024 台机器。 最后 12 位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成 2^12=4096 个不重复 id。 可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。 对于每一个雪花算法服务，需要先指定 10 位的机器码，这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的 10 位比特位的整数值都行。 具体网址 https://blog.csdn.net/jiaomubai/article/details/124385324?spm=1001.2014.3001.5506 分页查询分库分表后分页查询比较麻烦，比如差10条，一般从第一张表里查10条，再从第二章表里查10条，然后再排序获取。 跨库join 方案一 shardingsphere支持夸库join查询 方案二 先查一个字段，从这里获得关联的第二个字段，再通过第二个字段查 方案三 增加冗余列，把链接这个直接作为冗余字段存储 主从复制的问题使用shardingsphere进行主从复制，默认是查走从，插找主，但是主和从节点的数据同步是需要一些时间的，如果我们查最新插入的数据可能会导致查不到（因为数据还没有同步过去） 以地表沉降系统为例，查询最新的数据可能会导致查不到，原因如上。 方案一 可以设置查询最新的消息都走主库 方案二 在插入数据的时候同时插入缓存一个标志，比如设置60秒过期（根据业务定，差不多可以主从同步的时间），再查的时候先判断这个缓存还有没，如果有则查主，如果没有（说明已经主从辅助完成了）查从。 项目在形变模块，为了提升查询速度，对数据库进行了分库分表工作，对表进行了水平拆分，拆分了三个表。用到了数据库中间件shardingshere，采用了mod进行分片（利用传感器id），分布式id采用雪花策略，这样可以把同一个传感器的数据分到同一个表里，查询的时候就不需要查多张表了，提升速度。另外，项目里面有根据时间进行查询的，根据上面的分片策略可以实现，但需要到多张表中查寻，这样性能会低。我的解决方法采用看冗余数据，在通过时间进行范围分片。另外，做了主从复制，共搭建了两个从节点（在mini中配置），这里出现了一个问题，最新的数据有一部分查不到，原因是（通过shardingshere配置了查走从，其他走主。可能从还没有同步过来数据），解决方案是在插入数据的时候在redis中查如一个缓存，类似标志位，设置60秒（主从时间够就行），查的时候判断这个缓存还在吗，如果不在了就说明同步完成，查从。否则查主。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"java基础","slug":"java基础","date":"2020-03-14T16:00:00.000Z","updated":"2023-06-05T03:09:20.600Z","comments":true,"path":"posts/7f1ae090.html","link":"","permalink":"http://example.com/posts/7f1ae090.html","excerpt":"","text":"Java 中 sleep 方法和 wait 方法的区别？​ 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。 sleep()是Thread类中的方法，而wait()则是Object类中的方法。 程序计数器(线程私有)一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 迭代器 Iterator 是什么？首先说一下迭代器模式，它是 Java 中常用的设计模式之一。用于顺序访问集合对象的元素，无需知道集合对象的底层实现。 Iterator 是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。 缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 // 引入 ArrayList 和 Iterator 类 import java.util.ArrayList; import java.util.Iterator; public class RunoobTest { public static void main(String[] args) { // 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(\"Google\"); sites.add(\"Runoob\"); sites.add(\"Taobao\"); sites.add(\"Zhihu\"); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的第一个元素 System.out.println(it.next()); } } 线程的 sleep()方法和 yield()方法有什么区别？1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态； 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常； 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。 volatile关键字的作用和原理 volatile关键字的作用 1、保证可见性；2、防止指令重排；3、但是不保证原子性； 可见性是什么？ 在JMM（java memory model）java内存模型中，其他线程从主内存空间把值拷贝到自己的工作空间，线程修改之后的值会返回给主内存，主内存会通知其他线程，此为可见性。 指令重排 CPU为了执行效率会并发执行操作指令，volatile可以使指令一个一个的执行。 为什么不保证原子性 //自定义的类 public static class MyTest { //类的内部成员变量num public volatile int num = 0; public void numPlusPlus() { num++; } } 比如说，在多个线程同时执行num++时候，他们都是把num值copy到自己的工作内存中，++后再写回主内存。问题出现了这里，比如说A线程刚要写回内存时候，被抢占挂起了，然后B线程写进去了，然后通知所有线程修改了。但是这个时间太短了，所以A也写进来了，把刚刚的覆盖了。 如何解决原子性问题 1、通过synchronized关键字。(不建议，因为volatile自身就是轻量级的，可以说是乞丐版本的synchronized，加这个太重了)2、通过使用AtomicXX，不加锁,采用CAS（compareAndSet）解决。其本质是使用UnSafe本地方法（CPU原语）。3、使用LongAdder:最快（在线程多的情况下，使用分段锁）1、通过synchronized关键字。 Java 中能创建 volatile 数组吗？可以创建volatile数组，但是volatile只保证对数组的引用可见，即如果是改变引用只向的数组，将受到volatile的保护，但是对多个线程想要去改变数组里面的元素，volatile不能保证。 java equals于== 什么时候不同 对于字符串变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。 “==”比较两个变量本身的值，即两个对象在内存中的首地址。 “equals()”比较字符串中所包含的内容是否相同。 注意 String s1,s2,s3 = \"abc\", s4 =\"abc\" ; s1 = new String(\"abc\"); s2 = new String(\"abc\"); s1==s2 是 false //两个变量的内存地址不一样，也就是说它们指向的对象不 一样，故不相等。 s1.equals(s2) 是 true //两个变量的所包含的内容是abc，故相等。 （上述的是因为string重写了equals方法，比较的是值） 重点1 如果： StringBuffer s1 = new StringBuffer(“a”); StringBuffer s2 = new StringBuffer(“a”); 结果： s1.equals(s2) //是false 解释：StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类， 而Object类中的equals方法是用来比较“地址”的，所以等于false 重点2 对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符 串常量所生成的变量，其中所存放的内存地址是相等的， 所以s3==s4是true(即使没有s3=s4这样一个赋值语句) 重点3 对于非字符串变量来说，”==”和”equals”方法的作用是相同的都是用来比较其 对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。 如何判断对象是否是垃圾？引用计数：在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。 可达性分析：主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。 线程四种创建方式？ 创建线程的四种方式 继承Thread类（Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法）,实现Runnable接口,实现Callable接口,线程池。 线程池的好处 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 形成死锁的四个必要条件是什么1、互斥条件：一个资源每次只能被一个进程使用； 2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺； 4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系； 什么是IoC和DI？IoC(控制反转) 、DI(依赖注入) ioc IOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 di DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 两者关系 在平时的Java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象或者依赖对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，**创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起**，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象B之后，两个人一起协作完成要完成的工作即可。 所以控制反转IOC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IOC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IOC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IOC容器了，通过IOC容器来建立它们之间的关系。 DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结道：控制的什么被反转了？就是获得依赖对象的方式反转了。 Java的内存模型是什么？（JMM是什么？）JMM 是Java内存模型（ Java Memory Model），简称JMM。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范。通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。 计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。 三大特性 1.原子性一个或多个操作，要么全部执行（执行的过程是不会被任何因素打断的），要么全部不执行。 2.可见性只要有一个线程对共享变量的值做了修改，其他线程都将马上收到通知，立即获得最新值。 3.有序性 有序性可以总结为：在本线程内观察，所有的操作都是有序的；而在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as-if-serial 语义：线程内似表现为串行，后半句是指：“指令重排序现象”和“工作内存与主内存同步延迟现象”。处理器为了提高程序的运行效率，提高并行效率，可能会对代码进行优化。编译器认为，重排序后的代码执行效率更优。这样一来，代码的执行顺序就未必是编写代码时候的顺序了，在多线程的情况下就可能会出错。 java类型转换规则自动转换规则 布尔型不参与转换 转换规则（总）： byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double 转换规则（详）3.1 操作数之一为double，则另一个操作数先被转化为double，再参与算术运算；3.2 操作数均不为double，当操作数之一为float，则另一操作数先被转换为float，再参与运算；3.3 操作数均不为double或float，当操作数之一为long，则另一操作数先被转换为long，再参与算术运算；3.4 操作数均不为double、float或long，则操作数先被转换为int，再参与运算。 特殊：4.1 如采用+=、*=等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。4.2 当运算符为自动递增运算符（++）或自动递减运算符（–）时，如果操作数为byte，short或char类型不发生改变； Java的char能否存汉字当然可以 Java的char类型占两个字节，存的是Uicode码，其中就包含了汉字。怎么将 byte 转换为 String？ 怎么将 byte 转换为 String？一、String转化为byte[] //Convert to byte[] byte[] bytes = string.getBytes(); System.out.println(\"bytes输出是：\"+bytes); 二、byte[]转化为string String s = new String(bytes); //Check converted string against original String System.out.println(\"Decoded String : \" + s); 什么是隐式转换，什么是显式转换显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。 Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型Char类型可以隐式转成int,double类型，但是不能隐式转换成string（不能自动转换，一个是值类型，一个是引用类型 ）；如果char类型转成byte，short类型的时候，需要强转。 notify() 和 notifyAll() 有什么区别？notify()只能唤醒一个wait()线程,然而notifyAll()可以唤醒多个wait()线程; Java 中的 LinkedList 是单向链表还是双向链表？双向列表 接口特征接口的特征有：1、接口使用interface关键字修饰；2、接口不可以实例化；3、实现类一定要实现接口的所有方法（抽象类除外）；4、实现类可以实现多个接口；5、接口中的常量都是静态常量 接口中只能有static、final变量,不能有其他变量。 什么是过滤器？怎么创建一个过滤器个人理解，拦截并处理（可能是增强等等） 如何创建过滤器 主要是实现过滤器接口，重写dofilter Java中各种数据默认值1、 Byte,short,int,long默认是都是0 2、 Boolean默认值是false 3、 Char类型的默认值是’’ 4、 Float与double类型的默认是0.0 5、 对象类型的默认值是null synchronized 和 Lock 有什么区别？1、 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； 2、 synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 3、 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 4、 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 5、 synchronized只支持非公平锁,lock支持非公平锁和公平锁; synchronized原理 什么是VectorVector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多 ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。 抽象类必须要有抽象方法吗？不必须 1.如果一个类使用了abstract关键字修饰，那么这个类就是一个抽象类。 2.抽象类可以没有抽象方法 3.一个类如果包含抽象方法，那么这个类必须是抽象类，否则编译就会报错。 4.最关键的一点就是如果一个类是抽象类，那么这个类是不能被实例化的。 抽象类有构造方法吗 可以有构造方法。构造方法的作用有两个，一个是初始化变量，另外一个是实例化对象，抽象类不能实例化，还可以做另外一个作用。 能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化， int 类型的高 24 位将会被丢弃，因为 byte 类型的范围是从 -128 到 127 接口和抽象类的区别是什么？1、抽象类可以有构造方法，接口中不能有构造方法。2、接口的方法默认是 public，所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。3、接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。4、一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。5、接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（不能使用 private 关键字修饰！）。6、从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 如何合理配置线程池大小1、CPU密集型特点：更多的CPU在做计算，一直在工作，等待时间很少推荐：线程数少一点一般：CPU内核数+1 2、IO密集型特点：更多的时候线程在等待响应推荐：线程数多一些一般：CPU内核数 * 2 或者（线程等待时间与线程CPU时间之比 + 1） * CPU数目 3、混合型特点：啥任务都有推荐：将CPU密集和IO密集的操作分成2个线程池去执行一般：2个线程池 直接缓冲区和非直接缓冲区的区别1.直接缓冲区是建立在系统的物理内存的，而非直接缓冲区是建立在jvm内存，jvm内存是有上限的，所以速度会很慢 2使用直接缓冲区会对你的物理内存有一定的影响。而非直接缓冲区不会，但是会慢。 如何决定使用 HashMap 还是TreeMap？HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。两个都是非线程安全 ArrayList的优缺点 ArrayList的优点如下： ArrayList底层以数组实现，是一种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候非常快； ArrayList在顺序添加一个元素的时候非常方便； ArrayList 比较适合顺序添加、随机访问的场景； ArrayList的缺点如下： 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能； 插入元素的时候，也需要做一次元素复制操作，缺点同上； 构造方法能不能重写？能不能重载？不能重写但是可以重载，因为构造方法不能被继承。如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有super();语句,即调用父类不带参数的构造方法。如果类里定义一个或多个构造方法，那么java不提供默认的构造方法(不带参数的构造方法)。 被引用的对象就一定能存活吗？不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收 常见异常 java.lang.NullPointerException(空指针异常) java.lang.IllegalArgumentException( 方法的参数错误) 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 Object obj = new Integer(0); String str = obj; java.lang.NoSuchMethodException方法不存在异常 当程序试图通过来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.OutOfMemoryException内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 如何停止一个正在运行的线程？ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法 使用interrupt方法中断线程 线程池都有哪些状态？线程池的5种状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。 RUNNING：运行状态，线程池创建好之后就会进入此状态，如果不手动调用关闭方法，那么线程池在整个程序运行期间都是此状态。 SHUTDOWN：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。 STOP：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。 TIDYING：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。 TERMINATED：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。 线程的五种状态 1.新建状态（New）： 创建一个新的线程对象。 2.就绪状态（Runnable）: 线程创建对象后，其他线程调用start()方法，该线程处于就绪状态，资源已经准备就绪，等待CPU资源。 3.运行状态（Running）： 处于就绪状态的线程获取到CPU资源后进入运行状态。 4.阻塞状态（Blocked）： 阻塞状态是线程由于某些原因放弃CPU使用，暂时停止运行。 （1）等待阻塞：线程调用start（）方法，JVM会把这个线程放入等待池中，该线程需要其他线程调用notify()或notifyAll()方法才能被唤醒。 （2）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入锁池中。 （3）其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 5.终止状态（Terminated）： 线程run（）方法运行完毕，该线程结束。 怎么检测一个线程是否拥有锁？在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。 Java 中用到的线程调度算法是什么？有两种调度模型：分时调度模型和抢占式（java默认使用）调度模型。 分时调度模型： 平均分配每个线程占用的 CPU 的时间片。 抢占式调度模型： 让优先级高的线程占用CPU，如果线程优先级相同，那么就随机选择一个线程。 session和cookie的区别对象都是优先分配在年轻代上的吗？不是 平时代码创建出来的对象，一般分为两种： ​ 一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收，会分配到年轻代里。 ​ 另一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停地去使用，会分配到老年代里。 JAVA如何判断两个类是否相等？ 两个类是否相等，取决于他们是否由统一个类加载器来加载。如果他们来自不同的类加载器，哪么就算这两个类来自同一Class文件，他们也是不相等的。 同一个加载器，那么要判断两个类是否相等我们则可以简单的通过他们的Class对象是否是同一个对象即可。 Integer和int的区别1、类型不同:Integer是对象类型,int是基本数据类型。Integer是int的包装类。 2、Integer变量需要实例化之后才能使用，int则不需要。 3、Integer的默认值是null,int的默认值是0 4、Integer是对象的引用，当new一个Integer对象时，实际上是生成一个指针指向这个对象；而int则是直接存储数据 注意 对于非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true； 如果两个变量的值不在这个区间，则比较结果为false。 Java线程唤醒与阻塞的常用方法 sleep() 方法 sleep(毫秒)，指定以毫秒为单位的时间，使线程在该时间内进入线程阻塞状态，期间得不到cpu的时间片，等到时间过去了，线程重新进入可执行状态。(暂停线程，不会释放锁) yield() 方法： 会使得线程放弃当前分得的cpu时间片，但此时线程仍然处于可执行状态，随时可以再次分得cpu时间片。yield()方法只能使同优先级的线程有执行的机会。调用 yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。(暂停当前正在执行的线程，并执行其他线程，且让出的时间不可知) wait() 和 notify() 方法 两个方法搭配使用，wait()使线程进入阻塞状态，调用notify()时，线程进入可执行状态。wait()内可加或不加参数，加参数时是以毫秒为单位，当到了指定时间或调用notify()方法时，进入可执行状态。(属于Object类，而不属于Thread类，wait()会先释放锁住的对象，然后再执行等待的动作。由于wait()所等待的对象必须先锁住，因此，它只能用在同步化程序段或者同步化方法内，否则，会抛出异常IllegalMonitorStateException.) 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？1、 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。 2、 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。 频繁fullGc 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁gc) 是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了) 为什么HashTable是线程安全的？HashMap是线程不安全的 Hashtable下面代码 //get它搞成了同步方法，保证了get的安全性 public synchronized V get(Object key) { …… } //synchronized,同样 public synchronized V put(K key, V value) { …… } //也是搞成了同步方法 public synchronized V remove(Object key) { …… } finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。 finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。 。finalize()方法允许被重写，一般在该方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。 用最有效率的方法计算2乘以8？2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方 什么是JDK?什么是JRE？JDK = JRE + Java 开发工具包 [Java,Javac,Javadoc,Javap等] JRE = JVM + Java 的核心类库 [类] JRE顾名思义是java运行时环境 JDK顾名思义是java开发工具包 JDK（Java Development Kit）是Java的开发工具包，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等 如何通过获取和设置对象私有字段的值？import com.fasterxml.jackson.annotation.JsonProperty; public class SysUser { // @JsonProperty(\"roleIdList\") private Long[] roleIds; } public Long[] getRoleIds() { return roleIds; } public void setRoleIds(Long[] roleIds) { this.roleIds = roleIds; } 下面是获取 import com.fasterxml.jackson.annotation.JsonProperty; public static Object getFieldValueByObject(Object object, String targetFieldName) throws Exception { // 获取该对象的Class Class objClass = object.getClass(); // 初始化返回值 Object result = null; // 获取所有的属性数组 Field[] fields = objClass.getDeclaredFields(); for (Field field : fields) { // 属性名称 String currentFieldName = \"\"; // 获取属性上面的注解 import com.fasterxml.jackson.annotation.JsonProperty; /** * 举例： @JsonProperty(\"roleIds\") * private String roleIds; */ try { boolean has_JsonProperty = field.isAnnotationPresent(JsonProperty.class); if (has_JsonProperty) { currentFieldName = field.getAnnotation(JsonProperty.class).value(); } else { currentFieldName = field.getName(); } if (currentFieldName.equals(targetFieldName)) { field.setAccessible(true); result = field.get(object); return result; // 通过拿到该属性在此对象中的值(也可能是个对象) } } catch (SecurityException e) { // 安全性异常 e.printStackTrace(); } catch (IllegalArgumentException e) { // 非法参数 e.printStackTrace(); } catch (IllegalAccessException e) { // 无访问权限 e.printStackTrace(); } } return result; } 主要的 Field[] fields = objClass.getDeclaredFields(); field.setAccessible(true); 并发编程三要素1、原子性 原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操 作打断，要么就全部都不执行。 2、可见性 可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他 线程可以立即看到修改的结果。 3、有序性 有序性，即程序的执行顺序按照代码的先后顺序来执行。 讲讲什么情况下会出现内存泄漏？内存泄漏的原因很简单： 1、 对象是可达的(一直被引用) 2、 但是对象不会被使用 例子 public static void main(String[] args) { Set&lt;Object&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { Object object = new Object(); set.add(object); // 设置为空，该对象不再使用 object = null; } // 但是set集合中还维护object的引用，gc不会回收object对象 System.out.println(set); System.out.println(set.size()); } } 解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。 内存溢出常见原因及解决方法引起内存溢出的原因有很多种，常见的有以下几种： 1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据。 解决方法：检查对数据库查询中，是否有一次获得全部数据的查询；对于数据库查询尽量采用分页的方式查询。 2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。 解决方法：检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。（内存泄露） 3.代码中存在死循环或循环产生过多重复的对象实体。 解决方法：检查代码中是否有死循环或递归调用；检查是否有大循环重复产生新对象实体。 4.使用的第三方软件中的BUG。 解决方法：使用内存查看工具动态查看内存使用情况。 5.启动参数内存值设定的过小； 解决方法：修改JVM启动参数(-Xms，-Xmx)，直接增加内存。 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。 乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 动态代理为什么 Thread 类的 sleep()和 yield ()方法是静态的？Java对象创建过程java创建对象的过程主要分为一下五个步骤：（1）类加载检查Java虚拟机（jvm）在读取一条new指令时候，首先检查能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化。如果没有，则会先执行相应的类加载过程。 （2）内存分配在通过（1）后，则开始为新生的对象分配内存。该对象所需的内存大小在类加载完成后便可确定，因此为每个对象分配的内存大小是确定的。而分配方式主要有两种，分别为： 1.指针碰撞 应用场合：堆内存规整（通俗的说就是用过的内存被整齐充分的利用，用过的内存放在一边，没有用过的放在另外一边，而中间利用一个分界值指针对这两边的内存进行分界，从而掌握内存分配情况）。 即在开辟内存空间时候，将分界值指针往没用过的内存方向移动向应大小位置即可）。 将堆内存这样划分的代表的GC收集器算法有：Serial，ParNew 2.空闲列表 应用场合;堆内存不规整（虚拟机维护一个可以记录内存块是否可以用的列表来了解内存分配情况） 即在开辟内存空间时候，找到一块足够大的内存块分配给该对象即可，同时更新记录列表。 将堆内存这样划分的代表的GC收集器算法有：CMS （3）初始化默认值第（2）步完成后，紧接着，虚拟机需要将分配到的内存空间都进行初始化（即给一些默认值），这将做是为了保证对象实例的字段在Java代码中可以在不赋初值的情况下使用。程序可以访问到这些字段对用数据类型的默认值。 （4）设置对象头初始化（3）完成后，虚拟机对对象进行一些简单设置，如标记该对象是那个类的实例，这个对象的hash码，该对象所处的年龄段等等（这些可以理解为对象实例的基本信息）。这些信息被卸载对象头中。jvm根据当前的运行状态，会给出不同的设置方式。 （5）执行初始化方法在（4）完成后，最后执行由开发人员编写的对象的初始化方法，把对象按照开发人员的设计进行初始化，一个对象便创建出来了。 会导致类初始化 会导致 类初始化 的情况 main 方法所在的类，总会被首先初始化 首次访问这个类的 静态变量 或 静态方法 时 子类初始化，如果父类还未初始化，会引发 子类访问父类的静态变量，只会触发父类的初始化 Class.forName new 会导致初始化 不会导致 类初始化 的情况 访问 类的 static final 静态变量（基本类型和字符型）不会触发初始化 类对象.class 不会触发初始化 创建该类的数组不会触发初始化 类加载的 loadClass 方法 Class.forName 的参数2 为 false 时 final不可变对象，它对写并发应用有什么帮助？不可变对象天生是线程安全的。 Java中操作字符串使用哪个类？操作字符串的类主要用三个,分别是String类,StringBuffer类和StringBuilder类. MyBatis中使用#和$书写占位符有什么区别？#将传入的数据都当成一个字符串，会对传入的数据自动加上引号； # 使用#传入参数是，sql语句解析是会加上””,比如 select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是 select * from table where name = ‘小李’， $ 另外一种场景是，如果你要做动态的排序，比如 order by column，这个时候务必要用${},因为如果你使用了#{},那么打印出来的将会是 select * from table order by ‘name’ ,这样是没用， 注意 目前来看，能用#就不要用$,使用 $ 占位符可能会导致SQL注入攻击 String、StringBuffer、StringBuilder的区别是什么 String：不可变 StringBuffer：可变的，线程安全 StringBuilder：可变的，线程不安全 线程安全： String因为是不可变，也可理解为常量，因此是线程安全的。而StringBuffer 和 StringBuilder 继承自AbstractStringBuilder，而AbstractStringBuilder定义了一些基本字符操作，如append、insert、indexOf等，在StringBuffer的方法中加了同步锁，因此StringBuffer是线程安全的。而StringBuilder没有相应的锁，所以非线程安全。 可变性： 简单而言，String类使用Final关键字字符数组保存字符串，private final char[] value，所以String是不可变的。而StringBuffer 和 StringBuilder 都是继承自AbstractStringBuilder，而AbstractStringBuilder 也是使用使用字符s数组保护字符串，不过没有final关键字，char[] value，所以后两者是可变的 对三者使用的总结： 操作量少：String 单线程操作量大：StringBuilder 多线程操作量大：StringBuffer 如何通过创建对象？1、 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 2、 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 运行时常量池溢出的原因？不断创建常量，比如字符串等。 什么是JSON？json的全称为：JavaScript Object Notation，是一种轻量级的数据交互格式。 优点 1、方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是xml、纯字符串的方式，但json有其独到的好处。google有个自己的协议，叫protobuf，有兴趣可了解一下。2、方便转换。有很多的json api提供了json字符串转成对象、对象转换成json串的方法。3、易于阅读。json代码的良好结构，可以很直观地了解存的是什么内容。 Minor GC与Full GC分别在什么时候发生？ Minor GC / Young GC 首先我们先来看下 Minor GC / Young GC，大家都知道，新生代(Young Gen)也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。 此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC，这两个名词，相信大家就理解了，说白了，就专门针对新生代的 GC。 Full GC 对于 Full GC，其实这里有一个更加合适的说法，就是说 Full GC 指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为 Full GC。 从字面意思上也可以理解，Full 就是整体的意思，所以就是对 JVM 进行一次整体的垃圾回收，把各个内存区域的垃圾都回收掉。 MajorGC 老年代 什么是可重入锁synchronized、ReentrantLock都是可重入的锁，可重入锁相对来说简化了并发编程的开发。 可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。synchronized 和 ReentrantLock 都是可重入锁。 可重入锁的意义之一在于防止死锁。 Java常见的锁总结 可重入锁、乐观锁、悲观锁、公平锁、非公平锁、自旋锁等 自旋锁在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。 为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 缺点 ​ 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。 如果锁被占用的时间很短，自旋等待的效果就会非常好；如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置） 实现原理 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 public final int getAndAddInt (Object var1, Long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while( !this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 线程同步和线程异步有什么区别同步和异步的区别，比如说某一次测验：同步：老师派科代表去办公室拿试卷，然后一直等到拿回来试卷，没错就是干等什么都不做，然后发卷子。老师一直等到卷子都发完，才开始说明测验内容。等到说明完了之后，学生才开始做卷子。。。异步：老师派科代表去办公室拿试卷，然后老师简单的介绍测验内容（此时介绍测验内容和科代表拿试卷是同时进行的），科代表拿回试卷后“通知”老师试卷已经拿回来了。老师可以暂停讲解，让科代表发卷子并继续讲解（老师比较嘴碎）。发完卷子学生一遍开始做卷子一遍听老师讲解（老师比较嘴碎，讲了这么久都没讲完）。 什么是线程同步和互斥同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。 OOP中的组合、聚合和关联有什么区别？如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的 关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指 一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在， 但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 理解 比如A类中包含B类的一个引用b，当A类的一个对象消亡时，b这个引用所指向的对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫做组合，反之b所指向的对象还会有另外的引用指向它，这种情况叫聚合。 在实际写代码时组合方式一般会这样写：A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡。聚合方式则是这样：A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它传给它的这个对象不是A类创建的。 代码 聚合 class Driver { //使用成员变量形式实现聚合关系 Car mycar; public void drive(){ mycar.run(); } } 组合(上面的代码加上这些) public Driver(Car car){ mycar = car; } 自动装箱和自动拆箱自动装箱和自动拆箱自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。JDK1.5后，Java引入了自动装箱(autoboxing)/拆箱(unboxing)。自动装箱：基本类型的数据处于需要对象的环境中时，会自动转为“对象”。自动拆箱：每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用Integer 设计模式六大原则：1、单一原则（Single Responsibility Principle）：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化； a、业务对象（BO business object）、业务逻辑（BL business logic）拆分； 2、里氏替换原则（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能；（本质其实就是c++的多态） （目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。 3、依赖倒置原则（dependence inversion principle）：面向接口编程；（通过接口作为参数实现应用场景） 抽象就是接口或者抽象类，细节就是实现类 含义： 上层模块不应该依赖下层模块，两者应依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象； 通俗点就是说变量或者传参数，尽量使用抽象类，或者接口； 【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】 4、接口隔离原则（interface segregation principle）：建立单一接口；（扩展为类也是一种接口，一切皆接口） 定义： a.客户端不应该依赖它不需要的接口； b.类之间依赖关系应该建立在最小的接口上； 简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用） 【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】 5、迪米特原则（law of demeter LOD）：最少知道原则，尽量降低类与类之间的耦合； 一个对象应该对其他对象有最少的了解 6、开闭原则（open closed principle）：用抽象构建架构，用实现扩展原则； url一般有哪几部分组成？一般标准的URL由协议、主机名、路径及文件名三部分00组0成。 comparable和comparator的区别 相同点： 两个都是接口都是实现比较的返回值都是a&gt;b返回正整数,a=b返回0，a&lt;b返回负数。 不同点： comparable位于java.lang包下面，而comparator位于java.util包下comparable实现的是自连接（比如String类），就是将自己和指定的一个对象进行比较，而comparator是另外的一个类的一个方法将两个不相关的对象进行比较，很显然comparator的耦合性比comparable的耦合性要低。 注意 在一些集合里面要对类进行排序，而这些类在设计的时候没有考虑到要进行排序，那么这时候我们唯一的办法就是传递一个comparator的接口给他让他进行比较。 为什么代码会重排序？重排序的好处：提高处理速度 如何写一段简单的死锁代码？public class DeadLockDemo { public static void main(String[] args) { Object object1 = new Object(); Object object2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (object1) { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (object2) { } } }, \"deadlock-demo-1\"); t1.start(); Thread t2 = new Thread(() -&gt; { synchronized (object2) { synchronized (object1) { } } }, \"deadlock-demo-2\"); t2.start(); } } float f=3.4;是否正确？答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 我们可以在 hashcode() 中使用随机数字吗？ 为什么要有hashcode总结:如果一个对象 不往 与hash有关的集合中放 那么hashcode()方法 写不写无所谓, 否则必须写hashcode方法 ,hashcode能加快比较的速度 , equals 相等 hashcode 必须相等 hashcode不相等 equals 必不相等 因为如果两个对象相等，hashcode一定相同，不可能是个随机数 你所知道网络协议有那些？TCP/IP协议、UDP协议、HTTP协议、FTP协议、Telnet协议、SMTP协议、NFS协议等。 FTP：文件传输协议 SMPT：简单邮件协议 程序的结构有那些？由顺序结构、选择结构、循环结构 如何打破双亲委派模型自定义类加载器，重写loadclass方法。 linkedlist和arraylist的区别是什么1、数据结构不同 ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。 2、效率不同 当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。 当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。 3、自由性不同 ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 4、主要控件开销不同 ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。 hashcode和equals如何使用hashcode冲突了，jdk1.7是采用链式继续存，这时候用equals比较 方法传参机制 string、包装类不可变性 例如上面的字符串s，它是指向与常量池，在传参后也是另一个方法也是指向与常量池。在另一个方法进行修改的时候，因为字符串的不可变性，它会产生一个新的字符串，然后把这个新的字符串重新赋值给这个参数，原来方法所指向的不变。（interger包装类也是一样的，它会产生一个新的，所以原来的不会改变，但注意interger 127这个范围） 成员变量与局部变量 作用域 布隆过滤器 布隆过滤器是一个二进制数组，只有0和1.在存储的时候根据多个hash函数计算位置，把对应位置改成1.判断的时候也是这样判断，要查到所有hash函数对应的都是1才存在 缺点 第一个缺点是误判，哈希冲突 第二个是不适合删除，因为可能多个映射到一个位置，删除的话是把对应值改成0，这样把其他的也删除了 优点 安全，都是0和1，谁也不晓得是啥 快，数组随机存储，快的一批 可重入锁指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，目的为了避免死锁 java泛型 java的static方法无法被重写 静态方法是无法被重写（Override）的，如果强行加上 @Override 注解，编译时会报错 “java: 方法不会覆盖或实现超类型的方法”。原因：重写的作用是为了父类和子类的相同签名的方法，具有不同的行为，从而实现了 多态 。但是静态方法是被类直接调用的，和对象无关，不存在父子类对象之间的相同方法不同行为，所以也没有多态。 子类可以直接调用父类的静态方法。虽说子类无法重写父类的静态方法，但是却可以直接调用父类的静态方法，调用方式是 子类名.父类静态方法() ，当然，也可以 **子类对象.父类静态方法()**，不过没必要，也不建议。 字符串创建对象个数面试题：String str4 = new String(“abc”) 创建多少个对象？ 在常量池中查找是否有“abc”对象 有则返回对应的引用实例 没有则创建对应的实例对象 在堆中 new 一个 String(“abc”) 对象 将对象地址赋值给str4,创建一个引用 所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用 根据字面量，往往会提出这样的变式题： String str1 = new String(“A”+”B”) ; 会创建多少个对象?String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象? str1：字符串常量池：”A”,”B”,”AB” : 3个堆：new String(“AB”) ：1个引用： str1 ：1个总共 ： 5个 str2 ：字符串常量池：”ABC” : 1个堆：new String(“ABC”) ：1个引用： str2 ：1个总共 ： 3个 运行时常量池和字符串常量池的区别常量池每个class一份，存在于字节码文件中。常量池中有字面量(数量值、字符串值)和符号引用(类符号引用、字段符号引用、方法符号引用)，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型 运行时常量池每个class一份，存在于方法区中(元空间)。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是下面的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。 字符串常量池每个JVM中只有一份，存在于方法区中(堆)。全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串（用双引号括起来的引用而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份 jdbc连接数据库的步骤是什么1、加载jdbc驱动程序； ​ 在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），这通过java.lang.Class类的静态方法forName(String className)实现。 2、创建数据库的连接； ​ •要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。​ •使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和密码来获得。 //连接MySql数据库，用户名和密码都是root String url = \"jdbc:mysql://localhost:3306/test\" ; String username = \"root\" ; String password = \"root\" ; try{ Connection con = DriverManager.getConnection(url , username , password ) ; }catch(SQLException se){ System.out.println(\"数据库连接失败！\"); se.printStackTrace() ; } 3、创建preparedStatement； •要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：1、执行静态SQL语句。通常通过Statement实例实现。2、执行动态SQL语句。通常通过PreparedStatement实例实现。3、执行数据库存储过程。通常通过CallableStatement实例实现。•具体的实现方式： Statement stmt = con.createStatement() ; PreparedStatement pstmt = con.prepareStatement(sql) ; CallableStatement cstmt = con.prepareCall(\"{CALL demoSp(? , ?)}\") ; 4、执行SQL语句；5、遍历结果集；6、处理异常，关闭JDBC对象资源。 threadLocal应用场景 链接数据库 hasmap扩容扩容容量扩容容量就是2倍，因为容量是2 的幂次方，扩容也是左移一位，例如16&lt;&lt;1 = 32 为啥用左移，不是乘法 主要是提升cpu性能，因为cpu是不支持乘法运算的，所有的运算会转换成加法，移位可以提高效率 理解 不指定，就是16，可以在构造函数指定，但会转化为2的幂数（3变4） 为啥要转换成2的幂数 为了末尾是1 由于哈希值是和长度-1进行取余 例如16是10000，减一后变成01111，这样取余可以。 但15如果不变成最近的2的幂数，则15对应的是01111，减一后变成01110，这样15（1111）和14（1110）取余后的结果是一致的，增加了冲突 参考 https://www.bilibili.com/video/BV1Yu411y7Jr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc 啥时候扩容负载因子和长度乘积决定 扩容死循环只在1.7版本有，因为采取了头插法 在多线程扩容下 如上图所示，如果在扩容的时候T2线程休眠，这时候T1进行扩容 扩容完成之后T2的节点和next节点会反过来，这时候T2在进行扩容，会形成死循环 如何解决 在1.8改成了尾插法，直接解决了 在1.7，可以使用 参考 https://www.bilibili.com/video/BV1oD4y1b7RF?p=2&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc 如何扩容（数据迁移）主要分为四个种类状态，节点是null，只有一个节点，有一个链，有红黑树 null 不用处理 只有一个节点 只有一个节点，说明没有发生冲突，直接迁移就行，根据新表长度计算出在新表的位置，然后放进去就行 只有一个链 说明发生了冲突，需要把当前这个链表拆分成两类，分为高位链和低位链 由于冲突成链了，所以这个链表中低位都是相同的（都是和长度-1计算出来的）（例如16，减一后变成01111，低位是后4位，高位是第五位，目前链表的低位一定是相同的，高位不一样，有的是0，有的是1） 对于高位是1的，到新表扩容肯定是变多了，是老表的位置加老表的size，因为高位1就是老表的长度。（例如，表长度是16，8的位置扩容后在新表的位置应该是8+16=24这个位置） 红黑树 也是高低位（以后再看）","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"linux","slug":"linux","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:21:54.981Z","comments":true,"path":"posts/7f1ae6do.html","link":"","permalink":"http://example.com/posts/7f1ae6do.html","excerpt":"","text":"目录结构bin sbin etc home usr root tmp vim快捷键 关机和重启的命令shutdown -h now 立刻进行关机 shutdown -h 1 ”hello，1分钟后会关机了“ shutdown -r now 现在重新启动计算机 halt 关机 reboot 重新启动 syn 把内存的数据同步到磁盘 注意：目前的shutdown/reboot/halt 等命令均已经在关机前进行了sync，但是在执行关机或重启前sync一下，小心驶得万年船 用户管理 用户切换 [halo@zwb-lucky root]$ su root Password: [root@zwb-lucky ~]# su - 用户名“命令来切换 注意 1.从权限高的用户切换到权限低的用户时，不需要输入密码，反之需要 2.当需要返回到原来用户时，使用exit/logout指令 添加用户 基本语法 useradd 用户名 实列(root权限下) useradd hucheng 添加一个用户chucheng，默认该用户的家目录在/home/hucheng 细节说明 1、当用户创建成功后果，会自动的创建和用户同名的家目录 2、也可以通过useradd -d 指定目录 新的用户名 来给新创建的用户指定家目录 12 新建用户zhanzhiwen的home目录下的文件夹名称是muluming 指定/修改密码 passwd 用户名 注意：修改密码要在root下 [zhangsan@zwb-lucky home]$ passwd zhangsan passwd: Only root can specify a user name. 删除用户 userdel 用户名 userdel -r 用户名 查询用户信息指令 id 用户名 [root@zwb-lucky ~]# id root uid=0(root) gid=0(root) groups=0(root) [root@zwb-lucky ~]# id halo uid=1000(halo) gid=1000(halo) groups=1000(halo),10(wheel) 查看当前用户/登录用户 whoami/who am i 用户组 类似于角色，系统可以对有共性/权限的多个用户进行统一的管理 新增组 指令：groupadd 组名 删除组 指令（基本语法）：groupdel 组名 注意：如果当添加用户时没有指定组，会默认创建和这个用户同名的组，同时把用户放到该组里 增加用户时直接加上组 指令：useradd -g 用户组 用户名 移动组 usermod -g 组名 用户名 运行级别说明：0：关机 1：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，也可以指定默认运行级别 帮助指令 man获得帮助信息 基本语法：man [命令或配置文件]（功能描述：获得帮助信息） 在linux下隐藏文件是以 “.” 开头的 help指令 基本语法：help 命令 （功能描述：获得shell内置命令的帮助信息） 文件目录类 pwd指令 基本语法：pwd （功能描述：显示当前工作目录的绝对路径） ls指令 基本语法：ls [选项] [目录或是文件] 常用选项 -a ： 显示当前目录所有的文件和目录，包括隐藏的 -l ： 以列表的方式显示信息 cd指令 基本语法：cd [参数] （功能描述：切换到指定的目录） 理解：绝对路径和相对路径（相对路径是针对当前位置的路径） cd ~ 或者cd 回到自己的家目录 cd … 回到当前目录的上一级目录 mkdir指令 基本语法：mkdir [选项] 要创建的目录 理解：mkdir指令用于创建目录（默认只能创建一级目录） -p :创建多级目录 rmdir指令（用于删除空目录） 基本语法：rmdir [选项] 要删除的空目录 使用细节： rmdir删除的是空目录，如果欲删除的目录下有内容则无法删除 ==如果需要删除非空目录，需要使用rm -rf 要删除的目录 touch指令（用于创建空文件） touch 文件名称 cp指令（copy拷贝文件导指定目录） cp [选项] source dest 常用选项：-r 递归复制真个文件夹 应用实例: 将 /home/hello.txt 拷贝到 /home/bbb 目录下 cp /home/hello.txt /home/bbb 递归复制整个文件夹，将/home/aaa 目录下的文件全部拷贝到/home/bbb下 cp -r /home/aaa /hom/bbb (是将整个目录和目录本身拷贝进来) rm指令（remove，移除文件或目录）=一定要小心！！！ 基本语法：rm [选项] 要删除的文件或目录 常用选项 -r : 递归删除整个文件夹 -f ：强制删除不提示 使用细节：强制删除不提示的方式，带上-f参数即可 cat指令（查看文件内容） cat [选项] 要查看的文件 常用选项： -n 显示行号 使用细节：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 |more cat -n /etc/profile |more 输入到控制台 查看历史 过滤查找，带行号","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"spring","slug":"spring5","date":"2020-03-14T16:00:00.000Z","updated":"2023-06-04T03:13:03.172Z","comments":true,"path":"posts/7f1ae6sp.html","link":"","permalink":"http://example.com/posts/7f1ae6sp.html","excerpt":"","text":"ioc为了降低耦合度 底层原理 xml解析、工厂模式、反射 工厂模式 它的出现就是为了解耦合 ioc 工厂不在new了，通过反射来创建对象，这样我们只需要修改xml就可以了 Spring提供的IOC容器实现的两种方式（两个接口） BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。） ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！ 注入 set &lt;!--（2）spring方式： set方法注入属性--&gt; &lt;bean id=\"book\" class=\"com.atguigu.spring5.Book\"&gt; &lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --&gt; &lt;property name=\"bname\" value=\"Hello\"&gt;&lt;/property&gt; &lt;property name=\"bauthor\" value=\"World\"&gt;&lt;/property&gt; &lt;/bean&gt; construct &lt;!--（2）spring方式：有参数构造注入属性--&gt; &lt;bean id=\"orders\" class=\"com.atguigu.spring5.Orders\"&gt; &lt;constructor-arg name=\"oname\" value=\"Hello\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"address\" value=\"China！\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 注入空值和特殊值 &lt;bean id=\"book\" class=\"com.atguigu.spring5.Book\"&gt; &lt;!--（1）null值--&gt; &lt;property name=\"address\"&gt; &lt;null/&gt;&lt;!--属性里边添加一个null标签--&gt; &lt;/property&gt; &lt;!--（2）特殊符号赋值--&gt; &lt;!--属性值包含特殊符号 a 把&lt;&gt;进行转义 &amp;lt; &amp;gt; b 把带特殊符号内容写到CDATA --&gt; &lt;property name=\"address\"&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 注入外部bean &lt;!--1 service和dao对象创建--&gt; &lt;bean id=\"userService\" class=\"com.atguigu.spring5.service.UserService\"&gt; &lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userDaoImpl\" class=\"com.atguigu.spring5.dao.UserDaoImpl\"&gt;&lt;/bean&gt; xml 注入集合属性 &lt;!--（2）在 spring 配置文件进行配置--&gt; &lt;bean id=\"stu\" class=\"com.atguigu.spring5.collectiontype.Stu\"&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=\"courses\"&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list类型属性注入--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map类型属性注入--&gt; &lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"JAVA\" value=\"java\"&gt;&lt;/entry&gt; &lt;entry key=\"PHP\" value=\"php\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set类型属性注入--&gt; &lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 在集合里面设置对象类型值 &lt;!--创建多个course对象--&gt; &lt;bean id=\"course1\" class=\"com.atguigu.spring5.collectiontype.Course\"&gt; &lt;property name=\"cname\" value=\"Spring5框架\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"course2\" class=\"com.atguigu.spring5.collectiontype.Course\"&gt; &lt;property name=\"cname\" value=\"MyBatis框架\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--注入list集合类型，值是对象--&gt; &lt;property name=\"courseList\"&gt; &lt;list&gt; &lt;ref bean=\"course1\"&gt;&lt;/ref&gt; &lt;ref bean=\"course2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 自动装配 两个的弊端：byname必须名字一样，要不不行 bytype，两个同类型的容器不行，直接报错 注解实现 当然要首先开启注解的支持 @Autowired @Qualifier @Resource Bean 的作用域有哪些?Spring 中 Bean 的作用域通常有下面几种： singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。（单例） prototype : 每次请求都会创建一个新的 bean 实例。（原型） request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。 单例 Bean 的线程安全问题了解吗？大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。 常见的有两种解决办法： 在 Bean 中尽量避免定义可变的成员变量。 在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。 (换成原型模式就安全了)（加锁当然也可以不过会降低效率） 代理模式这是spring aop的底层 aop切面编程 AOP(Aspect Oriented Programming)：面向切面编程，一种编程范式，AOP弥补了OOP的不足，基于OOP基础之上进行横向开发。 OOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型；AOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行， springmvc的执行流程 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。（被它拦截，拦截什么可以配置，比如配置/nihao，就拦截/你好）(一般写/，全拦截就行了) DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。（这个是根据url获取handler） url分为什么 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样： if(mappedHandler.getHandler() instanceof MultiActionController){ ((MultiActionController)mappedHandler.getHandler()).xxx }else if(mappedHandler.getHandler() instanceof XXX){ ... }else if(...){ ... } 这样假设如果我们增加一个 HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof HardController)，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。 HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器 什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 转发和重定向1、请求次数 重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次； 2、地址栏不同 重定向地址栏会发生变化，转发地址栏不会发生变化； 3、是否共享数据 重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）； 4、跳转限制 重定向可以跳转到任意URL，转发只能跳转本站点资源； 5、发生行为不同 重定向是客户端行为，转发是服务器端行为； 请求转发：request.getRequestDispatcher(“info.html”).forward(request, response); 请求重定向：response.sendRedirect(“1.html”); 项目构建 先创建一个父工程 删除父工程src，因为用不到 导入自己知道的公共依赖 创建子工程，一个普通的maven即可 servlet继承httpservlet，重写doGet、depost 乱码问题过滤器解决乱码 配置文件配置 (上面的/换/*) springmvc自带过滤器（在配置文件上配置就可以了） jison它是一种数据格式，现在都是前后端分离开放，需要这样一种格式约定 requestbody了解http请求 第一行是请求url；包含请求类型，地址等 第二行是请求头；包含身份信息，请求内容的类型等 然后空行 第四行请求体： get请求是url传参的，例如上面？后面的 post请求体传参的，比如上面两个，可能是json或者字符串（表单）等等 测试 加上requestbody get请求不行，post请求表单不行，jsion可以 不加requestbody get，post表单都可以。jsion不行 所以处理传来的是jison的时候加上requestbody 注意 用requestbody修饰字符串的时候，会接收整个jsion 所以requestbody尽量修饰一个实体参数，或者map requestparam其实这个在参数上加和不加是一样的，只不过加上可以解决前端和后端传递参数名不一致的情况 跨域问题1.使用注解 (局部跨域) 在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。 @RestController @CrossOrigin(origins = \"*\") public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"hello world\"; } } 2.手动设置响应头(局部跨域) 使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。 @RequestMapping(\"/index\") public String index(HttpServletResponse response) { response.addHeader(\"Access-Allow-Control-Origin\",\"*\"); return \"index\"; } 3.使用自定义filter实现跨域 package cn.wideth.aop; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; @Component public class MyCorsFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with,content-type\"); chain.doFilter(req, res); } public void init(FilterConfig filterConfig) {} public void destroy() {} } get请求和post请求的区别1.get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。 2.get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；post请求是没有的长度限制，请求数据是放在body中； 3.get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。 4.get请求可以被缓存，post请求不会被缓存。 5.get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。 6.get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。 requestbody和RequestParamRequestBody注解的主要作用就是用于接收前端的参数，当我们使用post请求的时候，我们会将参数放在request body中，此时我们就需要在Controller的方法的参数前面加上@RequestBody用来接受到前端传过来的request body中的值，举个栗子： @Controller @RequestMapping（“/test”） public class test{ public void testMethod(@RequestBody String string)\"{ System.out.println(\"测试\"); } } 一个请求只能有一个RequestBody，也就是说，当一个方法中有两个参数的时候，最多只能有一个参数加@RequestBody注解用来接受request body中的参数； @RequestParam接收的参数主要是来自request Header中，即请求头中。通常用于get请求中，我们都知道get请求的参数都是写在url中的，例如：http://localhost:8080/my/api/testMethod?name=雷神&amp;age=3 该url我们可以看到有那么和age两种属性，那么当我们将此请求发送到后台服务以后，Controller写法如下： @Controller @RequesMapping（“/api”） public class test{ public void testMethod(@RequestParam(value=\"name\",required=false,defaultValue=\"雷神\")String name,@RequestParam(value=\"age\")Int age){ System.out.println(\"年仅\"+age+“岁肥宅”+name); } } 注意 RequestBody的作用是将前端传来的json格式的数据转为自己定义好的javabean对象，需要注意的是传入数据的属性名称要和后端javabean中定义的一致，发送请求后可以看到在控制台中我们通过javabean对象的get方法打印出了前端传来的值，说明json数据已经成功被转换为了javabean对象，将对应的属性进行了赋值。 SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解： 1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。 2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。 springboot自动配置 springboot启动流程 原理 https://blog.csdn.net/m0_46316970/article/details/125898849 @ComponentScan 扫描类，可以扫描很多个类还是只能一个类？默认情况下,@ComponentScan扫描入口类同级及其子级包下的所有文件。 扫描其他包 动指定扫描包路径。 springboot自动装配 自动装配和自动配置 自动装配是autowire 自动配置是auto-configuration 自动配置 这里用@ComponentScan来加载我们application路径下的包，用@EnableAutoConfiguration来用spring factory机制来加载第三方的jar包的配置类，所有加载好后，再去加载这些配置类用@Import，@Bean等注解去加载的别的配置类，此时所有需要加载的配置类都加载好了，再去实例化这些bean，将这些bean注册到IOC中 https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc @import 用法 1、直接填class数组方式2、ImportSelector方式【重点】3、ImportBeanDefinitionRegistrar方式 普通 @Import({ 类名.class , 类名.class... }) public class TestDemo { } ImportSelector 分析实现接口的selectImports方法中的：1、返回值： 就是我们实际上要导入到容器中的组件全类名【重点 】2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！ 第一步：创建Myclass类并实现ImportSelector接口，这里用于演示就添加一个全类名给其返回值 public class Myclass implements ImportSelector {//要实现ImportSelector接口 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { return new String[]{\"com.yc.Test.TestDemo3\"};//这里是要导入的全限定名 } } 类似注入多个，每个用它的全限定名 第二步：使用ImportSelector方式的Myclass类 @Import({Myclass.class}) 参考 https://blog.csdn.net/a14654/article/details/114398753 https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"人文科技","slug":"人文科技","date":"2020-03-14T16:00:00.000Z","updated":"2023-12-24T09:12:34.779Z","comments":true,"path":"posts/7a46we34.html","link":"","permalink":"http://example.com/posts/7a46we34.html","excerpt":"","text":"科举考试 隋炀帝的时候正式形成 唐太宗：进士（考的杂）和明经（这个类似选词填空，比如说己所不欲后半句是啥） 武则天：这里有武状元和文状元，殿试要皇帝来考你 唐朝主要考唐诗这些 北宋的这个是防止作弊的，把考生文章抄一份，这样就没办法作弊了 明清的三级考试制度：乡试、会试（中央考的）、殿试 1905年废除 物理化学变化化学变化：有新物质的生产 焰色反应（燃烧颜色，这是物理变化） 铜变铜绿（化学，碳酸铜） 光合作用（化学） 泥土烧成瓷器（化学） 四灵麒麟、凤凰、乌龟、龙（这些都是祥瑞的标志） 百家争鸣 孔子 至圣 论语不是孔子写的，是他后来弟子进行整理所得 孔子思想：仁（你爱我我爱你）礼（等级有序，不要越级） 教育上：有效无类（教育没有身份，你想学他就教）、因材施教 孟子 孟子继承和发展孔子思想 亚圣 政治上：民贵君轻，强调老百姓的重要性 认为人性是善的 荀子 认为人性是恶的，不教育就恶，提倡礼法并用 他是唯物主义 老子 道 道生一，一生二，二生万物 他是客观唯心主义（道摸不着，看不见） 政治上主张：无为而治，就是君主不要过多的干预老百姓，他们自然发展 哲学上：有辩证法的思想，福祸相依这些 庄子 思想：齐物论，强调世界万物都是一样的，没有善恶美丑的区别，没有贵贱之分。追求精神的极大自由 墨子 非攻，反对侵略 注意 墨家和儒家都有爱，但不同，儒家的爱有等级，墨家没有","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"中国党史","slug":"中共党史","date":"2020-03-14T16:00:00.000Z","updated":"2023-10-28T14:37:20.277Z","comments":true,"path":"posts/7a46f35i.html","link":"","permalink":"http://example.com/posts/7a46f35i.html","excerpt":"","text":"党史 青年杂志1915年陈独秀创办《青年杂志》，这是新文化运动。以鲁迅、胡适等，有两个口号，’德先生‘（民主）、’赛先生‘（科学）。（新文化运动是在前面的失败了操弄，比如戊戌变法、辛亥革命）（青年杂志把马克思主义传到中国，在这之前，并没有马克思主义） 陈独秀是《青年杂志的创办者》，实际发稿最多的是李大钊 最先提出“中国共产党”这个名称的是蔡和森 开眼看世界的第一人是林则徐 把马克思引入到中国的第一人是李大钊 《青年杂志》带来了马克思主义理论 十月革命列宁领导的 给中国带来了马克思主义实践 五四运动这是党史的开端 五四运动导火索是巴黎和会（第一次世界大战刚结束，中国是战胜国，小日本欺负人，逼迫中国签订21条不平等合约，包括把山东割地给小日本，当时北洋政府居然同意了，但国内老百姓不愿意，学生罢课，工人罢工，商人罢市）（工人就是无产阶级，这里说明无产阶级开始走向政治的舞台） 五四运动标志着无产阶级走向了历史的舞台 五四运动标志着旧民主主义革命的结束和新民主主义革命的开端 第一次世界大战导火索虎门销烟 上面四个日期是等差，这样记忆好记 会议重要会议9+8，共17次 （绿色重要，红色了解） 一大（重要）年月日都记 参会人员13名（代表50多名，当时只有这么多党员）（毛泽东在这13中，但当时没有发言的机会，只能记录） 标志着共产党的诞生 党的生日7月1号 二大立纲 最高（终极目标，到今天也是）：实现共产主义 最低（最低目标，首要目标）：制定反帝反封建纲领 三大国共合作（共产党没有军队，但是国民党有，所以合作，那时候国民党孙中山同意了） 袁世凯嗝屁了（老大嗝屁了，下面的都想当老大，所以天天打，嗷嗷叫） 国民党一大提出“新三民” 上面三大相当于共产党要约，这里是给了 联俄联共助农工 国共正式合作是这时候开始的（1924年） 当时合作方式是共产党员以个人名义加入国民党（又是共产党，又是国民党） 合作的目的是打北洋军阀，开始北伐，到1927年差不多干完了 国民党最后撕票了，孙中山去世，蒋介石和汪精卫掌权（汪精卫权大），蒋介石发动’四一二‘反革命（这里的主要目的是夺权，夺汪精卫的权，汪精卫后来不惜投靠小日本来干蒋介石，变成了中国第一大汉奸）（也是国共撕票），汪精卫发动’七一五‘反革命（他两个虽然是死对头，但共同的敌人是共产党，所以发动两个政变）开始暗杀共产党，危险（这时候党的领导人是陈独秀，他还想和国民党谈，再谈就灭团个去求了，所以后来不听他的了） 左倾和右倾（这是哲学中的质量互变，如果只看到质而忽略量，左倾。右倾是只看到量的积累，而忽略质。陈独秀是右倾，光想投降） 南昌起义上面说了陈独秀右倾，党内其他人（例如周恩来、朱德、贺龙）必须起义了，标志着军队的诞生 建军节就是8月1号，纪念这一天 打响了第一枪（打响国民党武装反抗）不服就干 周恩来、朱德、贺龙、叶挺、刘伯承（朱刘喝夜粥） 八七会议反右的会议，反对陈独秀右倾 毛主席发言了，枪杆里出政权 但是打不过啊，只能逃命，往农村逃，没吃的咋办，抢，抢地主的，这就来到了秋收起义 秋收起义打土豪、分田地，粮食带走，地没啥用，分给农民，土地归集体所有，集体所有制就这样诞生的 长征国民党对共产党的四次围剿都躲过去了，第五次没抗住，开始了长征。 这个时候领导人是王明，他是左倾（第五次他改防守为进攻，没攻出去，农村也待不住了，往山里逃命，往没人的地方逃，东北那边） 34年开始，36年会师，标志成功 湘江战役是长征以来最壮烈的一战 飞夺泸定桥也是一次重要战役 遵义会议1935年1月召开 反左的会议，确定了毛泽东的领导低位 标志着共产党走向了成熟 标志着第一次独立自主（之前也用，这次是独立自主，之前听有个共产国际的，否定了这群只会纸上谈兵的家伙）运用马列主义解决中国事情的会议 一二九运动1935年12月9号 1927-1937国共在内战 1931九一八小日本来了，主要干东北三省（习大大改这里，说抗日从这里开始的，也就是14年，到1945年抗日胜利） 这个时候国共还在内战（国民党还在追杀共产党，学生又看不下去了，这就是一二九运动） 学生游街示威了，要求国共两党停止内战，一致抗日 瓦窑堡会议共产生密切联系群众，会议上面的一二九了（没隔几天，都是1935年12月份） 第二次向国民党发送要约，国民党不愿意 到1936年，张学良和杨虎城看不下去了，发动西安事变，胁迫蒋介石停止内战 瓦窑堡会议是抗日统一战线 洛川会议是全面抗战路线 洛川会议1937年，会议通过了《抗日救国的十大纲领》 西安事变1936年12月12日 七七事变1937年小日本发动在北京卢沟桥事变 1937-45全面抗战时期（8年，以前书本写的是八年，但习大大改为14年，说1931-1937年虽然国共在内战没抗日，但东北在抗） 标志着抗日民族统一战线的正式达成 标志着日本全面侵华爆发 抗日战争胜利是在1945年8月15，9月2号签订投降书，9月3号被习大大命为抗日战争纪念日 淞沪会战（不重要）小日本从东北开始打，1937年七七事变，到10月份就打到上海了。这时候蒋介石发动74个师在这里和小日本干起来了（基本全面出动），为了转业自己的家业首都（这是首都在南京，也是小日本要去的地方） 国共合作后，共产党的部队收编到国民党中，比如新四军、八路军，但还是自己指挥自己。正面蒋介石打，游击共产党打 南京大屠杀1937年12月13日 淞沪会战蒋介石败了，小日本死了四W人左右，蒋介石死了30w左右，上海失手 德国拉贝记录了南京大屠杀 美国魏特琳，救了很多儿童，她挂上美国的国旗（小日本当时还害怕美国） 中共六届六中全会1938年9月 批判了王明的右倾投降主义, 马克思主义中国化（毛主席提出的） 刘少奇秒懂，所以马上开七大 中国七大这时候抗日快胜利了，可以同患难不能同富贵，所以先开个会 毛泽东思想诞生了 1945年4月 （这个是刘少奇组织召开的） 评价意义 评价意义是灯塔指引 一大的意义是开天辟地 遵义会议的意义是生死攸关 辽沈、淮海、平津战役这是共产党干国民党的，记住先后顺序就行 这里打完国民党大势已去，但毛主席没有乘胜追击，因为党内出现了问题 七届二中全会（重要）1949年 地点西柏坡 提出了两个务必，政治思想（别骄傲自满。务必保持戒躁急噪、谦虚谨慎，务必保持艰苦奋斗）（整顿思想） 第一个整顿党，党的自身建设 习大大也整治了，在十八届六中全会，提出全面从严治党 然后向南京开始进发，开始渡江战役(1949年4月21日胜利，4月23日南京解放) 三大改造在1949年10月1日建国的时候，是新民主主义国家，那时候觉得光无产阶级领导太小，就大家一起领导。是人民明主专政的社会主义国家 但我们的目标是社会主义，社会主义就是无产阶级领导的，所以要改造，消除其他（封建制度、私有制等）改造成公有制 1956年完成了 私有变成人民公社，这个时候才是社会主义社会 由于社会是从封建-资产阶级-社会主义，由于我们现在是社会主义，比较牛逼，所以毛主席认为可以跑得快，就出来了后面的大跃进（1956-1966年） 大跃进不行，毛主义一分析，觉得应该是队伍里有反动分子，影响了，所以立刻把知识分子剔除了队伍（文化大革命，都不要读书了，都去干活，踏实做事，消灭孔子，儒家思想，等知识忘干净了，在从头到尾学习马列主义、毛泽东思想）（1966-1976文化大革命失败） 1976年9月9号毛主席去世 1976年1月8号周恩来去世 十一届三中全会1978年12月 邓小平上台 1976-1978这两年邓小平并没有上台，不是很受拥戴（他资），后来上台是十大元帅之一叶剑英推选，大家都给叶帅一个面子。 这个会议拨乱反正，把党从阶级斗争转移到社会主义建设中来 改革开放 十一届六中全会关于党建设的若干问题 科学评价毛，七分功三分过 八个会议背诵 五年一开，2对双数大，7对单数大 进行换届选举，总结归纳 中国特色理论体系包括邓小平理论、三个代表、科学发展观 十四大主要搞市场经济，南方谈话 记忆：中国特色社会主义理论体系 中国特色社会主义 — 十二大邓小平提出 理论— 十三大邓小平理论（这个时候邓小平没这么说，他说是社会主义初级阶段和党在……）–十五大写入党章 体系 –十七大胡锦涛提出的 这个中国特色社会主义理论体系还包括三个代表（十六大写入党章）科学发展观（十八大写入党章）习大大思想（十九大写入党章） 三个代表思想是十三届四中全会形成的 会议小节 会议 十九大习近平中特 积累对民主资产阶级和平赎买、四马分肥（国家一份、资本家一份、企业一份、企业员工一份） 红船精神开天辟地、敢为人先的首创精神 鉴定信念、百折不挠的奋斗精神 立党为公、忠诚为民的奉献精神 南泥湾精神自力更生、艰苦奋斗 三会一课“四党” 支部党员大会、党支部委员会、党小组会，党课 中华苏维埃第一次全国代表大会在瑞金召开 三重一大重大事项决策、重要干部任免、重要项目安排、大额资金的使用，必须经过集体讨论做决定 新发展格局内涵：构建以国内大循环为主题，国内国际双循环相互促进的新发展格局 关键：经济循环畅通无阻 本质特征：高水平的自立自强 马克思主义阶级基础无产阶级作为一支独立的力量登上了历史舞台 《改造我们的学习》文中详细地解释了“实事求是的内涵”，他认为马克思主义和中国国情相结合就是实事求是的态度。“墙上芦苇，头重脚轻根底浅；山间竹笋，嘴尖皮厚腹中空。”（贬义对联，形容傲娇自满的人，不扎实做事，偏好虚名浮事；嘴上浮夸刻薄，而肚子里没有学问和真功夫。）讽刺了主观主义学风 党员预备党员到党员 考察期是一年 延长考察期不能超过一年 党员如果出去**六个月**以内就不用转移关系，如果是六个月以上且地方比较稳定，可以转移。 党龄是从转正之后开始算去，不是从预备党员开始算。 党的思想路线一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理 五位一体包括：经济建设、政治建设、文化建设、社会建设、生态建设 五位一体是对国家来说的，这里是经济建设最重要。全面从严治党是从党来说的，政治建设最重要 社会主义主要矛盾随着去国社会主义矛盾的变化，我国社会主义一变三不变 一变：人民日益增长的美好生活的需要和不平衡不充分发展之间的矛盾 两不变：我国仍然长期处于社会主义初级阶段的基本国情没有变 ​ 我国是世界上最大发展中国家没有变 低碳经济低排放、低耗能、低污染 延安整风改造—整顿—反对 改造我们学习标志着开始 毛泽东毛泽东同志在《〈共产党人〉发刊词》中系统论论述了中国革命胜利的“三大法宝”——统一战线、武装斗争、党的建设 毛泽东指出国民革命中心问题是农民问题。 毛泽东思想和邓小平理论，他们共有的是实事求是。邓小平理论另外加入了解放思想。 党的六届六中全会强调了学习的重要性。 中国革命的基本问题是农民问题 首要问题是中国革命，这是毛泽东提出的。 毛泽东思想初步形成的标志是农村包围城市。 邓小平邓小平在讨姓资还是姓社的问题，判断标准为两力一平。是否有利于发展社会主义生产力？是否有利于增强社会主义综合国力？是否有利于提高人民生活水平？ 教育坚持立德树人是教育的立身之本，是办好中国特色社会主义教育的核心理念。 教育投入的重中之重，义务教育教育是我国民族振兴和社会进步的基石。 基础知识六大在莫斯科召开 一国两制，爱国者治港 香山是进京赶考的第一站 党的生死攸关转折点遵义会议 中华名族生死攸关转折点是抗日战争胜利 党的基层组织是党在社会基层中战斗堡垒 党的纪律必须严于国法，根本原因在于中国共产党的先进性 生产工具是衡量生产力发展水平的重要标志 井冈山是1927年的第一个农村根据地，他不是抗日的时候，是国共内战的时候，也可以说是土地革命时期 首次提出官兵平等是在三湾改编。 马窑堡会议确立了抗日民族统一战线方针 中国共产党与各民主党派在《论十大关系》时候提出了长期共存，互相监督，在12大修改为长期共存，互相监督，肝胆相照，荣辱与共。 西柏坡曾是中共中央所在地，党中央和毛主席在此指挥了决定解放战争走向的辽沈、淮海、平津三大战役，召开了具有伟大历史意义的七届二中全会和全国土地会议，解放全中国，故有“新中国从这里走来”、“中国命运定于此村”的美誉。 百团大战并不是中国抗日的第一次最重大的一个胜利 游击战的指导方针是 敌进我退，敌驻我扰，敌疲我打，敌退我追。但辽沈，淮海，平津并不是游击战，他是一个决战 社会主义的根本任务和根本要求是解放生产力，发展生产力。根本方向是消除剥削，消除两极分化。根本目的是不能富裕。 新时代的东西生态文明尊重自然是首要态度 保护自然是重要责任 顺应自然是基本原则 新发展格局 内涵 什么是新发展格局？ 构建国内大循环为主体，国内国际双循环相互促进的新发展格局 关键 经济循环畅通无阻 本质特征 高水平的自立自强 中国式现代化的五个重要特征（未来要实现的方向）人口规模巨大 全体人员共同富裕 物质文明和精神文明相协调 人与自然和谐共生 走和平发展道路 四个伟大19大习大大提出的 伟大梦想（中国梦） 伟大事业（中特事业） 伟大工程（党的建设） 伟大斗争（矛盾） 其中，伟大的工程是主体力量，（火车快不快，全靠车都带，这里的伟大工程是党） 中国共产党近一百年来全心全意为人民服务（宗旨） 实现中华名族伟大复兴（一切奋斗、一切牺牲，归结起来的 主题）（比较大，正确选项可能性大） 实现共建共治共享（社会治理） 中国精神 民族精神 爱国主义（始终把中华名族团结在一起） 时代精神 改革创新（始终鞭策我们改革开发、与时俱进） 民主党派四民二公，三九胃泰 背下来法——保障 党–保证 依法治国–重要保障 从严治党–政治保证 深化改革–动力源泉 建设社会主义现代化国家–战略目标 我国经济从高速增长到高质量发展 建设现代化经济必须重心放到实体经济中来 查缺补漏中国特色社会主义中国特色社会主义是改革开放以来党的全部理论和实践的主题。中国特色社会主义理论体系包括邓三科习。中国特色社会主义，包括中国特色社会主义道路，理论，制度，文化。 一国两制一个中国既是前提又是核心，和平统一是目的。 个人社会国家拥有的个人爱国，敬业，友善。 社会自由，平等，公正，法治。 国家富强，民族文明和谐。","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"mysql","slug":"mysql","date":"2020-03-14T16:00:00.000Z","updated":"2023-05-28T11:01:04.056Z","comments":true,"path":"posts/7f1ae6dh.html","link":"","permalink":"http://example.com/posts/7f1ae6dh.html","excerpt":"","text":"什么是存储过程？用什么来调用？存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 用什么调用？ 可以用一个“execute 存储过程名 参数”命令来调用存储过程。 好处 由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。 完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 1、实体完整性：规定表的每一行在表中是惟一的实体。 2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 使用B树的好处B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。 视图有哪些特点？哪些使用场景？ 什么是视图 是虚拟的表 使用和普通的表一样 mysql5.1后出现的新特性，是通过表动态生成的 特点 临时 可重复用 应用场景 多个地方用到了同样的查询结果 该查询结果比较复杂 好处 简化sql查询，提高开发效率，兼容老的表结构。 索引有哪几种类型？1、 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 2、 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 3、 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。 4、 全文索引：是目 前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。 5、 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行 6、 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并 好处 提高数据的搜索速度 坏处 在我们建立数据库的时候，需要花费的时间去建立和维护索引，而且随着数据量的增加，需要维护它的时间也会增加。在创建索引的时候会占用存储空间。在我们需要修改表中的数据时，索引还需要进行动态的维护，所以对数据库的维护带来了一定的麻烦。 MySQL自增主键用完了怎么办？一般都是int，一般用不完 用完了可以用bigint 可以考虑提前分库分表的。 mysql如何显示前50行？在Mysql中，使用以下代码查询显示前50行： SELECT*FROM LIMIT 0,50; sql执行速度慢怎么办可以加索引 原因 主要原因： sql写的烂 索引失效 关联查询多，比如join这些 加索引为啥快 如果没有索引，需要在所有的数据一点点查，与磁盘i/o多。加上索引，大大减少I/O操作。 二叉树 缺点：有序的时候不行 红黑树 虽然他进行了平衡，但数太多了，高度也很大 InnoDB和MyISAM有什么区别? 建立索引 默认索引是idx_开头 什么时候建立索引 对频繁使用的字段建立索引 索引失效原因 比如上面的name，email做了复合索引，这个是先按照name排序查在按照email查。如果查询语句没有name，只写了whare email = ？，这样就会失效 sql执行顺序 SQL语句中order by和group by一起使用的注意事项 1.order by 的列，必须是出现在group by 子句里的列2.order by 要 放在 group by的后面 join 左连接 两张表的高度要一致，不一致要补null 左边的全部查出来，根据on进行连接，右表没有的补null 右链接 内链接 on是跟的join的条件 1 去除AB公共部分，就是B.key is null 1 全连接 索引 什么是索引 索引是帮助mysql高效的获取数据的数据结构 MySQL中，用的最多的是InnoDB存储引擎，InnoDB中的索引采用B+Tree这种s数据结构 (排好序的快速查找的数据结构) 会影响查找和排序（比如orderby） 一般来说，索引也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上 有哪些索引 单值索引 唯一索引 复合索引 基本语法 哪些适合建立索引 主键自动建立唯一索引 频繁查询 查询中排序的字段，索引可以大大提升速度 不适合索引 where用不到的字段 频繁更新的字段（因为更新也要更新索引） 表记录很少就算了 数据重复率高，又或者类别很少（比如说ture，false）就不建立了 事务四大特性 并发情况下引发的问题 脏读：A事务还没提交，B事务就读到了A事务的结果。（破坏隔离性） 例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（破坏一致性，update，delete）例如：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（破坏一致性，insert）例如：目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 解决 四种隔离级别，隔离程度不同，副作用也不同 读未提交（Read uncommitted）： ​ 这种事务隔离级别下，select语句不加锁。 ​ 此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。 读已提交（Read committed）： ​ 可避免 脏读 的发生。 ​ 在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。 3 .可重复读（Repeatable read）： ​ MySql默认隔离级别。 ​ 可避免 脏读 、不可重复读 的发生。 串行化（Serializable ）： ​ 可避免 脏读、不可重复读、幻读 的发生。 实现（innoDB） 隔离级别就是依赖锁和MVCC实现的。 锁 InnoDB中的行锁 ① 记录锁（Record Locks） 锁住某一条记录 ② 间隙锁（Gap Locks） 比如幻读，一开始没有数据，没办法加记录锁，可以加间隙锁 (3, 8)这个区间被锁 ③ 临键锁（Next-Key Locks） 是上两个锁的组合，间隙锁是开区间（3，8），如果我们也想锁住8，那么用临键锁（3，8] innodb默认的锁就是Next-Key locks。 ④ 插入意向锁（Insert Intention Locks） 为什么索引用b+不用bb+数非叶子叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。IO次数更少 b+高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5， 为什么MySQL 没有用hash作为索引的数据结构呢？1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。 2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。 数据库常用得命令 超键、候选键、主键、外键超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 候选键(candidate key):不含有多余属性的超键称为候选键 主键(primary key):用户选作元组标识的一个候选键程序主键 外键(foreign key)如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。 结合实例的具体解释： 假设有如下两个表： 学生（学号，姓名，性别，身份证号，教师编号） 教师（教师编号，姓名，工资） 超键： 由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。 候选键： 候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。 主键： 主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。 外键： 外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。 sql五种约束 主键约束：不重复、唯一、非空 设置主键的列不允许为空， 唯一约束用来保护表中某列数据不允许重复， char与varchar的区别 char的长度不可变，而varchar的长度可变 这就表示，存储字符串’abc’，使用char(10)，表示存储的字符将占10个字节（包括7个空字符） 使用varchar(10),则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储 char类型的效率比varchar的效率稍高 varchar比char节省空间，但是在效率上比char稍差些。既要获得效率即必须牺牲一点空间，这就是设计上的””以空间换时间”” 三范式 一范式 不重复，原子 数据冗余 插入异常 比如说你新建一个系，这个时候没有学生就插入不了 二范数 消除部分依赖， 完全依赖，通过一个候选码可以确定其他码 比如id可以确定姓名等但是id和课名才能确定分数 分数完全依赖于（id和课程），可以说（id和课程）就是候选码，但是name只需要id就可以，所以说name部分依赖于（id和课程）消除 解决了1范式的数据冗余，修改异常 3范式 消除传递依赖 插入和删除没问题 事务原子性 undo log 持久性 redo log mysql数据是写入磁盘的，但写入磁盘比较慢，所以出现了一个缓存buffer，再写的时候是先写入buffer，在慢慢同步到磁盘。找的时候也如此。如果这时候宕机，buffer嗝屁，不能持久性，这时候有个日志redo log，在放buffer时候也在redo log记录一下，它记录了修改，根据它回复 隔离性 写-写：锁 写-读：mvcc mvcc主要是处理读请求，是快照读而不是当前读 目的是读写得时候不用去竞争锁，提高性能 读已提交和可重复读的快照读都是基于mvcc实现的 基于三个实现 undo log 、版本连、ReadView 如图，把di为1的一直修改，有事务id，这个是自增的，然后回滚指针，指向之前修改的 undo log记录之前修改的 readview啥用 你看版本连里面这么多版本，不知道取哪一个啊 其实readview在代码里就是一个对象 m_ids 表示活跃的，啥是活跃的，就是没有commit creator_trx_id 谁生成了这个readview 例子 读已提交RC：这个级别下每次select都会产生一个readview。 可重复读RR：这个级别下readview是以事务为单位，第一个select产生一个readview，后面不产生了 redolog保证持久性 当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。 为啥不直接写入磁盘 写入redolog快，写入的方式是在文件后面追加，不需要找位置。但是写入磁盘需要找的写入的具体位置，这个比较慢 redolog写满怎么办 它是写满了就从头开始写，像一个环状 redolog和binlog区别 主从复制springboot怎么使用 springboot是自动装配的，你好几个数据库，它怎么知道链接哪一个 在aplication.apropeity里分别定义主从的密码，用户名，链接这些 然后这里仿照springboot配置文件自己定义了一个配置类，取出aprlicaotion中的文件 配置数据源 设置链接工厂这些 设置默认值defult CREATE TABLE students( student_id INT DEFAULT 100, name VARCHAR(255) NOT NULL, age INT DEFAULT 15 ); 分布式IDuuid和雪花（snowflake） 区别 uuid是无序的不建议使用（因为无序在索引使用的时候影响较大） 雪花算法 它有64个bit位 配置也是通过shardingspere ，在properties中配置 非聚集索引回表一般普通索引就是非聚集索引，需要回表。聚集索引一般为主键索引，根据这个再进行回表。 为啥不都用聚集索引 没必要，浪费空间，因为每一个创建一个索引，innodb都会创建一个索引树，如果叶子节点都放数据就会浪费空间 具体参考 https://blog.csdn.net/weixin_38192427/article/details/111872683 不同类别索引创建 主键索引 ALTER TABLE tbl_name ADD PRIMARY KEY (col_list); // 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 唯一索引 ALTER TABLE tbl_name ADD UNIQUE index_name (col_list); // 这条语句创建索引的值必须是唯一的，索引值可以为null（null可重复出现） 普通索引 ALTER TABLE tbl_name ADD INDEX index_name (col_list); // 添加普通索引，索引值可出现多次。 删除 ALTER TABLE tbl_name DROP INDEX index_name； 索引失效原因https://blog.csdn.net/qq_43460095/article/details/125538837 覆盖索引就是联合索引，在普通索引查询后，需要进行回表操作，但如果查的多，一直回表比较费时。 这时候可以采用覆盖索引进行解决 比如这里增加name、和age复合索引，这样在查name和age就不需要回表，但要注意索引失效 参考链接 https://www.bilibili.com/video/BV1cv411P7Wb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc https://blog.csdn.net/Aplumage/article/details/117015144 索引下推Mysql5.6更新后一个重要特性，被问到要答出来 参考 https://www.bilibili.com/video/BV1ks4y157CS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"反射","slug":"反射","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:31:23.836Z","comments":true,"path":"posts/7f1ae6fg.html","link":"","permalink":"http://example.com/posts/7f1ae6fg.html","excerpt":"","text":"动态语言和静态语言动态语言是在运行的时候可以改变其结构的语言，比如说c#、javascript、PHP、Python等 静态比如说C、JAVA、C++ java不是动态语言，但java可以有一定的动态性，可以通过反射机制获得类似动态语言的特性，让编程更加灵活。 反射java reflection 反射获得类的class对象三种方式若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 Class clazz = Person.class; 已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class clazz = person.getClass(); 已知一个类的全类名，且该类在路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException static Class&lt;?&gt; aclass = Class.forName(\"绝对路径\"); 内置基本类型可以通过类名.Type(例 Integer、Long) 还可以利用ClassLoader 哪些类型有可以有class对象？ Object //类 Comparable //接口 String[] //一维数组 int[] [] // 二维数组 Override //注解 ElementType //枚举 Integer //基本数据类型 void //void Class //class 快捷键alt可以竖着复制多行，方便快捷 要遍历的时候直接（遍历对象）.for 类加载 什么时候类会初始化 执行过程 通过反射能够获取到什么 package com.text; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.concurrent.atomic.AtomicInteger; public class test32 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //获取Class类 Class&lt;?&gt; c1 = Class.forName(\"com.text.Animal\"); //获取类名 System.out.println(\"--------------------获取类名--------------------\"); System.out.println(\"类名\" + c1.getSimpleName()); System.out.println(\"包名+类名:\" + c1.getName());//包名+类名 //获取类的属性 System.out.println(\"--------------------获取类的属性--------------------\"); Field[] fields = c1.getFields();//只能获取公共的字段表示属性 Field[] declaredFields = c1.getDeclaredFields();//获取所以的字段属性(包括私有的等等) for (Field declaredField : declaredFields) { System.out.println(declaredField); } //获取指定属性的值 System.out.println(\"--------------------获取指定属性的值--------------------\"); Field name = c1.getDeclaredField(\"name\"); System.out.println(name); //获取方法 System.out.println(\"--------------------获取类的方法--------------------\"); Method[] declaredMethods = c1.getDeclaredMethods();//获得本类全部方法(无关修饰符) Method[] methods = c1.getMethods(); //获得本类及父类的全部public方法 for (Method method : declaredMethods) { System.out.println(method); } //获取指定方法 System.out.println(\"--------------------获取指定方法--------------------\"); Method getNames = c1.getMethod(\"getName\", null); System.out.println(getNames); //获取Class全部的公有构造方法 System.out.println(\"---------------------获取所有公共的构造函数---------------------\"); Constructor&lt;?&gt;[] constructors = c1.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) { System.out.println(constructor); } //获取Class全部的构造方法 System.out.println(\"---------------------获取所有全部的构造函数(包括：公共的,默认的,受保护的,私有的)---------------------\"); Constructor&lt;?&gt;[] declaredConstructors = c1.getDeclaredConstructors(); for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) { System.out.println(declaredConstructor); } //获取公共构造方法v System.out.println(\"---------------------获取公共无参构造方法---------------------\"); Constructor&lt;?&gt; constructor = c1.getConstructor(null);//这里必须是一个参数类型的class,默认为null System.out.println(constructor); Object o = constructor.newInstance();//调用构造方法 // System.out.println(\"o:\"+o.toString()); // User user=(User)o; // user.user2(); //获取私有构造放 System.out.println(\"---------------------获取私有构造方法---------------------\"); Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class); System.out.println(constructor); declaredConstructor.setAccessible(true); Object test = declaredConstructor.newInstance(123); System.out.println(test); //获取指定构造方法 System.out.println(\"---------------------获取指定构造方法---------------------\"); Constructor&lt;?&gt; declaredConstructor1 = c1.getDeclaredConstructor(int.class, String.class); System.out.println(declaredConstructor1); } } class Animal { private int age; private String name; public Animal() { } //这个是测试 private Animal(int a){ } private void test() { System.out.println(\"私有方法\"); } public Animal(int age, String name) { this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Animal{\" + \"age=\" + age + \", name='\" + name + '\\'' + '}'; } } class Dog extends Animal { private String name; public Dog() { this.setName(\"小狗\"); this.setAge((int) (Math.random() * 7)); } } class Cat extends Animal { public Cat() { this.setName(\"猫\"); this.setAge((int) (Math.random() * 7)); } } 反射创建对象 package com.text; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; public class test34 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { //1.创建class对象 Class&lt;?&gt; c1 = Class.forName(\"com.text.personnel\"); //2.获取构造方法 Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(); //3.通过构造方法new类(这里知道是什么类就可以强行转换了) personnel o = (personnel)(declaredConstructor.newInstance()); //4.这里获取字段(也可以获取方法全看需要) Field id = c1.getDeclaredField(\"id\"); //5.因为是私有的属性所以关闭安全检测 id.setAccessible(true); //6.设置属性，参数是(设置属性的对象,属性值) id.set(o,\"1234\"); //7.查看调用方法查看是否设置成功 System.out.println(o.getId()); } } //账号类 class personnel{ private String id; private String password; public String getId() { return id; } public String getPassword() { return password; } }","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"哲学","slug":"哲学","date":"2020-03-14T16:00:00.000Z","updated":"2023-07-09T23:21:48.187Z","comments":true,"path":"posts/7a46f35t.html","link":"","permalink":"http://example.com/posts/7a46f35t.html","excerpt":"","text":"哲学概述哲学研究世界，主要分为自然界和人类社会，人类社会主要有认识世界（停留在思考）和改变世界，认识世界又分为世界观和方法论 世界观 主要解决世界是什么的问题（从哪里来，水来还是其他？上帝创造？） 方法论 怎么做的问题，用什么样的方式去处理问题 每个人都有自己的世界观和方法论，但一门学科需要统一，这时就出现了哲学，它是系统化的世界观和方法论。但不能说它是科学的（因为哲学很多，在我们国家，只有马克思哲学才称为科学的） 世界观和方法论关系 世界观决定方法论，方法论体现世界观 一个人对世界的看法就决定了它做事情的基本方法，通过这个人解决问题的方法就可以体现这个人的世界观。比如一个人世界观认为世界是上帝创建了，人不能改变世界，听天由命，这样在做事的时候就会摆烂。反过来老摆烂，可以体现出世界观。 哲学是科学的？ 不对，只有马克思主义哲学才是科学的 哲学与具体科学的关系一般与特别，共性和特性的关系 比如物理学就是研究物理的，社会学就是研究社会的。但哲学是它们的概括，都有涉及到，范围广，研究是是共性 联系 哲学是以具体科学得成果为基础。比较好理解，因为哲学是共性，抽取其他自然科学的 哲学又为具体科学提供了引导（一般性的指导）（比如说你认为世界是物质的，这样就不用烧香拜佛了） 哲学的基本问题思想和存在（精神与物质） 基本问题是恩格斯提出的 第一性是先有谁的问题，先有物，就是唯物。 同一性就是思维能不能认识存在。比如你面前有个电脑，你看到它能不能知道它的用途等信息，能就是可知，反之不可知论 唯物主义古代朴素 注意 出现荀子、范镇……，八成是古朴 缺点 太直观了，靠感觉，靠猜测。觉得啥重要啥就是本源 形而上学认为是由原子和分子组成 缺点 机械性：认为人和机器一样，也是由零部件组成 形而上学：看到一课树，说这是树，看到一堆树，还说是树，明显是森林。这是看待问题片面（盲人摸象）。静止的眼光看问题（刻舟求剑） 老马是用联系、发展、前面的眼光看问题。 不彻底性：在自然领域是唯物的（比如问先见山后了解还是先了解后见山，他回答是先见山后了解（这里是唯物没问题）），但在社会领域不行（比如说，人类历史是谁创建的，形而上学认为是伟人、英雄或者神。老马认为是人民群众） 唯心主义主观唯心 与人有关 客观唯心（比如老子的道） 秒杀 马克思主义 组成 产生 其中，德国古典哲学是马哲的直接来源 黑格尔提供了辩证法（黑格尔是唯心主义） 费尔巴哈提出了唯物论 科学依据 进化论是达尔文提出 基本特征 马克思墓在伦敦 老马为啥科学，因为他与时俱进 一元论 世界本原有几个，有一个就是一元论，两个就是二元论 唯物论讲的物质是什么 物质物质的唯一特性：客观实在性（不以人的意志而转移） 物质是列宁提出的 物质怎样存在 物质的存在形式和根本属性是运动（有变化就是运动） 物质运动的存在形式是时间和空间 社会运动最复杂 物质和运动关系 世界上所有的物质都是运动的 离开运动谈物质，形而上学（刻舟求剑） 反过来，唯心（比如风吹的帆动，老和尚认为不是风动，也不是帆动，是心在动） 静止 动是绝对的，无条件的。静是相对的，有条件的。 静中有动，动中有静 否认运动，形而上学 否认静止，诡辩论（借钱不还，方生方死，太阳永远不会在正中央那一刻） 意识 产生条件 无生命物质比如化学反应 只有人有意识，要有人脑，但狼人不是，它虽然有人脑，但没有社会活动 人脑是产生意识的器官，但不是意识的源泉，客观世界才是源泉。（大脑不是产生意识的器官） 人的意识可以能动的认识世界（鸟–飞机，鱼–潜艇） 本质 是人脑对客观存在的主观映像 内容是客观的，形式是主观的 物质与意识物质决定意识 巧妇难为无米之炊（体现了米的重要性） 物质第一性，客观规律第一性 方法论 主观符合客观一般考政策，比如国家推选垃圾分类，先看看实用不 辩证法讲的物质是怎样存在的 两大特征普遍联系和永恒发展 联系 运气是违背联系客观性的，封建迷信也是，属相不和、喜鹊报喜，乌鸦报丧、666、888 普遍性：冒起不沾边的也有联系。比如蝴蝶效应、6度空间、唇亡齿寒、城门失火，殃及池鱼、连锁反应 整体和部分 发展 发展是不能只看眼前，要看的远 三大规律 质量互变 要把握时机 拔苗助长，学习也得劳逸结合 对立统一 相互依存，比如你的丑衬托出我的美，丑美依存 相互转化，比如整容了，从丑变美，转换（考试重点，反义词相互转换） 事物发展的源泉是内部矛盾 相互转化的词 内外因 创新属于内因 外因是条件，外因通过内因起作用 矛盾特征 主要矛盾和次要矛盾 多个矛盾，怎么做 主要方面与次要方面 单个矛盾，怎么看 否定之否定扬弃了两次 记住，否定之否定最后的落脚点是好的，经历了肯定、否定、否定之否定 五队范畴 讲课准备的充分，滔滔不绝。反之，磕磕绊绊（内容决定形式） 电闪雷鸣不是，四季交替也不是 吃的多导致肥胖是 可能性，比如说考试，每个人都可能考上，但现实惨目忍睹。 守株待兔 认识论我们能不能认识客观存在这个物质 实践 蜜蜂筑巢不是，必须是人 生产实践是最基本的，也是其他实践的基础和前提（民以食为天，填饱肚子再说其他的） 科学实验起到杠杆作用 认识 感性认识 感觉：比如你买衣服，看到后感觉如何 知觉：摸摸，看看料子怎么样，穿上试试 表象：比如一说香蕉，就能回忆起来长啥样 理性认识 感性和理性的关系 感性和理性相互包含、相互渗透。是同时存在的（比如，你看你就是卷王。这里看是感性，卷王被定义了，是理性） 第二次更加重要，因为理论是指导实践的 第二次飞跃的桥梁是表象（透过现象看本质） 实践和认识的关系 真理 内容是客观，形式是主观的 比如你说三角形内角和不是180，这是谬论。但在球面上就符合了，变成了真理，可以相互转化 认识的本质是主题对客体的反映（不是实践，实践决定认识） 历史唯物主义人民群众创造历史，不是杰出人物 社会存在 低碳出行（这就是社会存在决定社会意识，先是车太多了，才弄这个）计划生育也是 生产力是人类改造自然行不行，是人和自然的关系，是衡量社会进步的尺度 生产工具可以看出发展好不好 生产关系是人与人之间的，比如你卖货，我买货 所有制是基础，我国的所有制是公有制 要适应，先进生产关系促进生产力这是错的，适应才行 经济基础：我们国家公有制为主题，多种所有制总和。这个总的就是经济基础 关系 人民群众 所有人都是历史主题，是错误的。还有敌人呢 人民群众创造历史不能随心所欲，受制约的 补充现象和本质现象是外表直接看出来的，比如说水往低处流等 本质是添加上人的思维，深刻的认识 真象和假象 现象的两种表现形式，真象就是真实的（比如水往低处流），假象是歪曲的（比如月亮有光） 真象和假象都是现象，都可以反映事物的本质 假象和错觉 不一样，假象是客观存在的（你看到月亮亮的），错觉是个人的感觉（比如人家看了你一眼，你就觉得人家喜欢你） 马克思主义基本原则价值原则（为全世界大多数人谋利） 认识原则（实事求是） 理论原则（实践） 整体和部分整体居于主导低位统帅部分（不谋全局、不足某一略） 关键部分对整体起决定性作用（一步错，满盘皆是） 整体是各个部分的有机结合，整体具有部分没有的新功能（钟表） 注意 整体功能大于部分之和（这说法是错的，大于和不大于看具体情况，有序的大于，无序的小于） 事物发展事物发展的道路是前进和曲折性的统一 事物发展的总趋势是前进的","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"算法思想","slug":"算法","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:41:17.394Z","comments":true,"path":"posts/7f1ae6sf.html","link":"","permalink":"http://example.com/posts/7f1ae6sf.html","excerpt":"","text":"搜索二叉树遍历数组重建树 最后得节点是整棵树得头，然后想着左右树建立出来，搜索左边小右边大无重复值 （进阶：不需要一直遍历，可以二分） （无序怎么二分？这个我们可以分后与最后一个节点比较，看他大概在哪个区间。毕竟有这样一个简单得规律，后面一大堆比前面一大堆大） 左小右大，直接与根节点（最后一个节点）比较就行了 怎么确立左右树呢，一样得道理 复杂的（遍历得最差是o（n^2）（什么时候最差，单支，每一层都遍历，共n层），二分得最差是o(nlogn)） 前缀树 代码里每个节点有pass代表经过几次，还有end代表是不是结尾。 查询的时候只需要从上往下查，怎么加入的就怎么查，看end有没有 根节点的pass代表着一共多少字符串，根节点end代表空串数量 package class07; public class Code01_TrieTree { public static class TrieNode { public int path; public int end; public TrieNode[] nexts;//这个是用数组代表路，如果字符种类特别多，那可以用hash表 public TrieNode() { path = 0; end = 0; nexts = new TrieNode[26]; } } public static class Trie { private TrieNode root; public Trie() { root = new TrieNode(); } //插入 public void insert(String word) { if (word == null) { return; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { node.nexts[index] = new TrieNode(); } node = node.nexts[index]; node.path++; } node.end++; } public void delete(String word) { if (search(word) != 0) { char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (--node.nexts[index].path == 0) { node.nexts[index] = null; return; } node = node.nexts[index]; } node.end--; } } //查找加入的次数 public int search(String word) { if (word == null) { return 0; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { return 0; } node = node.nexts[index]; } return node.end; } //查有多少字符串以***作为前缀 public int prefixNumber(String pre) { if (pre == null) { return 0; } char[] chs = pre.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { return 0; } node = node.nexts[index]; } return node.path; } } public static void main(String[] args) { Trie trie = new Trie(); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuo\"); trie.insert(\"zuo\"); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuoa\"); trie.insert(\"zuoac\"); trie.insert(\"zuoab\"); trie.insert(\"zuoad\"); trie.delete(\"zuoa\"); System.out.println(trie.search(\"zuoa\")); System.out.println(trie.prefixNumber(\"zuo\")); } } 贪心在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到 一个答案的算法，叫作贪心算法。 也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解 例题1一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数 组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。 返回这个最多的宣讲场次 思考 我们先想按时间最早分配，显然，如果有一个项目最早开始，但贯穿一天，这种策略不行。然后考虑按时间最短分配，经过思考，也不行，比如下面中间的最短，但是他的开始时间和结束时间卡住了其他 最后我们按照结束时间最早分配，每次把不符合的给删除（因为我们的目的就是数量最多） 代码 package class07; import java.util.Arrays; import java.util.Comparator; public class Code04_BestArrange { public static class Program { public int start; public int end; public Program(int start, int end) { this.start = start; this.end = end; } } public static class ProgramComparator implements Comparator&lt;Program&gt; { @Override public int compare(Program o1, Program o2) { return o1.end - o2.end; } } public static int bestArrange(Program[] programs, int start) { Arrays.sort(programs, new ProgramComparator()); int result = 0; for (int i = 0; i &lt; programs.length; i++) { if (start &lt;= programs[i].start) { result++; start = programs[i].end; } } return result; } public static void main(String[] args) { } } 例题2给一个字符串数组，然后进行拼接成一个，要求拼接后的字典序最小 思考 每次都把最小字典序的字符串放前面，经过举例这个不对，例如。b的字典序小于ba，如果谁小谁在前，那么是bba，但是很明显bab更小。 代码 package class07; import java.util.Arrays; import java.util.Comparator; public class Code02_LowestLexicography { // 定义一个比较器，比较策略 public static class MyComparator implements Comparator&lt;String&gt; { @Override public int compare(String a, String b) { return (a + b).compareTo(b + a); } } public static String lowestString(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } //怎么比较排序，自己定义下 Arrays.sort(strs, new MyComparator()); String res = \"\"; for (int i = 0; i &lt; strs.length; i++) { res += strs[i]; } return res; } public static void main(String[] args) { String[] strs1 = { \"jibw\", \"ji\", \"jp\", \"bw\", \"jibw\" }; System.out.println(lowestString(strs1)); String[] strs2 = { \"ba\", \"b\" }; System.out.println(lowestString(strs2)); } } 例3 哈夫曼树解决 例题3 给一堆项目，有他的花费和利润，然后你有启动资金去投资它，怎么获利最大 解题思路： 如上面所示，先建立一个小根堆，这个小根堆按照所需投资钱数排，它的目的是根据我们的启动资金找出可以投资哪些项目。然后再建立一个大根堆，根据小根堆筛选出来的放进大根堆，大根堆按照利润排序，毕竟在钱够的情况下做利润大的，得到利润的钱后，在去小根堆瞅瞅哪些现在可以做了，筛选出来放大根堆，以此类推 package class07; import java.util.Comparator; import java.util.PriorityQueue; public class Code05_IPO { public static class Node { public int p; public int c; public Node(int p, int c) { this.p = p; this.c = c; } } //小根堆比较器 public static class MinCostComparator implements Comparator&lt;Node&gt; { @Override public int compare(Node o1, Node o2) { return o1.c - o2.c; } } //大根堆比较器 public static class MaxProfitComparator implements Comparator&lt;Node&gt; { @Override public int compare(Node o1, Node o2) { return o2.p - o1.p; } } //w是启动资金，k是最多处理几个项目 public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) { Node[] nodes = new Node[Profits.length]; for (int i = 0; i &lt; Profits.length; i++) { nodes[i] = new Node(Profits[i], Capital[i]); } //定义堆，通过比较器来看大小 PriorityQueue&lt;Node&gt; minCostQ = new PriorityQueue&lt;&gt;(new MinCostComparator()); PriorityQueue&lt;Node&gt; maxProfitQ = new PriorityQueue&lt;&gt;(new MaxProfitComparator()); //所有节点放在小根堆里 for (int i = 0; i &lt; nodes.length; i++) { minCostQ.add(nodes[i]); } for (int i = 0; i &lt; k; i++) { while (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) { maxProfitQ.add(minCostQ.poll()); } //剩下的都做不了了，提前 if (maxProfitQ.isEmpty()) { return W; } W += maxProfitQ.poll().p; } return W; } } 动态规划 啥是动态规划 空间换时间 如何你发现计算中有重复的部分，就把重复的给记录下来，下次不用重复算","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"集合常用api","slug":"集合常用api","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:39:05.068Z","comments":true,"path":"posts/7f1ae6ui.html","link":"","permalink":"http://example.com/posts/7f1ae6ui.html","excerpt":"","text":"String获取功能1）length():获取字符串的长度，其实也就是字符个数2）charAt(int index):获取指定索引处的字符 3）indexOf(String str):获取str在字符串对象中第一次出现的索引4）substring(int start):从start开始截取字符串5）String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end 判断功能1）equals(Object obj):比较字符串的内容是否相同 2）isEmpty()：判断指定字符串是否为空 3）compareTo(String anotherString)：比较字符串的大小，前者大返回整数，后者大返回负数，相等返回0 转换方法1）toCharArray():把字符串转换为字符数组 2）toLowerCase():把字符串转换为小写字符串 3）toUpperCase():把字符串转换为大写字符串 其他方法1）replace(char oldChar, char newChar)：将指定字符替换成另一个指定的字符 2）replaceAll(String regex,String replasement)：用新的内容替换全部旧内容 replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\\d”, “*”)把个字符串所有的数字字符都换成星号; String src = new String(\"ab43a2c43d\"); System.out.println(src.replace(\"3\",\"f\"));=&gt;ab4f2c4fd. System.out.println(src.replace('3','f'));=&gt;ab4f2c4fd. System.out.println(src.replaceAll(\"\\\\d\",\"f\"));=&gt;abffafcffd. 3）replaceFirst(String regex,String replacement)：替换首个满足条件的内容 4）contains(CharSequence s)：查看字符串中是都含有指定字符 hashmap1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。 3：remove方法：remove(key)，主要用来删除map中对应的key及其value值。 4：clear方法，用法：clear()，会清空map中的数据。 5：containsKey(key)，判断map集合中是否包含某个key。 6：containsKey(value)，判断map集合中是否包含某个value。 7：entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。 8：keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。 TreeMap构造方法 TreeMap()：创建一个空TreeMap，keys按照自然排序 TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(); TreeMap(Comparator comparator)：创建一个空TreeMap，按照指定的comparator排序 TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(Comparator.reverseOrder()); map.put(3, \"val\"); map.put(2, \"val\"); map.put(1, \"val\"); map.put(5, \"val\"); map.put(4, \"val\"); System.out.println(map); // {5=val, 4=val, 3=val, 2=val, 1=val} TreeMap(Map m)：由给定的map创建一个TreeMap，keys按照自然排序 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"val\"); ... TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(map); TreeMap(SortedMap m)：由给定的有序map创建TreeMap，keys按照原顺序排序 常用方法V put(K key, V value)：将指定映射放入该TreeMap中 void clear()：清空TreeMap中的所有元素 V remove(Object key)：从TreeMap中移除指定key对应的映射 V replace(K key, V value)：替换指定key对应的value值 boolean containsKey(Object key)：判断该TreeMap中是否包含指定key的映射 boolean containsValue(Object value)：判断该TreeMap中是否包含有关指定value的映射 Set&lt;Map&lt;K, V&gt;&gt; entrySet()：返回由该TreeMap中的所有映射组成的Set对象 int size()：返回该TreepMap中包含的映射的数量 遍历方式 for循环 for (Map.Entry entry : treeMap.entrySet()) { System.out.println(entry); } 迭代器循环 Iterator iterator = treeMap.entrySet().iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 自定义比较器Map&lt;Integer, Object&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); map.put(5, new Object()); map.put(10, new Object()); map.put(8, new Object()); map.put(12, new Object()); System.out.println(map); ArrayList1、add(Object element) 方法add(Object element) 方法用于向ArrayList集合中的添加元素。 2、size() 方法size()方法用于返回ArrayList集合中元素个数 3、get(int index) 方法get(int index)方法用于返回集合中对应位置的元素 4、add(int index, Object element) 方法add(int index, Object element) 方法用于在集合指定位置添加元素，原集合中从指定位置开始的元素全部后置 5、set(int i, Object element) 方法set(int i, Object element) 方法用于将索引i位置元素替换为元素element并返回被替换的元素 6、clear() 方法clear() 方法用于清空集合中元素 7、isEmpty() 方法isEmpty() 方法用于判断集合容器是否为空，如果为空，则返回true，否则返回false。 8、iterator()iterator（）不是一个方法而是一个用于返回按适当顺序在列表的元素上进行迭代的迭代器可以用它遍历集合元素 9、contains(Object o) 方法contains(Object o) 方法用以判断集合容器中是否含有指定元素，有返回值，且为boolean型。 10、remove(int index) 方法remove（int index）方法用于移除列表中指定位置的元素，并返回被删元素 11、remove(Object o) 方法remove(Object o) 方法用于移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。 转字符串数组方法一、 String[] arr = new String[list.size]; list.toArray(arr);//此时arr就有了list中的值了` 方法二、 String[] arr = (String[])list.toArray(new String[0]);` 构造方法List&lt;String&gt; list3 = new ArrayList&lt;&gt;(list2); List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); //构造一个具有指定初始容量的空列表。 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(6); StringBufferStringBuffer对象的初始化StringBuffer s = new StringBuffer(); StringBuffer s = new StringBuffer(“abc”); StringBuffer对象和String对象之间的互转String s = “abc”; StringBuffer sb1 = new StringBuffer(“123”); StringBuffer sb2 = new StringBuffer(s); //String转换为StringBuffer String s1 = sb1.toString(); //StringBuffer转换为String 常用方法1、append方法StringBuffer sb = new StringBuffer(); String user = “test”; String pwd = “123”; sb.append(“select * from userInfo where username=“) .append(user) .append(“ and pwd=”) .append(pwd); 这样对象sb的值就是字符串“select * from userInfo where username=test and pwd=123” 2、deleteCharAt方法该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字 StringBuffer sb = new StringBuffer(“Test”); sb. deleteCharAt(1); 该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变为”Tst” 3、delete方法public StringBuffer delete(int start,int end) StringBuffer sb = new StringBuffer(“TestString”); sb. delete (1,4); 4、insert方法public StringBuffer insert(int offset, boolean b) StringBuffer sb = new StringBuffer(“TestString”); sb.insert(4,false); 该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"秋招","slug":"面","date":"2020-03-14T16:00:00.000Z","updated":"2023-06-04T03:43:11.542Z","comments":true,"path":"posts/7f1ae999.html","link":"","permalink":"http://example.com/posts/7f1ae999.html","excerpt":"","text":"秒杀测试jmeter 请求组 http请求 结果在监听器显示 redis引入redis setIfAbsent 和 setnxsetIfAbsent 是java中的方法setnx 是 redis命令中的方法 BoundValueOperations boundValueOperations = this.redisTemplate.boundValueOps(redisKey); flag = boundValueOperations.setIfAbsent(value); // flag 表示的是否set boundValueOperations.expire(seconds, TimeUnit.SECONDS); if(!flag){ // 重复 repeatSerial.add(serialNo); continue; }else{// 没有重复 norepeatSerial.add(serialNo); } 问题 b线程释放a线程的锁 可以在value随机值，然后删的时候判断一下还是原来的随机值吗，但是这个是一个过程，先查是不是原来的，再删，这不是一个原子操作。用lua脚本、 如何用lua 可以在服务器写好，然后调用，优点是方便，但是修改了或者调用有资源消耗了 在java代码里直接写麻烦 java代码里写 先在resources中创建一个lock.lua（要和application.yml同级目录） 在测试 threadlocal和synchronized区别 threadlocal原理 spring bean生命周期1.创建前准备，比如调用工厂的后置处理器2.对象实例化，根据bean定义，找到类信息，使用反射创建对象（默认用无参构造，如果没有无参(有一个有参，则用有参；如果有多个有参，报错)（有参参数是在spring容器里面找，先bytype后byname）） 3.对象属性装填，装填成员变量，如果成员变量有其他bean，则加载其他bean（比如autoware resource这些）4.执行初始化，某些对象可能有初始化方法，在此时调用 5.销毁 首先初始化，因为spring容器中都是存放的一个个对象。这个初始化是用反射创建，默认使用无参构造，（如果没有看上面）。然后对对象进行属性填充（依赖注入），比如autowire、resource等。然后某些对象可能有初始化方法，比如实现initiallizingbean方法，实现afterproperitiesset进行初始化。然后判断是否存在aop切入点，如果有，则创建aop代理类，放进spring容器里的也是aop代理类。最后销毁。 单例bean和单例模式不是一回事 spring事务加这样一个注解 数据库表设计规范 字段 加注释 3范式 建议有创建时间和修改时间 固定的用char 线程同步的四种方式一，什么是线程同步和互斥 同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。 解决 方法一：使用synchronized关键字 方法二：wait和notify 线程间通信的几种实现方式方式一：使用 volatile 关键字 方式二：使用Object类的wait() 和 notify() 方法 Session的执行流程浏览器发起一个请求到服务器，服务器先检查是否携带了一个叫做JSEESIONID的Cookie。 如果有携带，会将此cookie值取出来（比如abc），然后从服务器的session池中找到ID为abc的session返回给调用者。如果没有携带JSESSIONID 这个Cookie，服务器就会自动创建一个session对象并且生成一个随机字符串（abc）作为此sessionID保存到session池中，在服务器为客户端响应时会自动创建一个键为“JSESSIONID”，值为“abc”的cookie对象让浏览器存储起来，以便下次访问的时候带着 怎么看走没走索引 解释Explain得到的结果 type 反应查询语句的性能我们主需要注意一个最重要的的 type 的信息很明显地体现出是否用到了索引： type 结果值从好到坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到 range 级别，最好能达到 ref 级别，否则就可能出现性能问题。 解析 反映用什么样的方式查询数据的 possible_keys: SQL查询时用到的索引。可以看到，没加索引时，possible_keys 的值为 NULL，加了索引后的值为 address，即用到了索引address(索引默认为(column_list)中的第一个列的名字). key 显示SQL实际决定查询结果使用的键(索引)。如果没有使用索引，值为NULL可以看到，没加索引时，key 的值为 NULL，加了索引后的值为 address，即决定查询结果用到了索引address rows 显示MySQL认为它执行查询时必须检查的行数可以看到，没加索引时，rows 的值为17，即数据表student中所有数据，说明没加索引时的SQL查询是全表扫描； 加了索引后，rows 的值为6，数据库表中address以“北京市”开头的一共也就6条，SQL在执行查询操作时，一共也检查了6行，不必进行全表扫描查询，可以很容易得出结论：加索引的SQL查询性能远高于不加索引的情况。 5）extra 模糊查询不走怎么解决 通过业务手段避免，举个实际栗子，博主之前做了一个汽车仓储项目，需求要求汽车表查询时候，车架号要有模糊查询操作，但是实际上对于车架号这个东西有个特殊的业务属性，就是车架号的后六位，基本可以在全省锁定到某一台车，全国不会超过三台车。所以业务人员在实际使用系统的时候，也只是输入后六位进行模糊查询，因此，在表设计的时候就将车架号字段冗余了一个字段，用于存储倒序的车架号，在进行模糊查询的时候，使用这个倒序字段进行右模糊查询，从而达到走索引的目的。有些时候，通过业务手段是可以达到一个优化要求的。 内连接 解决地址https://www.cnblogs.com/Marydon20170307/p/15866354.html synchronizedhttps://blog.csdn.net/m0_53474063/article/details/112389756 循环依赖 （属性相互赋值） 自己写出来的比较好解决 ioc的话比较难解决，主要有两个问题 从单例池中，属性注入b，由于b没有，去创建b，创建的过程有需要注入a。此时a没有，死循环了 解决方法 半成品池 a一旦被实例化，就把他放在半成品池中（二级缓存解决，为啥用三级缓存，因为解决不了aop代理） aop代理问题 等于说有一个前置方法，在调用的时候提前创建这个代理类 负载均衡1、轮询法 轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。 2、随机法 随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子[5]。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。 3、最小连接法 最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。 Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用 Ribbon默认负载轮询算法原理默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。 注解LoadBalancer 查看内存使用情况1 查看系统内存freenetstat -anp |grep 端口号 top 查看进程 cup使用情况 内存的使用情况 ** Load Average**load average: 1.79, 2.10, 2.28 系统负载，三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。如1.79，表示最近一分钟平均负载。 free -h ps 可以看pid 这个杀死用，也可以看cup使用情况内存使用情况 断开通信除了四次挥手还有什么方式？ 如果主机需要尽快关闭连接（或连接超时，或端口、主机不可达）时，发送RST包（RST表示复位）强制关闭TCP连接。 发送RST包关闭连接时，可以丢弃缓存区的包直接发送RST包，而接收端收到RST包后，也不必发送ACK包来确认。 线程池场景https://www.bilibili.com/video/BV1dt4y1i7Gt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc（B站） https://www.bilibili.com/video/BV1ca411B78i/?spm_id_from=333.880.my_history.page.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc 报警那块 我是把每个传感器作为一块子的，每一个子的都用线程池 这里设置了一个计数器来阻止主线程继续，让主线程等线程池中弄完再走 CountDownLatch 这个是同步工具类中的计数器，有几组（我这里是传感器的数量（这里就16了））设置初始值为多少 CountDownLatch原理 https://zhuanlan.zhihu.com/p/95835099 池化思想 线程池、数据库连接池、字符串常量池都是这样，池化思想，目的是为了提高资源利用率 常见知识点 https://blog.csdn.net/tumu6889/article/details/125257712 阻塞队列 线程池方法 这些本质也是调用的threadpool 拒绝策略 AbortPolicy中止策略：丢弃任务并抛出异常。比较关键的业务推荐使用该策略，这样在系统不能承载更大并发量的时候就能通过异常发现 DiscardPolicy丢弃策略：丢弃任务不抛异常。一些无关紧要的任务可以使用这个策略 DiscardOldestPolicyi弃老策略：根据实际业务来决定是否允许丢弃老任务 CallerRunsPolicy：由调用者处理。一般在不允许失败、对性能要求不高、并发量小的场景使用 AQS node 有一个内部类node，如上图所示，每个node都有prev、next、waitstatus（记录上一个节点是谁，下个节点，状态（这个状态是上面那两个标志exclusive、signal）） 还有这一个属性，记录当前绑定的线程 头和尾节点 state 只要不是0，说明拿到锁 结构图 Renntralock 非公平锁 通过cas，如果把0修改成1，说明成功获取到了锁（这里通过cas怕别人并发拿到） 锁重入 参考资料 https://zhuanlan.zhihu.com/p/45305463 https://zhuanlan.zhihu.com/p/540999126 redis 数据类型 zset数据结构 压缩链表和跳表 压缩列表 压缩列表本质上就是一个数组，只不过增加了一些节点 如上图所示，黄色是增加的部分 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素。 跳表 之前只能从头一个一个遍历，时间复杂度为 O(N) 跳表是增加了多级索引 例如每隔一个数据就建立一层索引，建立多层就类似于二分查找了，时间复杂度 O(logN) 什么时候用压缩列表，什么时候用跳表？ 有序集合保证元素数量小于128个时，用压缩列表 红黑树的时间复杂度也是O（logn），为啥 不用它，而选择跳表 首先，跳表可以查范围数据，比如上述查22-27，这样可以找到22后直接遍历即可 其次，跳表是通过多层索引，结构比较简单，更加容易实现。红黑树还要调节点 参考资料 https://www.bilibili.com/video/BV1kh411x7Jc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc Redis为什么不用b+树？MySQL为什么不用跳表？ 这个问题在于 Redis是直接操作内存的并不需要磁盘io而MySQL需要去读取io，所以mysql要使用b+树的方式减少磁盘io，B+树的原理是 叶子节点存储数据，非叶子节点存储索引，每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一 而Redis是 内存中读取数据，不涉及IO，因此使用了跳表，跳表明显是更快更简单的方式。 什么是布隆过滤器 原理 布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。 简单来说就是准备一个长度为 m 的位数组并初始化所有元素为 0，用 k 个散列函数对元素进行 k 次散列运算跟 len(m)取余得到 k 个位置并将 m 中对应位置设置为 1。 优点 空间占用极小，因为本身不存储数据而是用比特位表示数据是否存在，某种程度有保密的效果。 插入与查询时间复杂度均为 O(k)，常数级别，k 表示散列函数执行次数。 散列函数之间可以相互独立，可以在硬件指令层加速计算。 缺点 可能存在误判 redis为啥快1.在内存 2.数据结构多，找到对应的 3.单线程，没有啥切换","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"马哲错题","slug":"马哲错题","date":"2020-03-14T16:00:00.000Z","updated":"2023-10-28T14:37:13.657Z","comments":true,"path":"posts/7a06f35t.html","link":"","permalink":"http://example.com/posts/7a06f35t.html","excerpt":"","text":"理论马克思恩格斯的两大发现是《唯物史观》、《剩余价值学说》 杰出人物，这里体现了必然性与偶然性的统一 量积累到一定程度才会发生质变，量的积累不一定会有质的变化 时间的概念 “贯彻新发展理念”没有体现否定之否定定律 否定之否定是三个阶段，贯彻新发展能够更好地指导我们实践，可以促进事物发展，没有三个阶段 实践实践是认识发展的动力理解：强调实践中产生的新问题需要新的认识去解决问题，从而推动认识的发展。 整体部分 诗句判别 查缺补漏斗争性与同一性斗争性是对立面之间相互排斥、相互分离的趋势和倾向。同一性强调矛盾双方相互依存、相互转化。无条件的东西都是寓于有条件的东西中的。矛盾的斗争是无条件的，而同一是有条件的、相对的，所以斗争性寓于同一性中。 联系联系的条件是可以改变的。比如说你可以用手机交流，也可以用pad交流。 世界上的任何事物不一定都是相互联系的，联系是有一定的条件的，与周围的事物都有这样与那样的联系 马克思诞生标准《共产党宣言》是马克主义诞生的标准。 辩证的否认辩证的否定是事物自身的否定，是克服和保留的统一，其实质是扬弃。 辩证的否定有两个重要特点：其一，辩证的否定是事物发展的环节，事物的发展从根本上说，就是旧事物的灭亡和新事物的产生；其二，辩证的否定是事物联系的环节，新事物对旧事物的否定，不是把旧事物简单地全盘抛弃，而是在抛弃旧事物消极的不合理的因素的同时，保留并改造吸收旧事物中积极的、合理的因素，作为自己生存和发展的基础。 “青出于蓝而胜于蓝，冰水为之而寒于水”中“青”和“蓝”、“冰”和“水”之间正是这样一种关系。 规律规律是稳定的，并非时刻变化。 主观能动正确发挥人的主观能动性，从实际出发是前提。实践是基本途径。还要依赖一定的物质基础。 发展事物发展的总趋势是前进的。发展的道路是前进性和扭曲性的统一。事物的发展是螺旋形式上升的并不是直线。 基础知识行百里者半90，它是比喻到一定程度才能取得胜利，比喻质变。 理论创新具有先导地位。创新共包括科技创新，制度创新，文化创新，理论创新。 野火烧不尽，春风吹又生，体现了哲学要尊重客观规律，让人发展的眼光看问题。 沉舟侧畔千帆过，病树前头万木春体现了新事物的代替旧事物。体现了发展的观念，其中沉舟病树是旧事物。千帆万木是新事物 梅须逊雪三分白，雪却输梅一段香”出自宋代卢钺的《雪梅》，意思是梅花虽逊让雪花三分晶莹洁白，雪花却输给梅花一段清香。体现了梅和雪各有特点，即矛盾具有特殊性。 对于分层分类就是体现矛盾的特殊性。比如说扶贫（有级别）。 实践高于理论的认知，是因为实践具有直接现实性。","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"马哲","slug":"马哲","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T10:24:16.944Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"http://example.com/posts/7a46f93c.html","excerpt":"","text":"第一天立德树人是教育之本 民主党派成员最多的是民盟 新民主革命的动力包括：工人、农民、小资产阶级、民族阶级 马克思主义哲学是无产阶级世界观 我党把马列主义和中国实际相结合的最初成果：《中国社会各阶级的分析》、《湖南农民运动考察报告》 1956年4月，毛泽东同志提出“百花齐放，百家争鸣”是我国发展科学、繁荣文学艺术的方针 习近平外交思想始终坚持实践第一的观点 古田会议决议了中心思想是要用无产阶级思想进行军队和党的建设（第九次党代表大会） 八七会议结束了陈独秀右倾投降主义在中央的统治，确立了土地革命和武装反抗国民党反动派的总方针，并发动了农民进行秋收起义（大革命失败后） 洛川会议为了动员一切力量抗日，并具体指定、建立党领导抗战的纲领和政府。 遵义会议是中国共产党第一次独立自主地运用马克思列宁主义解决自己路线、方针和政策的会议。挽救党、挽救红军、挽救新中国，是生死攸关转折点，提出红军应该采取积极防御的战略方针 邓小平提出了一国两制 陈独秀上海创办《青年杂志》，后改名《新青年》（它也是中国共产党第一个公开性机关刊物），迁往北京成为新文化运动的主要阵地，标志着新文化运动的兴起，口号为民主和科学，没有参加中共一大 董必武参加了上海兴业路一大会址纪念馆。为纪念馆写下了“作始也简，将毕也钜”。他出席了中共一大 李大钊是中国传播马克思主义最早的革命先驱，被称为“引来天火的人”，没有参加中共一大 《中国革命和中国共产党》一文中，毛泽东指出现阶段的敌人是帝国主义和封建地主阶级，主要任务也是干这两个，但最主要的是干帝国主义 党员开除党籍，五年内不得重新入党 生产实践、社会实践、科学实践，最基础的最重要的是生产实践 两个务必是毛泽东提出来的，在七届二中全会（务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续地保持艰苦奋斗的作风） 三湾改编首次提出官兵平等 毛泽东思想初步形成的标志是农村包围城市 1927年8月1号，八一南昌起义，让南昌获得了英雄城市的美誉 第二天十三大概况“一个中心、两个基本点”基本路线（一个中心，指以经济建设为中心；两个基本点，指坚持四项基本原则，坚持改革开放。），第一次比较系统地概述了社会主义初级阶段理论。 十二大提中特 十五大邓小平指导 十六大三个代表 十七大科学发展观 十八大全面建成小康 一大建党，二大立岗 三大国共合作 一大立党二立纲，三大国共要合作。四大领导工农忙，五大批评陈独秀。六大苏联求帮忙，南昌打响第一枪。八七枪杆出政权，三湾军队要听党。古田军队建新军，遵义军事与组织。瓦統洛后。毛六六论马🐎，七大确定毛指导。七届二中转城市，八大主矛和建设。十一三中要开放，十二小平提中特。十三阶段路线定，南方三猫论本质。十四目标在市场，十五小平成指导。十六提出三代表，十七科学发展观。十八科学成指导，十九走进新时代。 党的一大在莫斯科召开 陈独秀和李大钊都未参加一大 我国对资本主义工商业进行社会改造的基本政策是“和平赎买” 科学发展观第一要义是发展，核心是以人为本，基本要求是全面协调可持续性，根本方法是统筹兼备 马克思主义中国化的第一个重要理论成果是毛泽东思想 我国经济已经由高速增长转向高质量发展 红船精神是敢为人先的首创精神 长征精神是把全国人民和中华民族的根本利益看得高于一切 意识反作用于物质的基本途径是实践 我国进行土地改革的基本原因是封建土地制度阻碍了农村经济和社会的发展 社会主义的根本方向是消灭剥削、消灭两级分化 《实践论》《矛盾论》标志着毛泽东哲学思想形成 邓小平邓小平南方谈话内容是‘三个有利于标志’（两力一平）（是否提高生产力、综合国力、生活水平）（黑猫白猫，能抓老鼠就好） 一国两制是邓小平提出来的 十五大将邓小平理论写入党章 《星星之火可以燎原》毛主席回复林彪的，林彪问毛主席红旗还需要打多久 《论联合政府》是七大提出的，主要弄了三大作风，（理论和实践相结合，与人民群众紧密联系在一起，自我批评） 实践决定意识，是因为实践具有直接现实性（通过实践，直接可以变成现实，比如盖一个房子，直接就有了） 实践具有主观能动性，因为它是有目的有意思的去实践，这是和动物区分的，比如动物也会盖房子，它们没有目的和意识 实践具有社会历史性，具有社会性受到历史条件的制约，比如你实践割麦子，有条件用机器，没条件用手 意识是对客观世界的主观反映，意识的内容是客观的，表现形式是主观的 所有的意识都要来源于客观存在 无产阶级领导的中心问题是农民问题（农民也是最多的，主力军） 外因要通过内因起作用（比如说你妈妈天天唠叨你好好学习，这是个外因，但如果你不听，也起不到作用） 党的性质是先进性和纯洁性 毛泽东最先提出马克思主义中国化（马66论马） 社会的基本矛盾是社会发展的基本动力（社会基本矛盾包括：生生经上。生产力和生产关系，经济基础和上层建筑） 生产力决定生产关系，生产关系反作用于生产力（反作用是两面的，好的促进，坏的抑制） 生产力是人类改造自然的能力（人与自然），生产关系是人们之间的关系（人与人） 马克思的两大发现：唯物史观、剩余价值学说 红船精神包括：开天辟地、敢为人先的首创精神，坚定理想、百折不挠的奋斗精神，立党为公、忠诚为民的奉献精神 第三天神州十号载人飞船，男的有聂海胜、张晓光，女的有王亚平，其中，聂海胜担任指令长 中华名族由危亡走向振兴的转折点是抗日战争的胜利（党的是遵义会议） 主次矛盾与矛盾的主要方面（主次矛盾讲的是不同的事情，至少是两件事，比如发展面对经济、环境、人口问题等）（矛盾的主要方面是讲的一件事情，例如科技是把双刃剑） 群众路线的核心是一切为了群众，一切依靠群众 延安精神的核心是自力更生、艰苦奋斗 中共七大还没有建国，八大规模大 机械唯物主义（形而上学）（原子是事物的属性） 朴素唯物主义（看到的） 物质的唯一特性是客观实在性（不随人的意志改变），唯一属性是运动 实践是认识的来源，一切认识归根到底是从实践中获得（实践是认识的唯一源泉）（但实践不是认识的唯一途径，也可通过视频、图片等认识） 实践是认识的发展动力。实践中遇到的新问题需要新认识去解决，从而推动认识的发展 （前两个实践：先有实践。后面两个是先有认识。这样来做题） 实践是认识的目的，从实践中来，到实践中去，认识的目的是改造世界，到实践中去 实践是检验真理的唯一标志 毛泽东中国革命最后一个农村根据地是西柏坡（七届二中，提出了两个务必，进京赶考），像北平进发，进了北平香山，标志着中国革命重心从农村转向城市 意识具有目的性和计划性（比如想上岸，一天计划做多少题） 意识具有主动创造性（比如龙） 意识能指导实践改造世界（指导是中心词，包含正确和错误，考的时候要都说） 意识对人体的生理活动具有调节和控制作用（比如笑一笑十年少）（望梅止渴） 意识只有人有 意识没有客观实在性，物质才有 意识受到主题的影响（比如不同人看到同一个问题意识不同） 发展是前进性和曲折性的统一 发展有其自身的客观规律，不以人的意志为转移（种啥得啥） 毛泽东思想和中国特色社会主义的区别：毛不改革，中特不革命 建设现代化经济体系，着力点放在实体经济上 中华苏维埃第一次在瑞金召开 一国两制 ”爱国者治港“ 毛泽东思想围绕的主题是革命和建设 邓小平理论主题是什么是社会主义，怎样建设社会主义 十九大报告：以人民安全为宗旨，以政治安全为根本 三大规律：对立统一；质量互变规律；否定之否定规律 辩证否定的实质是扬弃。矛盾是事物发展的源泉和动力。辩证否定是事物联系和发展的环节。 大革命失败后，中国共产党建立的第一个农村根据地是井冈山根据地 中国革命农村包围城市、武装夺取政权根本在于处理好土地革命、武装斗争、农村革命根据地之间的关系 新民主主义的三大法宝：统一战线、武装斗争、党的建设 人民统一战线：工人阶级、农民阶级、名族资产阶级三者之间的关系 抗战统一战线：进步势力、中间势力、顽固势力 瓦窑堡会议确定了建立抗日民族统一战线方针 1938年《论持久战》提出了民兵是胜利之本 延安整风：反对主观主义以整顿学风（中心任务）、反对宗派主义以整顿党风、反对党八股文以整顿文风 意识对于客观事物的反映是主动的、有选择的（每个人看同一件事物的意识不同，比如蛋糕，艺术家看到的和普通人不一样） 第四天十八届三中全会提出市场在配置中发挥决定性作用（2013年习总书记主持） 十八届四中（2014）提出了依法治国 十八大（一选举，二宪法，三改革，四法律，五经济，六党建） 毛泽东思想灵魂包括：实事求是（根本点，出发点），群众路线（工作路线），独立自主（立足点）。 本本主义也是教条主义，就是做什么事情都不从实际出发，生搬硬套 在党的纪律中，政治纪律最重要、最根本、最关键 画梅不能止渴反映了观念东西不能代替物质东西 精神和物质的同一性，这个是你认为这个世界是否是可知的，如果你认为是可知的，就是同一的，这也是可知论 精神对物质的相对独立性：意识可能超前，也可能落后 精神可以转化成物质，通过实践 小康：邓小平提出放入国家。十二大提出，十六大建设，十八大建成 家庭是道德建设的起点，学校是道德建设的阵地 经济特区：生下三头猪（深圳、厦门、汕头、珠海）去海南度假，结果去了新疆喀什（kā shí）霍尔果斯 伟大载人航天精神：淡泊名利，默默奉献 实践高于理论认识，是因为实践具有直接现实性 第五天主要矛盾对事物发展起决定性作用 中国精神包括民族精神（核心爱国主义）和时代精神（核心改革创新） 爱国主义始终是把中华民族坚强团结在一起的精神力量，改革创新始终是鞭策我们在改革开放中与时俱进的精神力量 整体与部分关系：1.整体居于主导地位 2.关键部分对整体起决定性作用 3.整体是各部分的有机构成，具有部分没有的功能（比如说钟表，有计时功能，但是拆开后每个指针没有该功能） 中国共产党主题就是为了实现中华民族伟大复兴 实事求是的“是”为规律性","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"}],"categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}]}