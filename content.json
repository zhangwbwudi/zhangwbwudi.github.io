{"meta":{"title":"蜗牛","subtitle":"boの博客","description":"硕士 | 计算机科学与技术 | 网络安全","author":"蜗牛","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:02.559Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"","date":"2023-04-12T13:50:02.598Z","updated":"2023-04-12T13:50:02.598Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://example.com/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2023-04-12T13:50:02.620Z","updated":"2023-04-12T13:50:02.620Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://example.com/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:02.899Z","comments":true,"path":"List/index.html","permalink":"http://example.com/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.206Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.228Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.183Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2023-04-12T13:50:06.249Z","comments":true,"path":"census/index.html","permalink":"http://example.com/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2023-04-12T13:50:06.270Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2023-04-12T13:50:06.292Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:06.313Z","comments":true,"path":"resource/index.html","permalink":"http://example.com/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:06.334Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-04-12T13:50:02.919Z","updated":"2023-04-12T13:50:02.919Z","comments":true,"path":"List/galleries/index.html","permalink":"http://example.com/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:03.222Z","comments":true,"path":"List/music/index.html","permalink":"http://example.com/List/music/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2023-04-12T13:50:03.201Z","comments":true,"path":"List/movies/index.html","permalink":"http://example.com/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-04-12T13:50:03.244Z","comments":true,"path":"List/tools/index.html","permalink":"http://example.com/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-04-12T13:50:02.961Z","updated":"2023-04-12T13:50:02.961Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://example.com/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2023-04-12T13:50:02.940Z","updated":"2023-04-12T13:50:02.940Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://example.com/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-04-12T13:50:02.984Z","updated":"2023-04-12T13:50:02.984Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-04-12T13:50:03.006Z","updated":"2023-04-12T13:50:03.006Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-04-12T13:50:03.026Z","updated":"2023-04-12T13:50:03.026Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://example.com/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-04-12T13:50:03.048Z","updated":"2023-04-12T13:50:03.048Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://example.com/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-04-12T13:50:03.068Z","updated":"2023-04-12T13:50:03.068Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://example.com/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-04-12T13:50:03.091Z","updated":"2023-04-12T13:50:03.091Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://example.com/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-04-12T13:50:03.115Z","updated":"2023-04-12T13:50:03.115Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://example.com/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-04-12T13:50:03.138Z","updated":"2023-04-12T13:50:03.138Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://example.com/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-04-12T13:50:03.158Z","updated":"2023-04-12T13:50:03.158Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://example.com/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-04-12T13:50:03.179Z","updated":"2023-04-12T13:50:03.179Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://example.com/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"经济学","slug":"经济学","date":"2023-07-12T12:26:30.000Z","updated":"2023-07-31T15:08:03.152Z","comments":true,"path":"posts/d315c0a7.html","link":"","permalink":"http://example.com/posts/d315c0a7.html","excerpt":"","text":"物质资料生产三要素劳动者的劳动 劳动资料（生产工具） 劳动对象 物质资料生产过程生产 &gt; 分配 &gt; 交换 &gt; 消费 &gt; 生产（消费了，有钱了，再生产） 分配 、 交换 、 消费 对生产都具有反作用 消费是是物质生产的最终目的和动力 消费为生产创造出新的劳动力（可以这么理解，你买买买，没钱了，就去赚钱吧，就成了新的劳动力） 商品 含义 商品必须用于交换，必须投入人类的劳动 （武汉疫情捐赠物品是商品吗？不是，因为没有交换） 二要素 使用价值和价值 使用价值（就是有用性，比如水可以解渴）（有使用价值，商品才能交换）（使用价值是价值的物质承担着）（使用价值是商品的前提） 价值（凝结在商品中的无差别人类劳动） 有价值的东西一定具有使用价值 商品的价值依赖商品的流通 关系 比如说，你种菜，没有去卖，自己吃，这里有使用价值，是人与自然的 价值，比如说，你生产了一个东西，你觉得有价值不行，要别人也觉得，这展现了人与人 劳动的二重性商品的使用价值和价值是由劳动二重性决定的 二重 具体劳动（看的见的，比如你干活） 抽象劳动（撇开具体形式的无差别劳动，不管脑力还是体力） 与商品的关系 具体劳动创造商品的使用价值 抽象劳动创造商品的价值 货币概念货币是一般等价物 先有商品，再有货币 何为一般等价物 在古代，两个物品进行交换，比如说，我有小麦，你有蔬菜，我需要你的，你需要我的，咱两个进行交换。 但如果我需要蔬菜，但你不需要小麦，就很难受，这时候出现了一般等价物，类似于媒介 一般等价物固定后就是货币 一般等价物本质就是商品 职能 价值尺度：比如你买东西，上面有标价，这就是价值尺度（为什么货币有价值尺度？因为货币自身有价值，它也是一种商品）（只需要观念上的就行，这个价值高，这个价值低） 流通手段：充当商品交换的媒介（一手交钱，一手交货）（货到付款） 支付手段：延期支付（时间差，不同步）（比如税收、工资、利息） 贮藏手段：只针对金属货币（金子、银子） 世界货币：世界都能用 流通规律 价值规律商品价值量和社会必要劳动时间有关，成正比，与社会必要生产率成反比 价值总量与个别劳动时间成反比，与个别劳动生产力成正比，与社会无关 商品交换要以价值量进行等价交换（但不是每一次的交换都是等价交换，比如说超市打折） 表现形式 价值决定价格，供求影响价格 等价交换是从整体来说，从上面的图可以看出，针对某一部分来说，可能高也可能低，但整体是一样的 价值的货币表现形式 价格 价值的表现形式 交换价值 剩余价值资本不变资本（不发生增值，比如原材料） 可变资本（这里劳动力是可变资本） 剩余价值 来源 工人劳动时间分为必要劳动时间（付给你工资，应该干的）和剩余劳动时间（被压榨的） 劳动力和劳动 不一样，劳动力的使用才是劳动，这里的劳动会有剩余价值，压榨 劳动力成为商品的条件 自己的自由 除了劳动力别的没啥可卖了（农民不是，农民有地）（无产阶级是） 资本家钱生钱 必须通过劳动力 剩余价值率 这里的可变资本是买你的价格（因为可变资本才能有剩余） 例题 资本有机构成 有机构成=不变资本/可变资本 产生方法绝对剩余（加时长，加班） 相对剩余（提高效率，针对整体） 超额剩余（个别资本家通过提高劳动生产率，使自己的商品价值低于社会价值的，这个差额就是超额剩余价值）（针对个别） 资本周转 基本主义基本矛盾 生产过剩是相对的，买不起，和卖不出去 （上面是资产阶级）收入分配 初次分配就是有钱的出钱，没钱的出力，然后按照产生的效率分配（这种分配会拉大贫富差距） 因此有了再分配，再分配比如交税，赚的多交的多，缩小差距，尽量让中等收入者占大多数 第三次分配，比如捐赠这些 初次分配一般与企业和社会有关（比如最低工资标准）（手段就是市场机制） 再分配一般是政府（手段是宏观机制、税收等）（比如税收、社会保障、转移支付） 只有公有制（国有经济，集体经济）才有按劳分配（多劳多得） 非公有制： 个体经济（按个人劳动进行分配） 私企、外企（按生产要素进行分配）（生产要素：管理、劳动、土地、技术） 现代企业制度 这里的法人是可以承担责任的，不是一个人（公司就是法人） 现在企业制度的基本特征是：产权清晰、权责明确、政企分开、管理科学 有限公司和股份有限公司主要区别：是否将公司划分为等额的股份 股东会是谁投的钱多听谁的 董事会是看投票的人头数 需求 收入是消费的前提和基础 互补商品（比如汽车和汽油） 边际效应 你特别饿，吃第一个包子带来的效应大，第二个就会减少（再吃就吐了） 边际效应随着需求量（或者消费数量）的增加而减少 随着需求量的增加，收获效益小了，所以顾客愿意付钱也少了 总效用和边际效应 效应就是满足感 总效应就是总满足感 边际效应就是新增的满足感 当达到一定的度时，总效用会减少，边际效应会为负数（比如吃包子，吃饱了再吃就难受了，总效应减少，边际效应为负数） 需求弹性 需求的价格弹性&gt;1，证明富有弹性（需求量对价格变动敏感），反之，是缺乏弹性，不敏感，等于1是单一弹性 大于1的基本都是昂贵的物品，比如珠宝，价值变动一点，大家都会觉得有利可图 小于1的基本都是生活必须品 供给 商品价格：越高就赚钱越多，供给增加 技术：技术牛，产生的多，供给多 相关产品：替代品价格增加，替代供给增加，本产品供给下降（厂家更愿意制造利润大的） 市场失灵 外部性 生产和消费都会产生（正的和负的） 生产： 比如养蜜蜂在果园旁边，则果园给养蜜蜂的正外部 化工厂排污水对稻田有负外部性 消费： 正向的（你买了声控灯，你自己费电，人家经过也能用） 负的（比如吸烟） 信息不对称 这个针对买卖双方 比如说你买到了假货，卖方肯定知道的多 公共物品 比如说路灯，你消费的时候人家也可以消费，而且不会有额外成本 竞争类型 完全竞争，比如卖土豆，都一样，对价格完全没有控制，人家说的算（自由流动、产品无差别，数量多，交易零成本，几乎很难实现，农业近一点）（不需要打广告） 垄断竞争，比如买衣服的，每个厂家的衣服可能不一样，对价格有一点点控制 宏观调控 原因 自发性：损人利己，比如违法犯罪，发国难财，造假 盲目性：盲目跟着人家 滞后性：时间差， 手段 经济：财政（收或者放）、货币（中国人民银行）法律： 政治：命令、举报打击 最主要的手段是经济手段 目标 两增一稳保平衡 两增（经济增长、增加就业）（经济增长就行，没说加速增长） 稳定物价 保持国际收支平衡（避免过多的顺差或者逆差） 失业和通货膨胀 周期性事业 一般是出现经济危机 摩擦性事业 比如说跳槽 比如怀孕 结构性事业 技能不匹配，比如技能更新了 技术性事业 比如科技进步了，出现了机器，代替了手工劳动 季节性事业 比如旅游业 通货膨胀 供不应求 只有全面的、持续的商品物价上涨才会通货膨胀。 全面的是不仅一种物品价格上涨了，是很多 原因 成本上升，羊毛出在羊身上，物价会上涨 生活水平下降并不是针对所有人，主要是针对固定收入的人群 上面事业率和通货膨胀反方向关系，通货膨胀了，物价上涨，供不应求，要求员工造东西，失业率下降。反过来，失业率高，则经济萧条，说明卖不出去，供过于求，通货膨胀低。找到两者合适点最好 宏观调控 行政手段是强制的 财政收入 税 是政府收入最主要的部分 是强制的、无偿的、固定的 取之于人，用之于人 上面拉弗曲线，税太高了也不行，企业交不起，那嗝屁 所得税：例如工资、稿费、彩票 流转税：增值税、关税 利 利润，国家分红，或者出租啥 债 国债 增加国债属于扩张性政策（是把老百姓的钱集中到国家手里，再通过政策投入到建设中，这样市场中的钱就多了） 费 财政支出 购买性支出 看商品有没有回到政府手里，比如军需，有商品回去 转业性支出 没有回到政府手中，比如补助 财政政策 货币政策 利率：存款利率、贷款利率 再贴现： （贴现：企业之间往来一般使用证券、汇票、支票这些），到期了再周转。但有的企业没到期就想周转，商业银行要扣除利息等， 比如说张三存款10w，存一年，但急用钱，所以提前取出来要，这时候就是贴现（银行扣除利息啥的，可能给你9w） 如果银行也急用钱，可以拿条去央行，这叫再贴现 目的：干预和调节市场利率和供求 存款准备率 商业银行的钱必须一部分存到央行，这个比例（比如这个存款准备率是百分之十，那么商业银行有存款1000w，要想央行缴纳100w（为了保证人家取款的需要），这样放贷的钱就少了，提高这个率，可以抑制流动性过剩造成的通货膨胀） 目的：抑制流动性过剩造成的通货膨胀 公开 调节货币供应量，央行少了就卖，多了就买回来 调节货币供应 中介目标和操作目标和选择标准 中介目标是间接的，上述的都是中介目标 操作目标是直接的，但要等政策上后才能看到效果，是特殊型的 价格歧视就是差别定价 一级：按照每个的“心理价位”定价（比如讨价还价，比如你是卖东西的，看到一个穿的不好，就便宜卖，看到开好车的，卖他贵点） 二级：按照购买的量（比如，买多了便宜） 三级：按“人/市场”歧视（比如老人和小孩票便宜。比如说车子在中国和外国卖价不一样） 记忆：一级挨个坑；二级批量坑；三级分类坑 考察系数 基尼系数 对象：收入分配差异 结论：越低差距越小【0，1】 恩格尔系数 对象：生活水平 结论：恩格尔系数和生活水平成反比 他是食品的支出/总支出 小康（40%-50） 富裕（30%-40） 市场机制价值是核心 供求是主题 竞争是动力 风险是基础 价值规律最重要 价值规律是棒子、锤子、鞭子 政府是监管者 市场是主导者 市场经济 市场经济的核心是公平竞争 公正监管是公平竞争的保障 市场经济构成三要素 市场主体（政府、企业等，其中企业是主体） 市场体系（市场体系三大支柱：商品市场、资本市场、劳动力市场） 市场机制 现代市场经济构成三要素 市场主题 市场体系 宏观调控体系 GDP 国内生产总值 国土原则 中国人在中国+外国人在中国 这个是GDP 国民生产总值 国民原则 中国人在中国+中国人在外国 这个是GNP 必须按当期最终产品，中间的不能算（比如二手产品），要不就重复了 仅仅市场活动，黑市不算 绿色GDP 扣除资源消耗和环境降级 注意 二手商品不能计入，但二手商品交易费要计入 股票债券属于转移，不能计入（但服务费用算） 政府转移支付不能计入（比如救助） 最终产品 核算要算最终的，比如你做面包，需要鸡蛋，这个鸡蛋不能算了，这个在蛋糕里算了 当期生产 核算哪一年的核算到哪一年去，比如二手商品不能算 市场价值 要经过市场交换，比如你打扫卫生，自己干不算，请保姆才算 正常经济活动 黄赌毒不算 成本 机会成本 企业为了某个东西放弃了另一种的机会 比如说有一个1w、5w、10w的项目，你选择了10w的，这里放弃中最高的5w就是放弃成本 经济成本 投入的物资资源，比如项目需要的成本 沉默成本 已经付出的，并且无法回收的成本 可变成本和固定成本 可以成本：在一定范围呢，随着业务量的变化而变化 例子：比如家具厂生产家具 生产一件和生产100件所需要的原材料肯定不同，所以原材料是可变成本 比如房租，生产1件和100件都是一样的，是固定成本（借款利息也是，设备折旧也是） 金融工具期限短、流动性强、对利率敏感 又短又快又敏感 名人亚当斯密（看不见的手）（富国论） 凯恩斯（就业、利息和货币通论）（看的见的手）（国家对市场的干预） 效应收入效应（由价格变动引起实际收入的变动，进而影响需求量） 挤出效应（政府为了平衡预算，采取发放政府债券） 口红效应（口红便宜，指在经济萧条而导致低价产品偏爱的趋势）代替效应（收入不变的情境下，代替物品的价格变了） 马太效应（强者愈强、弱者愈弱） 溢出效应（不仅达到了预期，对组织之外的人也产生了影响） 追赶校园（穷逼上升空间大） 牧童经济（这个和环境相关，说牧童放牧的时候只关心放牧，忽略草原破坏程度）（不好） 宇宙飞船经济（是循环利用的，这个是和牧童经济向背的）（好的） 丰收悖论（丰收了，农民的总收入反而下降，粮食是生活必需品，丰收了，量多了，但人的需求没变，便宜了） 熊彼特利润（创新） 消费影响 影响需求最重要的因素 价格 影响消费最重要的因素 国民收入 拉动经济投资、消费、出口 （笑出头） 社会财富两极分化 原因 资本积累（资本积累是剩余价值转化成资本，是两极化的重要原因，也是社会失业的根源） 其他（易错概念）（不是原因了） 资本集中（这个是大资本吞并小资本，只是个别资本富起来了） 分配混合所有制企业（这个是按资本要素分配） 农民承包土地（按劳分配，这个属于集体经济）（国企也是）（收费所） 第三产业除了农业和工业都是 IS曲线针对产品市场均衡时收入（Y）和利率（r）组合点轨迹 负相关 LS左移或者右移动都是陡峭的 LM曲线针对货币市场均衡时收入（Y）和利率（r）组合点轨迹 正相关 LM左移变平缓、右移动变陡峭 LS和LM 的交点就是平衡点 公有制和非公有制 公有制在社会总资产中占优势（是总资产，不是资产） 非公有制是社会主义市场经济重要组成部分（注意是社会主义市场，不是社会主义经济，社会主义经济是公有制） 国有经济是主导，它才是我国国民经济的支柱（而不是公有制经济） 社会救助为了保障最低生活需要 把保证最低生活所需要的商品和服务金额作为基数 注意 不是劳动者收入的最低标准（这个太高了） 公司记账民营都是借贷记账法 事业单位是收付实现制 CPI消费者物价指数（居民消费物价指数）（你购买商品在今天和过去的差别）（当期价格/基期价格）（这里的商品都是与生活息息相关的商品）（消费和服务的加权平均价格方法） 可以反映通货膨胀 CPI上涨说明物价上涨，购买力下降 CPI下跌说明物价下跌，购买力增强 社会保险是国家强制实行，用人单位和个人必须参加 （必须五险） 商品经济和市场经济商品经济是以交换为主，最开始没有固定的交换场所，随着发展，就有了固定场所，这个场所就是市场 市场经济是发达的商品经济 计划经济是国家（政府）发布指定的经济，国家都分配好了，生产啥，生产了卖给谁 肉票、粮票这些都是 市场经济是市场配置的 政府调控 财政投资：政府想扶持哪个行业，就投哪个 财政信用：有偿借款 限制价格和支持价格限制价格一般低于均衡价格（保护消费者） 支持价格一般高于均衡价格（扶持） 社会经济自然经济（自给自足，不存在物质交换） 商品经济（价值规律） 产品经济（按需分配，不存在交换） 剩余价值规律是资本主义固有的，社会主义没有 借贷资本太有钱了，花不完，根本花不完，不如借出去钱生钱 这里只是短暂的给了使用权（时间到了还钱和利息），所有权没有给 所有制 公有制 公有制为主体 包括： 国有经济（生产资料归国家所以，国家主人人民，归人民所有）（国企，比如中石化）—–主导地位 集体经济（生产资料归一部分人所有）（合作社） 混合所有制中国有成分和集体成分（例如一汽大众） 非公有制 个体经济 私营经济 外资经济 对他们的态度是：鼓励、支持、引导 注意 全面所有制是国家所有制 现代企业制度产权清晰 权责明确 政企分开 管理科学 农业是社会注意国民经济的基础作用 产品定价产品加定价（成本加上利润） 渗透定价（初期价格低，来吸引消费者，后面长） 心里定价（价值与消费者心理感受有很大联系）（比如超市9.98，而不是10块） 差别定价（歧视性定价，同样的产品，对于人的不同，定价不同）（比如杀熟，新用户便宜） 股票交易一级市场（初级市场，大额） 二级市场（小额，进出比较简单） 投资高风险高回报 买进基金（中国风险） 股票（高风险高回报） 存银行（低风险） 买国债（低风险，比银行收益高一点点）","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"政治学","slug":"政治学","date":"2023-06-30T07:58:16.000Z","updated":"2023-07-16T15:01:23.637Z","comments":true,"path":"posts/398ed5cf.html","link":"","permalink":"http://example.com/posts/398ed5cf.html","excerpt":"","text":"毛泽东思想直接理论来源马克思列宁主义 物质基础新的社会生产力的增长和工人运动 实践基础中国共产党领导的人民革命 形成和发展 1921年 一大 1927年八七会议召开，毛主义讲话了，枪杆子里出政权 1935年遵义会议，毛主义确立了领导低位 1945年毛泽东思想确立党章 1956年三大改造完成，标志进入社会主义社会 后面的二十年开始犯错了，不会考 达到成熟的标志是新民主主义理论科学体系形成 萌芽阶段 这里主要是调查报告 第二阶段 这个时候写文章还不规范，比如本本主义，其实外语里是教条，由于不懂，写为本本 这里还没建国，是斗争多 《星星之火，可以燎原》是毛泽东在1930年给林彪的一封信，提出了农村包围城市、武装夺取政权，标志着毛泽东思想基本形成 《反对本本主义》论述了“从斗争中创造新局面”，“没有调查就没有发言权”，反对教条，做任何事情都要从实际出发 第三阶段 大佬级别，学术牛逼，比如战略问题、各种论，用词专业 论联合政府（1945）—目的为了建国（在七大上做的报告，全心全意为人民服务，一刻也不脱离群众，一切从人民利益出发）（三大优良作风）（快打败小日本了，建立一个什么样的国家呢） 毛泽东思想的成熟(1935—1945):1935年遵义会议后到抗日战争时期 标志**:新民主主义论**革命理论形成 1939年10月，中共中央主办的党内刊物《共产党人》创刊，毛泽东撰写了《〈共产党人〉发刊词》。在《〈共产党人〉发刊词》中，毛泽东指出，统一战线、武装斗争、党的建设是中国共产党在中国革命中的三个基本问题，也是中国共产党在中国革命中战胜敌人的三个法宝。 论持久战–它是针对党内部分“中国速亡论”、“中国速胜论”，持久抗日。强调“民兵是胜利之本”“武器是重要因素，但不是绝对因素，决定因素是人而不是物” 《中国革命和中国共产党》首次提出新民主主义概念（与国民党的区分），这个时候的首要任务是推翻帝国主义（1939年） 论人民民主专政—国家已经建立起来了，但里面啥政府都有，要建立社会主义国家，剔除其他党派 毛泽东在《在晋绥干部会议讲话》中第一次全面、系统地提出了反对帝国主义、封建主义和官僚主义 1956年《论十大关系》，这个时候三大改造完成了，关于建设的文章，把国内外一切关系调动起来。这里提出了“长期共存、互相监督”，标志着人民民主统一战线发展到了一个新的阶段 1957年《关于正确处理人民内部矛盾问题》，改造完成后，有点不适应，学生罢课啥的，为了解决这，划分了敌我矛盾（残余国民党，武力解决），人民内部矛盾（学生罢课等，用非对抗的方式去解决） 1949年《论人民民主专政》主要介绍了新中国的性质。 新民主主义革命1919-1949 1919新民主主义运动（五四） 明珠主义革命是反帝反封建的 马克思主义在中国实现了两次飞跃，第一次是毛泽东思想，第二次是中国特色（这里面包括邓小平理论） 三座大山是：帝国主义；封建主义；官僚主义 三个活灵魂 邓小平添加了解放思想 江泽民添加了与时俱进 胡锦涛添加了求真务实 群众路线：一切为了群众，一切依靠群众 实事求是是精髓，独立自主是基本立足点 三大经济纲领 三大法宝 统一战线 三大作风 三大改造 军队建设 南昌起义标志着军队的诞生 三湾改编是党最早领导军队 古田会议是军队新型建设思想形成 延安整风反对主观主义（中心，也就是学风） 反对宗派主义 反对党八股 （猪排骨） 党的处分警告 严重警告 撤销党内职务 留党察看 开除党籍 新民主主义核心问题是党（无产阶级领导） 基本问题是农民 根本问题是政权 首要问题是分清敌我 红军长征最壮烈的战役湘江战役 社会主义核心价值观个人：爱国、敬业、诚信、友善 国家：富强、民主、文明、和谐 社会：自由、平等、公正、法治 中国特色社会主义 邓小平理论78-97 97年邓小平去世 邓小平理论大部分诞生于十三大 活的灵魂解放思想，实事求是 社会主义本质和根本任务1992年南方谈话，南方谈话为了搞市场经济 社会主义本质：共同富裕，消除两极分化 根本任务：解放生产力 邓小平说马克思经济学犯错了，一个是经济制度，一个是经济体制，制度是有阶级性的。但体制没，它包括市场和计划，这就好比两只猫，黑猫和白猫，能抓老鼠就是好猫，老鼠是生产力 社会主义初期阶段理论87年党十三大提出 78-87近十年，中国还是很穷，没有达到社会主义，怀疑邓小平领导能力不行，所以邓小平说目前我们处于社会主义初期阶段，并长期处于这个阶段 邓小平说要处于社会主义初期阶段100年，人家不信，那说可以分以下三步走 三步走 江泽民又把第三阶段进行划分 习近平又把江泽民的第三阶段划分为两个阶段 党的基本路线和基本纲领也是十三大提出 这里主要是给党下任务书 要领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放 一国两制79年提出 经济特区广东省的深圳、珠海、汕头 福建的厦门 海南 新建的喀什经济特区、霍尔果斯经济特区 注意没有上海 重要事件先后顺序 取消农业税 2006年1月1日，我国全面取消农业税 北京奥运会 2001年申报成功 2008年北京举行 上海浦东新区 1992年 经济特区 1980年 南方谈话判断改革开发姓“社”还是姓“资”，主要看 是否有利于发展社会主义生产力（这个是最基本的） 是否有利于增强社会主义国家的综合国力 是否有利于提高人民生活水平 中特道路是途径 理论是指南 制度是保障 文化是精神力量 积累中国特色社会主义的道路是根本途径，理论是指南，制度是保障，文化是精神力量 全心全意为人民服务是人民军队的唯一宗旨，实行官兵一致、军民一致、瓦解敌军 刘少奇安源党校是第一个党校，延安中学是第一个中学 小康十二大提出，十六大建设，十八大建成","categories":[],"tags":[]},{"title":"","slug":"leetcode","date":"2023-04-25T11:43:01.441Z","updated":"2023-04-25T11:43:01.933Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://example.com/posts/0.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"spring","date":"2023-04-25T10:26:53.647Z","updated":"2023-04-25T10:26:53.920Z","comments":true,"path":"posts/0.html","link":"","permalink":"http://example.com/posts/0.html","excerpt":"","text":"SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解： 1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。 2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。 springboot内置tomcat","categories":[],"tags":[]},{"title":"jvm","slug":"JVM","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:26:39.764Z","comments":true,"path":"posts/7f1ae6dp.html","link":"","permalink":"http://example.com/posts/7f1ae6dp.html","excerpt":"","text":"Class字节码文件 是一个[二进制](https://so.csdn.net/so/search?q=二进制&amp;spm=1001.2101.3001.7020)文件，包含了JAVA程序执行的字节码，包含的信息有版本、访问标志、常量池、当前类、超级类、接口、字段、方法、属性等，中间没有任何分隔符，文件开头有一个特殊标志，用16进制表示为0xcafebabe。 类的实例化顺序比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序 先静态、先父后子。 先静态：父静态 &gt; 子静态 优先级：父类静态代码块–&gt;子类静态代码块–&gt;父类代码块–&gt;父类构造方法–&gt;子类代码块—&gt;子类构造方法 一个类的实例化过程： 1、 父类中的static代码块，当前类的static（这是类初始化，这个main所在的也会初始化） 2、 顺序执行父类的普通代码块(还有非静态变量)（下面是实例初始化） 3、 父类的构造函数 4、 子类普通代码块(还有非静态变量) 5、 子类（当前类）的构造函数，按顺序执行。 6、 子类方法的执行，、 例子 解释 jvm 常用配置参数 分配堆内存s -Xms 最小堆 -Xmx 最大堆 栈 -Xss 栈大小 如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 类需要同时满足下面3个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。加载该类的 ClassLoader 已经被回收。该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 逃逸分析是对象只在当前函数范围内使用，因而改为在栈上申请空间，因为栈是用完就释放掉，不用等gc，缓解了gc的压力。测试可以用一个while循环创建对象来查看 JVM的GC ROOTS有哪几个地方呢？a. java虚拟机栈中的引用的对象。b.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）c.方法区中的常量引用的对象。d.本地方法栈中的JNI（native方法）引用的对象 GC日志的real、user、sys是什么意思？real:指的是从开始到结束所花费的时间。比如进程在等待I/O完成，这个阻塞时间也会被计算在内。user：指的是进程在用户态（User Mode）所花费的时间，只统计本进程所使用的时间，注意是指多核。sys：指的是进程在核心态（Kernel Mode）花费的CPU时间量，指的是内核中的系统调用所花费的时间，只统计本进程所使用的时间。 real time &gt; sys + user time 的情况 一般的GC事件中，real time是小于sys+user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys+user time的。比如说：user+sys是2秒，如果是有5个GC线程并发的做垃圾回收，那么real time差不多是2000/5=400ms左右。 但是，有时候会见到real time大于sys+user time的情况 原因 IO负载繁重 当服务器的IO负载非常重的时候（网络、磁盘访问、用户交互），real time就会变大。应用做GC日志打印的时候，也需要访问磁盘。当磁盘的负载非常重的时候，GC事件就有可能被阻塞，这会导致real time变长。 注意：就算不是你的应用导致的磁盘负载重，如果服务器上其他的应用导致的磁盘负载重也会导致real time变长。 可以用如下命令来监控服务器的磁盘负载情况： CPU不够用 如果服务器上跑了很多进程，你的应用很不幸没有得到足够的CPU时间，它就需要很多的等待。当你的进程在等待的时候，real time显然就比sys+user时间长了。 safepoint是什么？g1什么时候引发full gcyoung GC触发时机：young区不够用 full GC触发时机: 没有足够的Region 垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器 串行 单线程堆内存较小，适合个人电脑 吞吐量优先 多线程堆内存较大，多核cpu让单位时间内，STW 的时间最短 0.2 0.2 = 0.4 响应时间优先 多线程堆内存较大，多核cpu尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5 解释 接下来我们来学习垃圾回收器，垃圾回收器我们可以把它分为这三类，第一类叫串行的垃圾回收器，第二类叫吞吐量优先的垃圾回收器，第三类叫响应时间优先的垃圾回收器。下面就解释一下，第一个串行的垃圾回收器，这个从名字上也能猜出来，它的底层是一个单线程的垃圾回收器，也就是说，它在垃圾回收发生时，其他的线程都暂停，这时候一个单线程的垃圾回收器就登场了，它一个线程来完成垃圾回收，显然它的适用场景是堆内存较小的时候，而且cpu的核数多了也没用，因为只有一个线程，适合个人电脑这就好比我们有一个居民楼，有一个保洁工人来打扫卫生，一个保洁工人就类似于这种单线程的垃圾回收器，如果楼层比较矮，小三层，那保洁工人可能一天就能把卫生打扫完了，但是如果楼层特别的高，是一个三十几层的高层建筑，那一个保洁工人来打扫，这个工作量可能是非常大的，干好几天都干不完。这是串行垃圾回收器它的适用场景。它适合堆内存小，个人电脑也就是cpu个数少的这么一个工作环境。而下两种吞吐量优先和响应时间优先的这两种垃圾回收器，它们都是多线程的，多线程的好处，还拿刚才那个例子作比喻，这个楼层很高，但是我可以多找几个保洁工人啊，它们每个人打扫一层或者几层，人多力量大，肯定还是可以在规定时间内完成垃圾回收的任务。所以后两种垃圾回收器都适合堆内存较大的场景，并且一般它需要多核的cpu来支持，为什么非要说多核cpu呢，虽然有多个线程，但是假设只有一个cpu，那么工作的时候也是多个线程轮流去争抢这单核cpu的时间片，其实这个效率还不如单线程呢，举个例子，就好比虽然有多个保洁工人来打扫卫生，但是扫帚只有一把，那要打扫卫生必须轮流使用这把扫帚，这个效率显然跟一个人来打扫是一样的，所以后两种垃圾回收器它们的工作适用场景是堆内存很大，但是有一个要求，就是必须是多核cpu才能充分发挥它俩的威力，显然多核cpu都是服务器电脑，所以它们都适合工作在服务器上。后两种吞吐量优先跟响应时间优先它们都是多线程的，那它俩之间又有什么区别呢。我们先说响应时间优先，响应时间优先它就是注重的是让垃圾回收时它的 Stop The World 的时间尽可能的短，我们都知道垃圾回收时它要把其他的线程暂停下来，等打扫完垃圾了，其他线程才能恢复运行，这段时间我们把它叫做 STW，就是世界暂停，这个世界暂停时间显然是越短越好了，那响应时间优先的垃圾回收器它要考虑的就是尽可能的让这个暂停时间变短，尽可能让 STW 的时间最短，这是它的一个目标。那么吞吐量优先呢，它的目标就不太一样，吞吐量优先是指我要在单位时间内让我的垃圾回收所占用的 STW 的时间最短，让单位时间内 STW 的时间最短。吞吐量优先和响应时间优先都是 STW 最短，那么它俩有什么区别呢，这个线程优先它是让单次的 STW 时间最短，举个例子，比如说，单位时间内触发了很多次垃圾回收，每一次垃圾回收都只花了 0.1s，假设1小时内发生了5次垃圾回收，每次都是0.1，那么它们加起来最后等于0.5s，也就是一小时内花费了0.5s，但是每次都很短，这是响应时间优先它的目标。但是吞吐量优先则不同，它可能单次的垃圾回收时间花费的较长，比如说1次花了0.2s，但是在一个小时内它只发生了两次垃圾回收，所以它的总时间来讲只有0.4s，从这一点上来讲，它似乎在总时间上又要优于响应时间优先，所谓的吞吐量就是指垃圾回收的时间占程序运行时间的占比，垃圾回收时间占比越低，那么就指吞吐量越高，这是吞吐量它的一个含义。 都要哪些 对于吞吐量优先的场景，就只有一种选择，就是使用 PS 组合（Parallel Scavenge+Parallel Old ）。 对于响应时间优先的场景，在 JDK1.8 的话优先 G1，其次是 CMS 垃圾回收器，另外还有PN、ZGC、Shenandoah。 jdk1.8新特性1.Lambda表达式 2.函数式接口 3.方法引用 等 类的主动使用和被动使用主动 主动使用，又分为七种情况： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（ 比如：Class.forName(“cn.sxt.Test”) ) 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法） 被动 子类引用父类的静态字段，不会导致子类初始化 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 局部变量、成员变量、类变量栈，堆，方法区 i++和++i栈帧都有哪些数据？JVM的运行是基于栈的，和C语言的栈类似，它的大多数数据都是在堆里面的，只有少部分运行时的数据存在于栈上。 在JVM中，每个线程栈里面的元素，就叫栈帧。 栈帧包含：局部变量表、操作数栈、动态连接、返回地址等。 栈结构 栈帧的内部结构 局部变量表 组成 最基本的存储单元是Slot（变量槽） 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量 在局部变量表里，32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long和double）占用两个slot 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maxmum variables数据项中。在方法运行期间是不会改变局部变量表大小的。 操作数栈每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出（Last-in-first-out）的操作数栈，也可以称之为表达式栈（Expression Stack）操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。比如：执行复制、交换、求和等操作 图解：将8和15出栈，执行求和操作后再将结果进栈操作。 动态链接每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）.比如：invokedynamic指令在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 1.举例栈溢出的情况 答：StackOverflowError，通过-Xss设置大小，1.局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。2.递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。3.指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。 2.调整栈大小，就能保证不出现栈溢出吗？ 答：不能，如果说一个执行6000次递归就结束的程序，在可执行递归5000次的内存空间中会出现StackOverflowError，而在调整为可递归7000次的内存空间时就不会出现StackOverflowError。 如果程序是类似死递归情况无论怎样调整栈大小，都会出现溢出现象，对于这种情况，调整栈的大小理论上只能说是出现异常的时间晚一些而已’ 3.分配栈内存越大越好吗 不是，理论上好像会在一定时间或单位时间内减少StackOverflowError的概率，避免出现StackOverflowError过早，但是避免不了出现StackOverflowError。对栈空间来说是好事，但是这样会导致可执行的线程数减少，对其他内存结构也是有影响的 4.垃圾回收是否会设计到虚拟机栈 不涉及，虚拟机栈会出现StackOverflowError，但是不会出现GC，因为只有进栈出栈，出栈的过程就相当于GC（程序计数器不会Error和GC，堆会GC和ERROR，方法区也会出现GC和ERROR） 标记清除算法标记-清除”算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 它的主要缺点有两个： （1）效率问题：标记和清除过程的效率都不高； （2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，碎片过多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至Stop The World。 复制算法（Copying） 为解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 它的主要缺点有两个： （1）效率问题：在对象存活率较高时，复制操作次数多，效率降低； （2）空间问题：內存缩小了一半；需要額外空间做分配担保(老年代) From Survivor, To Survivor使用的就是复制算法。老年代不使用这种算法， 标记-整理(Mark-Compact) 复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法（Generational Collection） GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。 “分代收集”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。 你知道哪些垃圾收集器？ serial 串行回收 新生代 采用复制算法 Serial是一个单线程的收集器，Serial的特点是它在进行垃圾收集时，必须“Stop the World”，意思就是当这个垃圾收集器开始工作时，必须停止其他所有的工作线程。听起来似乎很不靠谱，但是对于限定单个CPU的场景下，这种方式简单而高效。对于简单的桌面应用，分配给虚拟机的内存不会很大，对于一两百兆的新生代，Serial的垃圾收集时间可以控制在一百毫秒以内，对于用户来说基本上是无影响的。 serial old 采用标记-压缩算法 老年代 ParNew 并行回收 ParNew垃圾收集器是Serial的多线程版本，使用多条线程进行垃圾收集。除此之外，和Serial基本相同，ParNew在多线程收集垃圾时依旧需要“Stop the World”。ParNew可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数量。 ParNew收集器在新生代使用复制算法 Parallel Old Parallel Scavenge收集器的老年版本，多线程收集器，采用标记-整理算法，也是吞吐量优先。 Parallel Scavenge Parallel Scavenge也是新生代收集器，也同样是多线程的收集器，但是和ParNew不同，Parallel Scavenge收集器关注的是一个可控制的吞吐量（Throughput）。所谓吞吐量指的是CPU用于运行代码的时间和CPU总消耗的时间比例。 吞吐量=运行代码的时间 /（运行代码的时间+垃圾收集时间） 理论上吞吐量越高，用户就越不能感受到停顿时间。 Parallel Scavenge提供了两个参数用来控制吞吐量： -XX:MaxGCPauseMillis和**-XX:GCTimeRatio** -XX:MaxGCPauseMillis设置内存回收花费时间最高毫秒值，但是不要一味地认为只要把值设置很小，垃圾回收就更快了。这个停顿时间是以牺牲吞吐量和新生代空间换来的。 -XX:GCTimeRatio表示垃圾收集时间占总时间的比例，（1~100），也就是吞吐量的倒数。默认这个值是99，就是允许最大百分之1的垃圾手机时间（1/(1+99)）。 还有一个参数**-XX:+UseAdaptiveSizePolicy**，打开这个参数后，就不需要自己设置新生代大小、晋升老年代对象年龄等参数，因此Parallel Scavenge收集器也被叫做吞吐量优先垃圾收集器。 Parallel Scavenge采用复制算法。 cms 主要特点：低延迟 尽可能缩短垃圾收集时候用户线程的停顿时间 采用的标记-清除算法 老年代垃圾回收器 1、初始标记：标记GC Roots可以直接关联到的对象，速度很快（stop the world） 2、并发标记：根搜索算法的过程 3、重新标记：为了修正并发标记期间，因程序运行导致标记产生变动的对象。（stop the world） 4、并发清除：清除垃圾 它的优点就是并发收集、并发清除、低停顿。 但是它有三个显著的缺点： 1、对CPU资源十分敏感，因为并发标记和并发清除都是和程序同时运行，因此会占用CPU导致应用程序变慢。 2、无法处理浮动垃圾，浮动垃圾就是在并发清除过程中新生成的垃圾，这部分垃圾CMS无法在本次被清理，可能出现Concurrent Mode Failed报错，因此需要预留一定的内存空间，无法等到老年代快被占满时再清除。默认情况下，CMS在老年代使用了68%后就会被激活。可以设置-XX:CMSInitiatingOccupancyFraction设置这个值。 3、产生空间碎片，由于采用的是标记-清除算法，那就无法避免会产生空间碎片的问题，这会给分配大对象带来困难。 G1 区域化分代式 同时兼顾新生和老年代 划分为一个个region，region内部采用复制算法，整体是标记压缩算法。没有碎片化。 只选取部分region进行内存回收，这样缩短了回收范围，减少了停顿。 后天有一个优先列表，优先回收大的（这个也根据自己给的限制时间内选择较大的）","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"ShardingSphere","slug":"ShardingSphere","date":"2020-03-14T16:00:00.000Z","updated":"2023-05-28T09:18:39.979Z","comments":true,"path":"posts/7f1ae6sd.html","link":"","permalink":"http://example.com/posts/7f1ae6sd.html","excerpt":"","text":"定义 添加事务后均是主库，在没添加事务的时候插入是主，查询是从 主从复制 springboot只需要在配置文件里配置一下，这里配置数据源 只需要配置一下，哪个数据源是读得，那个是写的 配置负载均衡 记录docker 这是映射到主机 修改my。cof 主键生成策略雪花 水平分库分表策略 如上图所示，定义好数据库的放置，这里是通过userid，偶数放在1号库，奇数放在2号库。定义完成后再定义每个库中表的策略，这里是根据cid进行划分，偶数放在1号表，奇数放在2号表。 公共表 何为公共表 不长变的，经常需要做关联工作，比如地表沉降系统中的传感器节点信息表。（要在每个库中创建同样一张表） 这里也是通过shardingsphere做的，在papertie里设置公共表，如下 这样的话，插入和删除都是对每个数据的公共表同时操作。 读写分离 修改这个文件 改端口号 修改文件路径（存数据的） 分布式事务 TCC 分布式事务可以通过TCC来解决，分别是上面三个单词的缩写。使用TCC需要给表加上冗余列，例如上述订单表和库存表，需要在订单表中添加预增金额和状态，库存服务里需要添加冻结库存。 在执行TCC时候，Try是对资源进行锁定，在这一步预增金额这里设置一下（比如买10瓶水，一瓶水3块钱，这里的预增金额就设置为30，把状态改为初始），库存表也是这样（因为要取，所以库存要减少，这里是冻结库存设置为10，因为要取10瓶水）。 Confirm进行提交，这里如果提交成果，就把上面的预增金额和冻结库存给真正处理。状态设置为完成。 cancel取消，取消的话放弃预设金额和冻结库存，状态码设置为取消。 分布式ID可以使用UUID和雪花算法，但一般使用的是雪花算法。 原因 UUID 生成的是一个无序的字符串（影响查询效率） 雪花算法（SnowFlake）雪花算法的原理就是生成一个的 64 位比特位的 long 类型的唯一 id。 最高 1 位固定值 0，因为生成的 id 是正整数，如果是 1 就是负数了。 接下来 41 位存储毫秒级时间戳，2^41/(1000606024365)=69，大概可以使用 69 年。 再接下 10 位存储机器码，包括 5 位 datacenterId 和 5 位 workerId。最多可以部署 2^10=1024 台机器。 最后 12 位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成 2^12=4096 个不重复 id。 可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。 对于每一个雪花算法服务，需要先指定 10 位的机器码，这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的 10 位比特位的整数值都行。 具体网址 https://blog.csdn.net/jiaomubai/article/details/124385324?spm=1001.2014.3001.5506 分页查询分库分表后分页查询比较麻烦，比如差10条，一般从第一张表里查10条，再从第二章表里查10条，然后再排序获取。 跨库join 方案一 shardingsphere支持夸库join查询 方案二 先查一个字段，从这里获得关联的第二个字段，再通过第二个字段查 方案三 增加冗余列，把链接这个直接作为冗余字段存储 主从复制的问题使用shardingsphere进行主从复制，默认是查走从，插找主，但是主和从节点的数据同步是需要一些时间的，如果我们查最新插入的数据可能会导致查不到（因为数据还没有同步过去） 以地表沉降系统为例，查询最新的数据可能会导致查不到，原因如上。 方案一 可以设置查询最新的消息都走主库 方案二 在插入数据的时候同时插入缓存一个标志，比如设置60秒过期（根据业务定，差不多可以主从同步的时间），再查的时候先判断这个缓存还有没，如果有则查主，如果没有（说明已经主从辅助完成了）查从。 项目在形变模块，为了提升查询速度，对数据库进行了分库分表工作，对表进行了水平拆分，拆分了三个表。用到了数据库中间件shardingshere，采用了mod进行分片（利用传感器id），分布式id采用雪花策略，这样可以把同一个传感器的数据分到同一个表里，查询的时候就不需要查多张表了，提升速度。另外，项目里面有根据时间进行查询的，根据上面的分片策略可以实现，但需要到多张表中查寻，这样性能会低。我的解决方法采用看冗余数据，在通过时间进行范围分片。另外，做了主从复制，共搭建了两个从节点（在mini中配置），这里出现了一个问题，最新的数据有一部分查不到，原因是（通过shardingshere配置了查走从，其他走主。可能从还没有同步过来数据），解决方案是在插入数据的时候在redis中查如一个缓存，类似标志位，设置60秒（主从时间够就行），查的时候判断这个缓存还在吗，如果不在了就说明同步完成，查从。否则查主。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"linux","slug":"linux","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T11:21:54.981Z","comments":true,"path":"posts/7f1ae6do.html","link":"","permalink":"http://example.com/posts/7f1ae6do.html","excerpt":"","text":"目录结构bin sbin etc home usr root tmp vim快捷键 关机和重启的命令shutdown -h now 立刻进行关机 shutdown -h 1 ”hello，1分钟后会关机了“ shutdown -r now 现在重新启动计算机 halt 关机 reboot 重新启动 syn 把内存的数据同步到磁盘 注意：目前的shutdown/reboot/halt 等命令均已经在关机前进行了sync，但是在执行关机或重启前sync一下，小心驶得万年船 用户管理 用户切换 [halo@zwb-lucky root]$ su root Password: [root@zwb-lucky ~]# su - 用户名“命令来切换 注意 1.从权限高的用户切换到权限低的用户时，不需要输入密码，反之需要 2.当需要返回到原来用户时，使用exit/logout指令 添加用户 基本语法 useradd 用户名 实列(root权限下) useradd hucheng 添加一个用户chucheng，默认该用户的家目录在/home/hucheng 细节说明 1、当用户创建成功后果，会自动的创建和用户同名的家目录 2、也可以通过useradd -d 指定目录 新的用户名 来给新创建的用户指定家目录 12 新建用户zhanzhiwen的home目录下的文件夹名称是muluming 指定/修改密码 passwd 用户名 注意：修改密码要在root下 [zhangsan@zwb-lucky home]$ passwd zhangsan passwd: Only root can specify a user name. 删除用户 userdel 用户名 userdel -r 用户名 查询用户信息指令 id 用户名 [root@zwb-lucky ~]# id root uid=0(root) gid=0(root) groups=0(root) [root@zwb-lucky ~]# id halo uid=1000(halo) gid=1000(halo) groups=1000(halo),10(wheel) 查看当前用户/登录用户 whoami/who am i 用户组 类似于角色，系统可以对有共性/权限的多个用户进行统一的管理 新增组 指令：groupadd 组名 删除组 指令（基本语法）：groupdel 组名 注意：如果当添加用户时没有指定组，会默认创建和这个用户同名的组，同时把用户放到该组里 增加用户时直接加上组 指令：useradd -g 用户组 用户名 移动组 usermod -g 组名 用户名 运行级别说明：0：关机 1：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务 4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，也可以指定默认运行级别 帮助指令 man获得帮助信息 基本语法：man [命令或配置文件]（功能描述：获得帮助信息） 在linux下隐藏文件是以 “.” 开头的 help指令 基本语法：help 命令 （功能描述：获得shell内置命令的帮助信息） 文件目录类 pwd指令 基本语法：pwd （功能描述：显示当前工作目录的绝对路径） ls指令 基本语法：ls [选项] [目录或是文件] 常用选项 -a ： 显示当前目录所有的文件和目录，包括隐藏的 -l ： 以列表的方式显示信息 cd指令 基本语法：cd [参数] （功能描述：切换到指定的目录） 理解：绝对路径和相对路径（相对路径是针对当前位置的路径） cd ~ 或者cd 回到自己的家目录 cd … 回到当前目录的上一级目录 mkdir指令 基本语法：mkdir [选项] 要创建的目录 理解：mkdir指令用于创建目录（默认只能创建一级目录） -p :创建多级目录 rmdir指令（用于删除空目录） 基本语法：rmdir [选项] 要删除的空目录 使用细节： rmdir删除的是空目录，如果欲删除的目录下有内容则无法删除 ==如果需要删除非空目录，需要使用rm -rf 要删除的目录 touch指令（用于创建空文件） touch 文件名称 cp指令（copy拷贝文件导指定目录） cp [选项] source dest 常用选项：-r 递归复制真个文件夹 应用实例: 将 /home/hello.txt 拷贝到 /home/bbb 目录下 cp /home/hello.txt /home/bbb 递归复制整个文件夹，将/home/aaa 目录下的文件全部拷贝到/home/bbb下 cp -r /home/aaa /hom/bbb (是将整个目录和目录本身拷贝进来) rm指令（remove，移除文件或目录）=一定要小心！！！ 基本语法：rm [选项] 要删除的文件或目录 常用选项 -r : 递归删除整个文件夹 -f ：强制删除不提示 使用细节：强制删除不提示的方式，带上-f参数即可 cat指令（查看文件内容） cat [选项] 要查看的文件 常用选项： -n 显示行号 使用细节：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 |more cat -n /etc/profile |more 输入到控制台 查看历史 过滤查找，带行号","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"mysql","slug":"mysql","date":"2020-03-14T16:00:00.000Z","updated":"2023-05-28T11:01:04.056Z","comments":true,"path":"posts/7f1ae6dh.html","link":"","permalink":"http://example.com/posts/7f1ae6dh.html","excerpt":"","text":"什么是存储过程？用什么来调用？存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 用什么调用？ 可以用一个“execute 存储过程名 参数”命令来调用存储过程。 好处 由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。 完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 分为以下四类： 1、实体完整性：规定表的每一行在表中是惟一的实体。 2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。 3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。 4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。 与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。 使用B树的好处B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。 视图有哪些特点？哪些使用场景？ 什么是视图 是虚拟的表 使用和普通的表一样 mysql5.1后出现的新特性，是通过表动态生成的 特点 临时 可重复用 应用场景 多个地方用到了同样的查询结果 该查询结果比较复杂 好处 简化sql查询，提高开发效率，兼容老的表结构。 索引有哪几种类型？1、 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 2、 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 3、 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。 4、 全文索引：是目 前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。 5、 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行 6、 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并 好处 提高数据的搜索速度 坏处 在我们建立数据库的时候，需要花费的时间去建立和维护索引，而且随着数据量的增加，需要维护它的时间也会增加。在创建索引的时候会占用存储空间。在我们需要修改表中的数据时，索引还需要进行动态的维护，所以对数据库的维护带来了一定的麻烦。 MySQL自增主键用完了怎么办？一般都是int，一般用不完 用完了可以用bigint 可以考虑提前分库分表的。 mysql如何显示前50行？在Mysql中，使用以下代码查询显示前50行： SELECT*FROM LIMIT 0,50; sql执行速度慢怎么办可以加索引 原因 主要原因： sql写的烂 索引失效 关联查询多，比如join这些 加索引为啥快 如果没有索引，需要在所有的数据一点点查，与磁盘i/o多。加上索引，大大减少I/O操作。 二叉树 缺点：有序的时候不行 红黑树 虽然他进行了平衡，但数太多了，高度也很大 InnoDB和MyISAM有什么区别? 建立索引 默认索引是idx_开头 什么时候建立索引 对频繁使用的字段建立索引 索引失效原因 比如上面的name，email做了复合索引，这个是先按照name排序查在按照email查。如果查询语句没有name，只写了whare email = ？，这样就会失效 sql执行顺序 SQL语句中order by和group by一起使用的注意事项 1.order by 的列，必须是出现在group by 子句里的列2.order by 要 放在 group by的后面 join 左连接 两张表的高度要一致，不一致要补null 左边的全部查出来，根据on进行连接，右表没有的补null 右链接 内链接 on是跟的join的条件 1 去除AB公共部分，就是B.key is null 1 全连接 索引 什么是索引 索引是帮助mysql高效的获取数据的数据结构 MySQL中，用的最多的是InnoDB存储引擎，InnoDB中的索引采用B+Tree这种s数据结构 (排好序的快速查找的数据结构) 会影响查找和排序（比如orderby） 一般来说，索引也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上 有哪些索引 单值索引 唯一索引 复合索引 基本语法 哪些适合建立索引 主键自动建立唯一索引 频繁查询 查询中排序的字段，索引可以大大提升速度 不适合索引 where用不到的字段 频繁更新的字段（因为更新也要更新索引） 表记录很少就算了 数据重复率高，又或者类别很少（比如说ture，false）就不建立了 事务四大特性 并发情况下引发的问题 脏读：A事务还没提交，B事务就读到了A事务的结果。（破坏隔离性） 例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（破坏一致性，update，delete）例如：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（破坏一致性，insert）例如：目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 解决 四种隔离级别，隔离程度不同，副作用也不同 读未提交（Read uncommitted）： ​ 这种事务隔离级别下，select语句不加锁。 ​ 此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。 读已提交（Read committed）： ​ 可避免 脏读 的发生。 ​ 在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。 3 .可重复读（Repeatable read）： ​ MySql默认隔离级别。 ​ 可避免 脏读 、不可重复读 的发生。 串行化（Serializable ）： ​ 可避免 脏读、不可重复读、幻读 的发生。 实现（innoDB） 隔离级别就是依赖锁和MVCC实现的。 锁 InnoDB中的行锁 ① 记录锁（Record Locks） 锁住某一条记录 ② 间隙锁（Gap Locks） 比如幻读，一开始没有数据，没办法加记录锁，可以加间隙锁 (3, 8)这个区间被锁 ③ 临键锁（Next-Key Locks） 是上两个锁的组合，间隙锁是开区间（3，8），如果我们也想锁住8，那么用临键锁（3，8] innodb默认的锁就是Next-Key locks。 ④ 插入意向锁（Insert Intention Locks） 为什么索引用b+不用bb+数非叶子叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。IO次数更少 b+高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5， 为什么MySQL 没有用hash作为索引的数据结构呢？1.Hash 冲突问题 ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。 2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点： 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。 数据库常用得命令 超键、候选键、主键、外键超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键 候选键(candidate key):不含有多余属性的超键称为候选键 主键(primary key):用户选作元组标识的一个候选键程序主键 外键(foreign key)如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。 结合实例的具体解释： 假设有如下两个表： 学生（学号，姓名，性别，身份证号，教师编号） 教师（教师编号，姓名，工资） 超键： 由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。 候选键： 候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。 主键： 主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。 外键： 外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。 sql五种约束 主键约束：不重复、唯一、非空 设置主键的列不允许为空， 唯一约束用来保护表中某列数据不允许重复， char与varchar的区别 char的长度不可变，而varchar的长度可变 这就表示，存储字符串’abc’，使用char(10)，表示存储的字符将占10个字节（包括7个空字符） 使用varchar(10),则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储 char类型的效率比varchar的效率稍高 varchar比char节省空间，但是在效率上比char稍差些。既要获得效率即必须牺牲一点空间，这就是设计上的””以空间换时间”” 三范式 一范式 不重复，原子 数据冗余 插入异常 比如说你新建一个系，这个时候没有学生就插入不了 二范数 消除部分依赖， 完全依赖，通过一个候选码可以确定其他码 比如id可以确定姓名等但是id和课名才能确定分数 分数完全依赖于（id和课程），可以说（id和课程）就是候选码，但是name只需要id就可以，所以说name部分依赖于（id和课程）消除 解决了1范式的数据冗余，修改异常 3范式 消除传递依赖 插入和删除没问题 事务原子性 undo log 持久性 redo log mysql数据是写入磁盘的，但写入磁盘比较慢，所以出现了一个缓存buffer，再写的时候是先写入buffer，在慢慢同步到磁盘。找的时候也如此。如果这时候宕机，buffer嗝屁，不能持久性，这时候有个日志redo log，在放buffer时候也在redo log记录一下，它记录了修改，根据它回复 隔离性 写-写：锁 写-读：mvcc mvcc主要是处理读请求，是快照读而不是当前读 目的是读写得时候不用去竞争锁，提高性能 读已提交和可重复读的快照读都是基于mvcc实现的 基于三个实现 undo log 、版本连、ReadView 如图，把di为1的一直修改，有事务id，这个是自增的，然后回滚指针，指向之前修改的 undo log记录之前修改的 readview啥用 你看版本连里面这么多版本，不知道取哪一个啊 其实readview在代码里就是一个对象 m_ids 表示活跃的，啥是活跃的，就是没有commit creator_trx_id 谁生成了这个readview 例子 读已提交RC：这个级别下每次select都会产生一个readview。 可重复读RR：这个级别下readview是以事务为单位，第一个select产生一个readview，后面不产生了 redolog保证持久性 当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。 为啥不直接写入磁盘 写入redolog快，写入的方式是在文件后面追加，不需要找位置。但是写入磁盘需要找的写入的具体位置，这个比较慢 redolog写满怎么办 它是写满了就从头开始写，像一个环状 redolog和binlog区别 主从复制springboot怎么使用 springboot是自动装配的，你好几个数据库，它怎么知道链接哪一个 在aplication.apropeity里分别定义主从的密码，用户名，链接这些 然后这里仿照springboot配置文件自己定义了一个配置类，取出aprlicaotion中的文件 配置数据源 设置链接工厂这些 设置默认值defult CREATE TABLE students( student_id INT DEFAULT 100, name VARCHAR(255) NOT NULL, age INT DEFAULT 15 ); 分布式IDuuid和雪花（snowflake） 区别 uuid是无序的不建议使用（因为无序在索引使用的时候影响较大） 雪花算法 它有64个bit位 配置也是通过shardingspere ，在properties中配置 非聚集索引回表一般普通索引就是非聚集索引，需要回表。聚集索引一般为主键索引，根据这个再进行回表。 为啥不都用聚集索引 没必要，浪费空间，因为每一个创建一个索引，innodb都会创建一个索引树，如果叶子节点都放数据就会浪费空间 具体参考 https://blog.csdn.net/weixin_38192427/article/details/111872683 不同类别索引创建 主键索引 ALTER TABLE tbl_name ADD PRIMARY KEY (col_list); // 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 唯一索引 ALTER TABLE tbl_name ADD UNIQUE index_name (col_list); // 这条语句创建索引的值必须是唯一的，索引值可以为null（null可重复出现） 普通索引 ALTER TABLE tbl_name ADD INDEX index_name (col_list); // 添加普通索引，索引值可出现多次。 删除 ALTER TABLE tbl_name DROP INDEX index_name； 索引失效原因https://blog.csdn.net/qq_43460095/article/details/125538837 覆盖索引就是联合索引，在普通索引查询后，需要进行回表操作，但如果查的多，一直回表比较费时。 这时候可以采用覆盖索引进行解决 比如这里增加name、和age复合索引，这样在查name和age就不需要回表，但要注意索引失效 参考链接 https://www.bilibili.com/video/BV1cv411P7Wb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc https://blog.csdn.net/Aplumage/article/details/117015144 索引下推Mysql5.6更新后一个重要特性，被问到要答出来 参考 https://www.bilibili.com/video/BV1ks4y157CS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc","categories":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"spring","slug":"spring5","date":"2020-03-14T16:00:00.000Z","updated":"2023-06-04T03:13:03.172Z","comments":true,"path":"posts/7f1ae6sp.html","link":"","permalink":"http://example.com/posts/7f1ae6sp.html","excerpt":"","text":"ioc为了降低耦合度 底层原理 xml解析、工厂模式、反射 工厂模式 它的出现就是为了解耦合 ioc 工厂不在new了，通过反射来创建对象，这样我们只需要修改xml就可以了 Spring提供的IOC容器实现的两种方式（两个接口） BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。） ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！ 注入 set &lt;!--（2）spring方式： set方法注入属性--&gt; &lt;bean id=\"book\" class=\"com.atguigu.spring5.Book\"&gt; &lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --&gt; &lt;property name=\"bname\" value=\"Hello\"&gt;&lt;/property&gt; &lt;property name=\"bauthor\" value=\"World\"&gt;&lt;/property&gt; &lt;/bean&gt; construct &lt;!--（2）spring方式：有参数构造注入属性--&gt; &lt;bean id=\"orders\" class=\"com.atguigu.spring5.Orders\"&gt; &lt;constructor-arg name=\"oname\" value=\"Hello\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"address\" value=\"China！\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 注入空值和特殊值 &lt;bean id=\"book\" class=\"com.atguigu.spring5.Book\"&gt; &lt;!--（1）null值--&gt; &lt;property name=\"address\"&gt; &lt;null/&gt;&lt;!--属性里边添加一个null标签--&gt; &lt;/property&gt; &lt;!--（2）特殊符号赋值--&gt; &lt;!--属性值包含特殊符号 a 把&lt;&gt;进行转义 &amp;lt; &amp;gt; b 把带特殊符号内容写到CDATA --&gt; &lt;property name=\"address\"&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 注入外部bean &lt;!--1 service和dao对象创建--&gt; &lt;bean id=\"userService\" class=\"com.atguigu.spring5.service.UserService\"&gt; &lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userDaoImpl\" class=\"com.atguigu.spring5.dao.UserDaoImpl\"&gt;&lt;/bean&gt; xml 注入集合属性 &lt;!--（2）在 spring 配置文件进行配置--&gt; &lt;bean id=\"stu\" class=\"com.atguigu.spring5.collectiontype.Stu\"&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=\"courses\"&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list类型属性注入--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map类型属性注入--&gt; &lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"JAVA\" value=\"java\"&gt;&lt;/entry&gt; &lt;entry key=\"PHP\" value=\"php\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set类型属性注入--&gt; &lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 在集合里面设置对象类型值 &lt;!--创建多个course对象--&gt; &lt;bean id=\"course1\" class=\"com.atguigu.spring5.collectiontype.Course\"&gt; &lt;property name=\"cname\" value=\"Spring5框架\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"course2\" class=\"com.atguigu.spring5.collectiontype.Course\"&gt; &lt;property name=\"cname\" value=\"MyBatis框架\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--注入list集合类型，值是对象--&gt; &lt;property name=\"courseList\"&gt; &lt;list&gt; &lt;ref bean=\"course1\"&gt;&lt;/ref&gt; &lt;ref bean=\"course2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 自动装配 两个的弊端：byname必须名字一样，要不不行 bytype，两个同类型的容器不行，直接报错 注解实现 当然要首先开启注解的支持 @Autowired @Qualifier @Resource Bean 的作用域有哪些?Spring 中 Bean 的作用域通常有下面几种： singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。（单例） prototype : 每次请求都会创建一个新的 bean 实例。（原型） request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。 session : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。 global-session ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。 单例 Bean 的线程安全问题了解吗？大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。 常见的有两种解决办法： 在 Bean 中尽量避免定义可变的成员变量。 在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。 (换成原型模式就安全了)（加锁当然也可以不过会降低效率） 代理模式这是spring aop的底层 aop切面编程 AOP(Aspect Oriented Programming)：面向切面编程，一种编程范式，AOP弥补了OOP的不足，基于OOP基础之上进行横向开发。 OOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型；AOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行， springmvc的执行流程 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。（被它拦截，拦截什么可以配置，比如配置/nihao，就拦截/你好）(一般写/，全拦截就行了) DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。（这个是根据url获取handler） url分为什么 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样： if(mappedHandler.getHandler() instanceof MultiActionController){ ((MultiActionController)mappedHandler.getHandler()).xxx }else if(mappedHandler.getHandler() instanceof XXX){ ... }else if(...){ ... } 这样假设如果我们增加一个 HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof HardController)，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。 HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器 什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 转发和重定向1、请求次数 重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次； 2、地址栏不同 重定向地址栏会发生变化，转发地址栏不会发生变化； 3、是否共享数据 重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）； 4、跳转限制 重定向可以跳转到任意URL，转发只能跳转本站点资源； 5、发生行为不同 重定向是客户端行为，转发是服务器端行为； 请求转发：request.getRequestDispatcher(“info.html”).forward(request, response); 请求重定向：response.sendRedirect(“1.html”); 项目构建 先创建一个父工程 删除父工程src，因为用不到 导入自己知道的公共依赖 创建子工程，一个普通的maven即可 servlet继承httpservlet，重写doGet、depost 乱码问题过滤器解决乱码 配置文件配置 (上面的/换/*) springmvc自带过滤器（在配置文件上配置就可以了） jison它是一种数据格式，现在都是前后端分离开放，需要这样一种格式约定 requestbody了解http请求 第一行是请求url；包含请求类型，地址等 第二行是请求头；包含身份信息，请求内容的类型等 然后空行 第四行请求体： get请求是url传参的，例如上面？后面的 post请求体传参的，比如上面两个，可能是json或者字符串（表单）等等 测试 加上requestbody get请求不行，post请求表单不行，jsion可以 不加requestbody get，post表单都可以。jsion不行 所以处理传来的是jison的时候加上requestbody 注意 用requestbody修饰字符串的时候，会接收整个jsion 所以requestbody尽量修饰一个实体参数，或者map requestparam其实这个在参数上加和不加是一样的，只不过加上可以解决前端和后端传递参数名不一致的情况 跨域问题1.使用注解 (局部跨域) 在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。 @RestController @CrossOrigin(origins = \"*\") public class HelloController { @RequestMapping(\"/hello\") public String hello() { return \"hello world\"; } } 2.手动设置响应头(局部跨域) 使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。 @RequestMapping(\"/index\") public String index(HttpServletResponse response) { response.addHeader(\"Access-Allow-Control-Origin\",\"*\"); return \"index\"; } 3.使用自定义filter实现跨域 package cn.wideth.aop; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; @Component public class MyCorsFilter implements Filter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, OPTIONS, DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"x-requested-with,content-type\"); chain.doFilter(req, res); } public void init(FilterConfig filterConfig) {} public void destroy() {} } get请求和post请求的区别1.get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。 2.get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；post请求是没有的长度限制，请求数据是放在body中； 3.get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。 4.get请求可以被缓存，post请求不会被缓存。 5.get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。 6.get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。 requestbody和RequestParamRequestBody注解的主要作用就是用于接收前端的参数，当我们使用post请求的时候，我们会将参数放在request body中，此时我们就需要在Controller的方法的参数前面加上@RequestBody用来接受到前端传过来的request body中的值，举个栗子： @Controller @RequestMapping（“/test”） public class test{ public void testMethod(@RequestBody String string)\"{ System.out.println(\"测试\"); } } 一个请求只能有一个RequestBody，也就是说，当一个方法中有两个参数的时候，最多只能有一个参数加@RequestBody注解用来接受request body中的参数； @RequestParam接收的参数主要是来自request Header中，即请求头中。通常用于get请求中，我们都知道get请求的参数都是写在url中的，例如：http://localhost:8080/my/api/testMethod?name=雷神&amp;age=3 该url我们可以看到有那么和age两种属性，那么当我们将此请求发送到后台服务以后，Controller写法如下： @Controller @RequesMapping（“/api”） public class test{ public void testMethod(@RequestParam(value=\"name\",required=false,defaultValue=\"雷神\")String name,@RequestParam(value=\"age\")Int age){ System.out.println(\"年仅\"+age+“岁肥宅”+name); } } 注意 RequestBody的作用是将前端传来的json格式的数据转为自己定义好的javabean对象，需要注意的是传入数据的属性名称要和后端javabean中定义的一致，发送请求后可以看到在控制台中我们通过javabean对象的get方法打印出了前端传来的值，说明json数据已经成功被转换为了javabean对象，将对应的属性进行了赋值。 SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解： 1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。 2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。 springboot自动配置 springboot启动流程 原理 https://blog.csdn.net/m0_46316970/article/details/125898849 @ComponentScan 扫描类，可以扫描很多个类还是只能一个类？默认情况下,@ComponentScan扫描入口类同级及其子级包下的所有文件。 扫描其他包 动指定扫描包路径。 springboot自动装配 自动装配和自动配置 自动装配是autowire 自动配置是auto-configuration 自动配置 这里用@ComponentScan来加载我们application路径下的包，用@EnableAutoConfiguration来用spring factory机制来加载第三方的jar包的配置类，所有加载好后，再去加载这些配置类用@Import，@Bean等注解去加载的别的配置类，此时所有需要加载的配置类都加载好了，再去实例化这些bean，将这些bean注册到IOC中 https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc @import 用法 1、直接填class数组方式2、ImportSelector方式【重点】3、ImportBeanDefinitionRegistrar方式 普通 @Import({ 类名.class , 类名.class... }) public class TestDemo { } ImportSelector 分析实现接口的selectImports方法中的：1、返回值： 就是我们实际上要导入到容器中的组件全类名【重点 】2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！ 第一步：创建Myclass类并实现ImportSelector接口，这里用于演示就添加一个全类名给其返回值 public class Myclass implements ImportSelector {//要实现ImportSelector接口 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { return new String[]{\"com.yc.Test.TestDemo3\"};//这里是要导入的全限定名 } } 类似注入多个，每个用它的全限定名 第二步：使用ImportSelector方式的Myclass类 @Import({Myclass.class}) 参考 https://blog.csdn.net/a14654/article/details/114398753 https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"java基础","slug":"java基础","date":"2020-03-14T16:00:00.000Z","updated":"2023-06-05T03:09:20.600Z","comments":true,"path":"posts/7f1ae090.html","link":"","permalink":"http://example.com/posts/7f1ae090.html","excerpt":"","text":"Java 中 sleep 方法和 wait 方法的区别？​ 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。 sleep()是Thread类中的方法，而wait()则是Object类中的方法。 程序计数器(线程私有)一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 迭代器 Iterator 是什么？首先说一下迭代器模式，它是 Java 中常用的设计模式之一。用于顺序访问集合对象的元素，无需知道集合对象的底层实现。 Iterator 是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。 缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 // 引入 ArrayList 和 Iterator 类 import java.util.ArrayList; import java.util.Iterator; public class RunoobTest { public static void main(String[] args) { // 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(\"Google\"); sites.add(\"Runoob\"); sites.add(\"Taobao\"); sites.add(\"Zhihu\"); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的第一个元素 System.out.println(it.next()); } } 线程的 sleep()方法和 yield()方法有什么区别？1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态； 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常； 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。 volatile关键字的作用和原理 volatile关键字的作用 1、保证可见性；2、防止指令重排；3、但是不保证原子性； 可见性是什么？ 在JMM（java memory model）java内存模型中，其他线程从主内存空间把值拷贝到自己的工作空间，线程修改之后的值会返回给主内存，主内存会通知其他线程，此为可见性。 指令重排 CPU为了执行效率会并发执行操作指令，volatile可以使指令一个一个的执行。 为什么不保证原子性 //自定义的类 public static class MyTest { //类的内部成员变量num public volatile int num = 0; public void numPlusPlus() { num++; } } 比如说，在多个线程同时执行num++时候，他们都是把num值copy到自己的工作内存中，++后再写回主内存。问题出现了这里，比如说A线程刚要写回内存时候，被抢占挂起了，然后B线程写进去了，然后通知所有线程修改了。但是这个时间太短了，所以A也写进来了，把刚刚的覆盖了。 如何解决原子性问题 1、通过synchronized关键字。(不建议，因为volatile自身就是轻量级的，可以说是乞丐版本的synchronized，加这个太重了)2、通过使用AtomicXX，不加锁,采用CAS（compareAndSet）解决。其本质是使用UnSafe本地方法（CPU原语）。3、使用LongAdder:最快（在线程多的情况下，使用分段锁）1、通过synchronized关键字。 Java 中能创建 volatile 数组吗？可以创建volatile数组，但是volatile只保证对数组的引用可见，即如果是改变引用只向的数组，将受到volatile的保护，但是对多个线程想要去改变数组里面的元素，volatile不能保证。 java equals于== 什么时候不同 对于字符串变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。 “==”比较两个变量本身的值，即两个对象在内存中的首地址。 “equals()”比较字符串中所包含的内容是否相同。 注意 String s1,s2,s3 = \"abc\", s4 =\"abc\" ; s1 = new String(\"abc\"); s2 = new String(\"abc\"); s1==s2 是 false //两个变量的内存地址不一样，也就是说它们指向的对象不 一样，故不相等。 s1.equals(s2) 是 true //两个变量的所包含的内容是abc，故相等。 （上述的是因为string重写了equals方法，比较的是值） 重点1 如果： StringBuffer s1 = new StringBuffer(“a”); StringBuffer s2 = new StringBuffer(“a”); 结果： s1.equals(s2) //是false 解释：StringBuffer类中没有重新定义equals这个方法，因此这个方法就来自Object类， 而Object类中的equals方法是用来比较“地址”的，所以等于false 重点2 对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符 串常量所生成的变量，其中所存放的内存地址是相等的， 所以s3==s4是true(即使没有s3=s4这样一个赋值语句) 重点3 对于非字符串变量来说，”==”和”equals”方法的作用是相同的都是用来比较其 对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。 如何判断对象是否是垃圾？引用计数：在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。 可达性分析：主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。 线程四种创建方式？ 创建线程的四种方式 继承Thread类（Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法）,实现Runnable接口,实现Callable接口,线程池。 线程池的好处 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 形成死锁的四个必要条件是什么1、互斥条件：一个资源每次只能被一个进程使用； 2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺； 4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系； 什么是IoC和DI？IoC(控制反转) 、DI(依赖注入) ioc IOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 di DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 两者关系 在平时的Java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象或者依赖对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，**创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起**，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象B之后，两个人一起协作完成要完成的工作即可。 所以控制反转IOC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IOC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IOC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IOC容器了，通过IOC容器来建立它们之间的关系。 DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结道：控制的什么被反转了？就是获得依赖对象的方式反转了。 Java的内存模型是什么？（JMM是什么？）JMM 是Java内存模型（ Java Memory Model），简称JMM。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范。通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。 计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。 三大特性 1.原子性一个或多个操作，要么全部执行（执行的过程是不会被任何因素打断的），要么全部不执行。 2.可见性只要有一个线程对共享变量的值做了修改，其他线程都将马上收到通知，立即获得最新值。 3.有序性 有序性可以总结为：在本线程内观察，所有的操作都是有序的；而在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as-if-serial 语义：线程内似表现为串行，后半句是指：“指令重排序现象”和“工作内存与主内存同步延迟现象”。处理器为了提高程序的运行效率，提高并行效率，可能会对代码进行优化。编译器认为，重排序后的代码执行效率更优。这样一来，代码的执行顺序就未必是编写代码时候的顺序了，在多线程的情况下就可能会出错。 java类型转换规则自动转换规则 布尔型不参与转换 转换规则（总）： byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double 转换规则（详）3.1 操作数之一为double，则另一个操作数先被转化为double，再参与算术运算；3.2 操作数均不为double，当操作数之一为float，则另一操作数先被转换为float，再参与运算；3.3 操作数均不为double或float，当操作数之一为long，则另一操作数先被转换为long，再参与算术运算；3.4 操作数均不为double、float或long，则操作数先被转换为int，再参与运算。 特殊：4.1 如采用+=、*=等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。4.2 当运算符为自动递增运算符（++）或自动递减运算符（–）时，如果操作数为byte，short或char类型不发生改变； Java的char能否存汉字当然可以 Java的char类型占两个字节，存的是Uicode码，其中就包含了汉字。怎么将 byte 转换为 String？ 怎么将 byte 转换为 String？一、String转化为byte[] //Convert to byte[] byte[] bytes = string.getBytes(); System.out.println(\"bytes输出是：\"+bytes); 二、byte[]转化为string String s = new String(bytes); //Check converted string against original String System.out.println(\"Decoded String : \" + s); 什么是隐式转换，什么是显式转换显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。 Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型Char类型可以隐式转成int,double类型，但是不能隐式转换成string（不能自动转换，一个是值类型，一个是引用类型 ）；如果char类型转成byte，short类型的时候，需要强转。 notify() 和 notifyAll() 有什么区别？notify()只能唤醒一个wait()线程,然而notifyAll()可以唤醒多个wait()线程; Java 中的 LinkedList 是单向链表还是双向链表？双向列表 接口特征接口的特征有：1、接口使用interface关键字修饰；2、接口不可以实例化；3、实现类一定要实现接口的所有方法（抽象类除外）；4、实现类可以实现多个接口；5、接口中的常量都是静态常量 接口中只能有static、final变量,不能有其他变量。 什么是过滤器？怎么创建一个过滤器个人理解，拦截并处理（可能是增强等等） 如何创建过滤器 主要是实现过滤器接口，重写dofilter Java中各种数据默认值1、 Byte,short,int,long默认是都是0 2、 Boolean默认值是false 3、 Char类型的默认值是’’ 4、 Float与double类型的默认是0.0 5、 对象类型的默认值是null synchronized 和 Lock 有什么区别？1、 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； 2、 synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 3、 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 4、 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 5、 synchronized只支持非公平锁,lock支持非公平锁和公平锁; synchronized原理 什么是VectorVector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多 ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。 抽象类必须要有抽象方法吗？不必须 1.如果一个类使用了abstract关键字修饰，那么这个类就是一个抽象类。 2.抽象类可以没有抽象方法 3.一个类如果包含抽象方法，那么这个类必须是抽象类，否则编译就会报错。 4.最关键的一点就是如果一个类是抽象类，那么这个类是不能被实例化的。 抽象类有构造方法吗 可以有构造方法。构造方法的作用有两个，一个是初始化变量，另外一个是实例化对象，抽象类不能实例化，还可以做另外一个作用。 能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化， int 类型的高 24 位将会被丢弃，因为 byte 类型的范围是从 -128 到 127 接口和抽象类的区别是什么？1、抽象类可以有构造方法，接口中不能有构造方法。2、接口的方法默认是 public，所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。3、接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。4、一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。5、接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（不能使用 private 关键字修饰！）。6、从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 如何合理配置线程池大小1、CPU密集型特点：更多的CPU在做计算，一直在工作，等待时间很少推荐：线程数少一点一般：CPU内核数+1 2、IO密集型特点：更多的时候线程在等待响应推荐：线程数多一些一般：CPU内核数 * 2 或者（线程等待时间与线程CPU时间之比 + 1） * CPU数目 3、混合型特点：啥任务都有推荐：将CPU密集和IO密集的操作分成2个线程池去执行一般：2个线程池 直接缓冲区和非直接缓冲区的区别1.直接缓冲区是建立在系统的物理内存的，而非直接缓冲区是建立在jvm内存，jvm内存是有上限的，所以速度会很慢 2使用直接缓冲区会对你的物理内存有一定的影响。而非直接缓冲区不会，但是会慢。 如何决定使用 HashMap 还是TreeMap？HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。两个都是非线程安全 ArrayList的优缺点 ArrayList的优点如下： ArrayList底层以数组实现，是一种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候非常快； ArrayList在顺序添加一个元素的时候非常方便； ArrayList 比较适合顺序添加、随机访问的场景； ArrayList的缺点如下： 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能； 插入元素的时候，也需要做一次元素复制操作，缺点同上； 构造方法能不能重写？能不能重载？不能重写但是可以重载，因为构造方法不能被继承。如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有super();语句,即调用父类不带参数的构造方法。如果类里定义一个或多个构造方法，那么java不提供默认的构造方法(不带参数的构造方法)。 被引用的对象就一定能存活吗？不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收 常见异常 java.lang.NullPointerException(空指针异常) java.lang.IllegalArgumentException( 方法的参数错误) 比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。 java.lang.ArithmeticException 数学运算异常 当算术运算中出现了除以零这样的运算就会出这样的异常。 java.lang.ClassCastException数据类型转换异常 当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。 Object obj = new Integer(0); String str = obj; java.lang.NoSuchMethodException方法不存在异常 当程序试图通过来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常 java.lang.OutOfMemoryException内存不足错误 当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。 如何停止一个正在运行的线程？ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法 使用interrupt方法中断线程 线程池都有哪些状态？线程池的5种状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。 RUNNING：运行状态，线程池创建好之后就会进入此状态，如果不手动调用关闭方法，那么线程池在整个程序运行期间都是此状态。 SHUTDOWN：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。 STOP：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。 TIDYING：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。 TERMINATED：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。 线程的五种状态 1.新建状态（New）： 创建一个新的线程对象。 2.就绪状态（Runnable）: 线程创建对象后，其他线程调用start()方法，该线程处于就绪状态，资源已经准备就绪，等待CPU资源。 3.运行状态（Running）： 处于就绪状态的线程获取到CPU资源后进入运行状态。 4.阻塞状态（Blocked）： 阻塞状态是线程由于某些原因放弃CPU使用，暂时停止运行。 （1）等待阻塞：线程调用start（）方法，JVM会把这个线程放入等待池中，该线程需要其他线程调用notify()或notifyAll()方法才能被唤醒。 （2）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入锁池中。 （3）其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 5.终止状态（Terminated）： 线程run（）方法运行完毕，该线程结束。 怎么检测一个线程是否拥有锁？在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。 Java 中用到的线程调度算法是什么？有两种调度模型：分时调度模型和抢占式（java默认使用）调度模型。 分时调度模型： 平均分配每个线程占用的 CPU 的时间片。 抢占式调度模型： 让优先级高的线程占用CPU，如果线程优先级相同，那么就随机选择一个线程。 session和cookie的区别对象都是优先分配在年轻代上的吗？不是 平时代码创建出来的对象，一般分为两种： ​ 一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收，会分配到年轻代里。 ​ 另一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停地去使用，会分配到老年代里。 JAVA如何判断两个类是否相等？ 两个类是否相等，取决于他们是否由统一个类加载器来加载。如果他们来自不同的类加载器，哪么就算这两个类来自同一Class文件，他们也是不相等的。 同一个加载器，那么要判断两个类是否相等我们则可以简单的通过他们的Class对象是否是同一个对象即可。 Integer和int的区别1、类型不同:Integer是对象类型,int是基本数据类型。Integer是int的包装类。 2、Integer变量需要实例化之后才能使用，int则不需要。 3、Integer的默认值是null,int的默认值是0 4、Integer是对象的引用，当new一个Integer对象时，实际上是生成一个指针指向这个对象；而int则是直接存储数据 注意 对于非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true； 如果两个变量的值不在这个区间，则比较结果为false。 Java线程唤醒与阻塞的常用方法 sleep() 方法 sleep(毫秒)，指定以毫秒为单位的时间，使线程在该时间内进入线程阻塞状态，期间得不到cpu的时间片，等到时间过去了，线程重新进入可执行状态。(暂停线程，不会释放锁) yield() 方法： 会使得线程放弃当前分得的cpu时间片，但此时线程仍然处于可执行状态，随时可以再次分得cpu时间片。yield()方法只能使同优先级的线程有执行的机会。调用 yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。(暂停当前正在执行的线程，并执行其他线程，且让出的时间不可知) wait() 和 notify() 方法 两个方法搭配使用，wait()使线程进入阻塞状态，调用notify()时，线程进入可执行状态。wait()内可加或不加参数，加参数时是以毫秒为单位，当到了指定时间或调用notify()方法时，进入可执行状态。(属于Object类，而不属于Thread类，wait()会先释放锁住的对象，然后再执行等待的动作。由于wait()所等待的对象必须先锁住，因此，它只能用在同步化程序段或者同步化方法内，否则，会抛出异常IllegalMonitorStateException.) 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？1、 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。 2、 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。 频繁fullGc 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁gc) 是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了) 为什么HashTable是线程安全的？HashMap是线程不安全的 Hashtable下面代码 //get它搞成了同步方法，保证了get的安全性 public synchronized V get(Object key) { …… } //synchronized,同样 public synchronized V put(K key, V value) { …… } //也是搞成了同步方法 public synchronized V remove(Object key) { …… } finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。 finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。 。finalize()方法允许被重写，一般在该方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。 用最有效率的方法计算2乘以8？2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方 什么是JDK?什么是JRE？JDK = JRE + Java 开发工具包 [Java,Javac,Javadoc,Javap等] JRE = JVM + Java 的核心类库 [类] JRE顾名思义是java运行时环境 JDK顾名思义是java开发工具包 JDK（Java Development Kit）是Java的开发工具包，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等 如何通过获取和设置对象私有字段的值？import com.fasterxml.jackson.annotation.JsonProperty; public class SysUser { // @JsonProperty(\"roleIdList\") private Long[] roleIds; } public Long[] getRoleIds() { return roleIds; } public void setRoleIds(Long[] roleIds) { this.roleIds = roleIds; } 下面是获取 import com.fasterxml.jackson.annotation.JsonProperty; public static Object getFieldValueByObject(Object object, String targetFieldName) throws Exception { // 获取该对象的Class Class objClass = object.getClass(); // 初始化返回值 Object result = null; // 获取所有的属性数组 Field[] fields = objClass.getDeclaredFields(); for (Field field : fields) { // 属性名称 String currentFieldName = \"\"; // 获取属性上面的注解 import com.fasterxml.jackson.annotation.JsonProperty; /** * 举例： @JsonProperty(\"roleIds\") * private String roleIds; */ try { boolean has_JsonProperty = field.isAnnotationPresent(JsonProperty.class); if (has_JsonProperty) { currentFieldName = field.getAnnotation(JsonProperty.class).value(); } else { currentFieldName = field.getName(); } if (currentFieldName.equals(targetFieldName)) { field.setAccessible(true); result = field.get(object); return result; // 通过拿到该属性在此对象中的值(也可能是个对象) } } catch (SecurityException e) { // 安全性异常 e.printStackTrace(); } catch (IllegalArgumentException e) { // 非法参数 e.printStackTrace(); } catch (IllegalAccessException e) { // 无访问权限 e.printStackTrace(); } } return result; } 主要的 Field[] fields = objClass.getDeclaredFields(); field.setAccessible(true); 并发编程三要素1、原子性 原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操 作打断，要么就全部都不执行。 2、可见性 可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他 线程可以立即看到修改的结果。 3、有序性 有序性，即程序的执行顺序按照代码的先后顺序来执行。 讲讲什么情况下会出现内存泄漏？内存泄漏的原因很简单： 1、 对象是可达的(一直被引用) 2、 但是对象不会被使用 例子 public static void main(String[] args) { Set&lt;Object&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { Object object = new Object(); set.add(object); // 设置为空，该对象不再使用 object = null; } // 但是set集合中还维护object的引用，gc不会回收object对象 System.out.println(set); System.out.println(set.size()); } } 解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。 内存溢出常见原因及解决方法引起内存溢出的原因有很多种，常见的有以下几种： 1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据。 解决方法：检查对数据库查询中，是否有一次获得全部数据的查询；对于数据库查询尽量采用分页的方式查询。 2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。 解决方法：检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。（内存泄露） 3.代码中存在死循环或循环产生过多重复的对象实体。 解决方法：检查代码中是否有死循环或递归调用；检查是否有大循环重复产生新对象实体。 4.使用的第三方软件中的BUG。 解决方法：使用内存查看工具动态查看内存使用情况。 5.启动参数内存值设定的过小； 解决方法：修改JVM启动参数(-Xms，-Xmx)，直接增加内存。 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。 乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 动态代理为什么 Thread 类的 sleep()和 yield ()方法是静态的？Java对象创建过程java创建对象的过程主要分为一下五个步骤：（1）类加载检查Java虚拟机（jvm）在读取一条new指令时候，首先检查能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化。如果没有，则会先执行相应的类加载过程。 （2）内存分配在通过（1）后，则开始为新生的对象分配内存。该对象所需的内存大小在类加载完成后便可确定，因此为每个对象分配的内存大小是确定的。而分配方式主要有两种，分别为： 1.指针碰撞 应用场合：堆内存规整（通俗的说就是用过的内存被整齐充分的利用，用过的内存放在一边，没有用过的放在另外一边，而中间利用一个分界值指针对这两边的内存进行分界，从而掌握内存分配情况）。 即在开辟内存空间时候，将分界值指针往没用过的内存方向移动向应大小位置即可）。 将堆内存这样划分的代表的GC收集器算法有：Serial，ParNew 2.空闲列表 应用场合;堆内存不规整（虚拟机维护一个可以记录内存块是否可以用的列表来了解内存分配情况） 即在开辟内存空间时候，找到一块足够大的内存块分配给该对象即可，同时更新记录列表。 将堆内存这样划分的代表的GC收集器算法有：CMS （3）初始化默认值第（2）步完成后，紧接着，虚拟机需要将分配到的内存空间都进行初始化（即给一些默认值），这将做是为了保证对象实例的字段在Java代码中可以在不赋初值的情况下使用。程序可以访问到这些字段对用数据类型的默认值。 （4）设置对象头初始化（3）完成后，虚拟机对对象进行一些简单设置，如标记该对象是那个类的实例，这个对象的hash码，该对象所处的年龄段等等（这些可以理解为对象实例的基本信息）。这些信息被卸载对象头中。jvm根据当前的运行状态，会给出不同的设置方式。 （5）执行初始化方法在（4）完成后，最后执行由开发人员编写的对象的初始化方法，把对象按照开发人员的设计进行初始化，一个对象便创建出来了。 会导致类初始化 会导致 类初始化 的情况 main 方法所在的类，总会被首先初始化 首次访问这个类的 静态变量 或 静态方法 时 子类初始化，如果父类还未初始化，会引发 子类访问父类的静态变量，只会触发父类的初始化 Class.forName new 会导致初始化 不会导致 类初始化 的情况 访问 类的 static final 静态变量（基本类型和字符型）不会触发初始化 类对象.class 不会触发初始化 创建该类的数组不会触发初始化 类加载的 loadClass 方法 Class.forName 的参数2 为 false 时 final不可变对象，它对写并发应用有什么帮助？不可变对象天生是线程安全的。 Java中操作字符串使用哪个类？操作字符串的类主要用三个,分别是String类,StringBuffer类和StringBuilder类. MyBatis中使用#和$书写占位符有什么区别？#将传入的数据都当成一个字符串，会对传入的数据自动加上引号； # 使用#传入参数是，sql语句解析是会加上””,比如 select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是 select * from table where name = ‘小李’， $ 另外一种场景是，如果你要做动态的排序，比如 order by column，这个时候务必要用${},因为如果你使用了#{},那么打印出来的将会是 select * from table order by ‘name’ ,这样是没用， 注意 目前来看，能用#就不要用$,使用 $ 占位符可能会导致SQL注入攻击 String、StringBuffer、StringBuilder的区别是什么 String：不可变 StringBuffer：可变的，线程安全 StringBuilder：可变的，线程不安全 线程安全： String因为是不可变，也可理解为常量，因此是线程安全的。而StringBuffer 和 StringBuilder 继承自AbstractStringBuilder，而AbstractStringBuilder定义了一些基本字符操作，如append、insert、indexOf等，在StringBuffer的方法中加了同步锁，因此StringBuffer是线程安全的。而StringBuilder没有相应的锁，所以非线程安全。 可变性： 简单而言，String类使用Final关键字字符数组保存字符串，private final char[] value，所以String是不可变的。而StringBuffer 和 StringBuilder 都是继承自AbstractStringBuilder，而AbstractStringBuilder 也是使用使用字符s数组保护字符串，不过没有final关键字，char[] value，所以后两者是可变的 对三者使用的总结： 操作量少：String 单线程操作量大：StringBuilder 多线程操作量大：StringBuffer 如何通过创建对象？1、 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 2、 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 运行时常量池溢出的原因？不断创建常量，比如字符串等。 什么是JSON？json的全称为：JavaScript Object Notation，是一种轻量级的数据交互格式。 优点 1、方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是xml、纯字符串的方式，但json有其独到的好处。google有个自己的协议，叫protobuf，有兴趣可了解一下。2、方便转换。有很多的json api提供了json字符串转成对象、对象转换成json串的方法。3、易于阅读。json代码的良好结构，可以很直观地了解存的是什么内容。 Minor GC与Full GC分别在什么时候发生？ Minor GC / Young GC 首先我们先来看下 Minor GC / Young GC，大家都知道，新生代(Young Gen)也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。 此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC，这两个名词，相信大家就理解了，说白了，就专门针对新生代的 GC。 Full GC 对于 Full GC，其实这里有一个更加合适的说法，就是说 Full GC 指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为 Full GC。 从字面意思上也可以理解，Full 就是整体的意思，所以就是对 JVM 进行一次整体的垃圾回收，把各个内存区域的垃圾都回收掉。 MajorGC 老年代 什么是可重入锁synchronized、ReentrantLock都是可重入的锁，可重入锁相对来说简化了并发编程的开发。 可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。synchronized 和 ReentrantLock 都是可重入锁。 可重入锁的意义之一在于防止死锁。 Java常见的锁总结 可重入锁、乐观锁、悲观锁、公平锁、非公平锁、自旋锁等 自旋锁在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。 为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 缺点 ​ 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。 如果锁被占用的时间很短，自旋等待的效果就会非常好；如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置） 实现原理 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 public final int getAndAddInt (Object var1, Long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while( !this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 线程同步和线程异步有什么区别同步和异步的区别，比如说某一次测验：同步：老师派科代表去办公室拿试卷，然后一直等到拿回来试卷，没错就是干等什么都不做，然后发卷子。老师一直等到卷子都发完，才开始说明测验内容。等到说明完了之后，学生才开始做卷子。。。异步：老师派科代表去办公室拿试卷，然后老师简单的介绍测验内容（此时介绍测验内容和科代表拿试卷是同时进行的），科代表拿回试卷后“通知”老师试卷已经拿回来了。老师可以暂停讲解，让科代表发卷子并继续讲解（老师比较嘴碎）。发完卷子学生一遍开始做卷子一遍听老师讲解（老师比较嘴碎，讲了这么久都没讲完）。 什么是线程同步和互斥同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。 OOP中的组合、聚合和关联有什么区别？如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的 关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指 一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在， 但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 理解 比如A类中包含B类的一个引用b，当A类的一个对象消亡时，b这个引用所指向的对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫做组合，反之b所指向的对象还会有另外的引用指向它，这种情况叫聚合。 在实际写代码时组合方式一般会这样写：A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡。聚合方式则是这样：A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它传给它的这个对象不是A类创建的。 代码 聚合 class Driver { //使用成员变量形式实现聚合关系 Car mycar; public void drive(){ mycar.run(); } } 组合(上面的代码加上这些) public Driver(Car car){ mycar = car; } 自动装箱和自动拆箱自动装箱和自动拆箱自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。JDK1.5后，Java引入了自动装箱(autoboxing)/拆箱(unboxing)。自动装箱：基本类型的数据处于需要对象的环境中时，会自动转为“对象”。自动拆箱：每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用Integer 设计模式六大原则：1、单一原则（Single Responsibility Principle）：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化； a、业务对象（BO business object）、业务逻辑（BL business logic）拆分； 2、里氏替换原则（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能；（本质其实就是c++的多态） （目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。 3、依赖倒置原则（dependence inversion principle）：面向接口编程；（通过接口作为参数实现应用场景） 抽象就是接口或者抽象类，细节就是实现类 含义： 上层模块不应该依赖下层模块，两者应依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象； 通俗点就是说变量或者传参数，尽量使用抽象类，或者接口； 【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】 4、接口隔离原则（interface segregation principle）：建立单一接口；（扩展为类也是一种接口，一切皆接口） 定义： a.客户端不应该依赖它不需要的接口； b.类之间依赖关系应该建立在最小的接口上； 简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用） 【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】 5、迪米特原则（law of demeter LOD）：最少知道原则，尽量降低类与类之间的耦合； 一个对象应该对其他对象有最少的了解 6、开闭原则（open closed principle）：用抽象构建架构，用实现扩展原则； url一般有哪几部分组成？一般标准的URL由协议、主机名、路径及文件名三部分00组0成。 comparable和comparator的区别 相同点： 两个都是接口都是实现比较的返回值都是a&gt;b返回正整数,a=b返回0，a&lt;b返回负数。 不同点： comparable位于java.lang包下面，而comparator位于java.util包下comparable实现的是自连接（比如String类），就是将自己和指定的一个对象进行比较，而comparator是另外的一个类的一个方法将两个不相关的对象进行比较，很显然comparator的耦合性比comparable的耦合性要低。 注意 在一些集合里面要对类进行排序，而这些类在设计的时候没有考虑到要进行排序，那么这时候我们唯一的办法就是传递一个comparator的接口给他让他进行比较。 为什么代码会重排序？重排序的好处：提高处理速度 如何写一段简单的死锁代码？public class DeadLockDemo { public static void main(String[] args) { Object object1 = new Object(); Object object2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (object1) { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (object2) { } } }, \"deadlock-demo-1\"); t1.start(); Thread t2 = new Thread(() -&gt; { synchronized (object2) { synchronized (object1) { } } }, \"deadlock-demo-2\"); t2.start(); } } float f=3.4;是否正确？答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。 什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 我们可以在 hashcode() 中使用随机数字吗？ 为什么要有hashcode总结:如果一个对象 不往 与hash有关的集合中放 那么hashcode()方法 写不写无所谓, 否则必须写hashcode方法 ,hashcode能加快比较的速度 , equals 相等 hashcode 必须相等 hashcode不相等 equals 必不相等 因为如果两个对象相等，hashcode一定相同，不可能是个随机数 你所知道网络协议有那些？TCP/IP协议、UDP协议、HTTP协议、FTP协议、Telnet协议、SMTP协议、NFS协议等。 FTP：文件传输协议 SMPT：简单邮件协议 程序的结构有那些？由顺序结构、选择结构、循环结构 如何打破双亲委派模型自定义类加载器，重写loadclass方法。 linkedlist和arraylist的区别是什么1、数据结构不同 ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。 2、效率不同 当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。 当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。 3、自由性不同 ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。 4、主要控件开销不同 ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。 hashcode和equals如何使用hashcode冲突了，jdk1.7是采用链式继续存，这时候用equals比较 方法传参机制 string、包装类不可变性 例如上面的字符串s，它是指向与常量池，在传参后也是另一个方法也是指向与常量池。在另一个方法进行修改的时候，因为字符串的不可变性，它会产生一个新的字符串，然后把这个新的字符串重新赋值给这个参数，原来方法所指向的不变。（interger包装类也是一样的，它会产生一个新的，所以原来的不会改变，但注意interger 127这个范围） 成员变量与局部变量 作用域 布隆过滤器 布隆过滤器是一个二进制数组，只有0和1.在存储的时候根据多个hash函数计算位置，把对应位置改成1.判断的时候也是这样判断，要查到所有hash函数对应的都是1才存在 缺点 第一个缺点是误判，哈希冲突 第二个是不适合删除，因为可能多个映射到一个位置，删除的话是把对应值改成0，这样把其他的也删除了 优点 安全，都是0和1，谁也不晓得是啥 快，数组随机存储，快的一批 可重入锁指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，目的为了避免死锁 java泛型 java的static方法无法被重写 静态方法是无法被重写（Override）的，如果强行加上 @Override 注解，编译时会报错 “java: 方法不会覆盖或实现超类型的方法”。原因：重写的作用是为了父类和子类的相同签名的方法，具有不同的行为，从而实现了 多态 。但是静态方法是被类直接调用的，和对象无关，不存在父子类对象之间的相同方法不同行为，所以也没有多态。 子类可以直接调用父类的静态方法。虽说子类无法重写父类的静态方法，但是却可以直接调用父类的静态方法，调用方式是 子类名.父类静态方法() ，当然，也可以 **子类对象.父类静态方法()**，不过没必要，也不建议。 字符串创建对象个数面试题：String str4 = new String(“abc”) 创建多少个对象？ 在常量池中查找是否有“abc”对象 有则返回对应的引用实例 没有则创建对应的实例对象 在堆中 new 一个 String(“abc”) 对象 将对象地址赋值给str4,创建一个引用 所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用 根据字面量，往往会提出这样的变式题： String str1 = new String(“A”+”B”) ; 会创建多少个对象?String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象? str1：字符串常量池：”A”,”B”,”AB” : 3个堆：new String(“AB”) ：1个引用： str1 ：1个总共 ： 5个 str2 ：字符串常量池：”ABC” : 1个堆：new String(“ABC”) ：1个引用： str2 ：1个总共 ： 3个 运行时常量池和字符串常量池的区别常量池每个class一份，存在于字节码文件中。常量池中有字面量(数量值、字符串值)和符号引用(类符号引用、字段符号引用、方法符号引用)，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型 运行时常量池每个class一份，存在于方法区中(元空间)。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是下面的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。 字符串常量池每个JVM中只有一份，存在于方法区中(堆)。全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串（用双引号括起来的引用而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份 jdbc连接数据库的步骤是什么1、加载jdbc驱动程序； ​ 在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），这通过java.lang.Class类的静态方法forName(String className)实现。 2、创建数据库的连接； ​ •要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。​ •使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和密码来获得。 //连接MySql数据库，用户名和密码都是root String url = \"jdbc:mysql://localhost:3306/test\" ; String username = \"root\" ; String password = \"root\" ; try{ Connection con = DriverManager.getConnection(url , username , password ) ; }catch(SQLException se){ System.out.println(\"数据库连接失败！\"); se.printStackTrace() ; } 3、创建preparedStatement； •要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：1、执行静态SQL语句。通常通过Statement实例实现。2、执行动态SQL语句。通常通过PreparedStatement实例实现。3、执行数据库存储过程。通常通过CallableStatement实例实现。•具体的实现方式： Statement stmt = con.createStatement() ; PreparedStatement pstmt = con.prepareStatement(sql) ; CallableStatement cstmt = con.prepareCall(\"{CALL demoSp(? , ?)}\") ; 4、执行SQL语句；5、遍历结果集；6、处理异常，关闭JDBC对象资源。 threadLocal应用场景 链接数据库 hasmap扩容扩容容量扩容容量就是2倍，因为容量是2 的幂次方，扩容也是左移一位，例如16&lt;&lt;1 = 32 为啥用左移，不是乘法 主要是提升cpu性能，因为cpu是不支持乘法运算的，所有的运算会转换成加法，移位可以提高效率 理解 不指定，就是16，可以在构造函数指定，但会转化为2的幂数（3变4） 为啥要转换成2的幂数 为了末尾是1 由于哈希值是和长度-1进行取余 例如16是10000，减一后变成01111，这样取余可以。 但15如果不变成最近的2的幂数，则15对应的是01111，减一后变成01110，这样15（1111）和14（1110）取余后的结果是一致的，增加了冲突 参考 https://www.bilibili.com/video/BV1Yu411y7Jr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc 啥时候扩容负载因子和长度乘积决定 扩容死循环只在1.7版本有，因为采取了头插法 在多线程扩容下 如上图所示，如果在扩容的时候T2线程休眠，这时候T1进行扩容 扩容完成之后T2的节点和next节点会反过来，这时候T2在进行扩容，会形成死循环 如何解决 在1.8改成了尾插法，直接解决了 在1.7，可以使用 参考 https://www.bilibili.com/video/BV1oD4y1b7RF?p=2&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc 如何扩容（数据迁移）主要分为四个种类状态，节点是null，只有一个节点，有一个链，有红黑树 null 不用处理 只有一个节点 只有一个节点，说明没有发生冲突，直接迁移就行，根据新表长度计算出在新表的位置，然后放进去就行 只有一个链 说明发生了冲突，需要把当前这个链表拆分成两类，分为高位链和低位链 由于冲突成链了，所以这个链表中低位都是相同的（都是和长度-1计算出来的）（例如16，减一后变成01111，低位是后4位，高位是第五位，目前链表的低位一定是相同的，高位不一样，有的是0，有的是1） 对于高位是1的，到新表扩容肯定是变多了，是老表的位置加老表的size，因为高位1就是老表的长度。（例如，表长度是16，8的位置扩容后在新表的位置应该是8+16=24这个位置） 红黑树 也是高低位（以后再看）","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"中国党史","slug":"中共党史","date":"2020-03-14T16:00:00.000Z","updated":"2023-07-15T14:13:25.368Z","comments":true,"path":"posts/7a46f35i.html","link":"","permalink":"http://example.com/posts/7a46f35i.html","excerpt":"","text":"党史 青年杂志1915年陈独秀创办《青年杂志》，这是新文化运动。以鲁迅、胡适等，有两个口号，’德先生‘（民主）、’赛先生‘（科学）。（新文化运动是在前面的失败了操弄，比如戊戌变法、辛亥革命）（青年杂志把马克思主义传到中国，在这之前，并没有马克思主义） 陈独秀是《青年杂志的创办者》，实际发稿最多的是李大钊 最先提出“中国共产党”这个名称的是蔡和森 开眼看世界的第一人是林则徐 把马克思引入到中国的第一人是李大钊 《青年杂志》带来了马克思主义理论 十月革命列宁领导的 给中国带来了马克思主义实践 五四运动这是党史的开端 五四运动导火索是巴黎和会（第一次世界大战刚结束，中国是战胜国，小日本欺负人，逼迫中国签订21条不平等合约，包括把山东割地给小日本，当时北洋政府居然同意了，但国内老百姓不愿意，学生罢课，工人罢工，商人罢市）（工人就是无产阶级，这里说明无产阶级开始走向政治的舞台） 五四运动标志着无产阶级走向了历史的舞台 五四运动标志着旧民主主义革命的结束和新民主主义革命的开端 第一次世界大战导火索虎门销烟 上面四个日期是等差，这样记忆好记 会议重要会议9+8，共17次 （绿色重要，红色了解） 一大（重要）年月日都记 参会人员13名（代表50多名，当时只有这么多党员）（毛泽东在这13中，但当时没有发言的机会，只能记录） 标志着共产党的诞生 党的生日7月1号 二大立纲 最高（终极目标，到今天也是）：实现共产主义 最低（最低目标，首要目标）：制定反帝反封建纲领 三大国共合作（共产党没有军队，但是国民党有，所以合作，那时候国民党孙中山同意了） 袁世凯嗝屁了（老大嗝屁了，下面的都想当老大，所以天天打，嗷嗷叫） 国民党一大提出“新三民” 上面三大相当于共产党要约，这里是给了 联俄联共助农工 国共正式合作是这时候开始的（1924年） 当时合作方式是共产党员以个人名义加入国民党（又是共产党，又是国民党） 合作的目的是打北洋军阀，开始北伐，到1927年差不多干完了 国民党最后撕票了，孙中山去世，蒋介石和汪精卫掌权（汪精卫权大），蒋介石发动’四一二‘反革命（这里的主要目的是夺权，夺汪精卫的权，汪精卫后来不惜投靠小日本来干蒋介石，变成了中国第一大汉奸）（也是国共撕票），汪精卫发动’七一五‘反革命（他两个虽然是死对头，但共同的敌人是共产党，所以发动两个政变）开始暗杀共产党，危险（这时候党的领导人是陈独秀，他还想和国民党谈，再谈就灭团个去求了，所以后来不听他的了） 左倾和右倾（这是哲学中的质量互变，如果只看到质而忽略量，左倾。右倾是只看到量的积累，而忽略质。陈独秀是右倾，光想投降） 南昌起义上面说了陈独秀右倾，党内其他人（例如周恩来、朱德、贺龙）必须起义了，标志着军队的诞生 建军节就是8月1号，纪念这一天 打响了第一枪（打响国民党武装反抗）不服就干 周恩来、朱德、贺龙、叶挺、刘伯承（朱刘喝夜粥） 八七会议反右的会议，反对陈独秀右倾 毛主席发言了，枪杆里出政权 但是打不过啊，只能逃命，往农村逃，没吃的咋办，抢，抢地主的，这就来到了秋收起义 秋收起义打土豪、分田地，粮食带走，地没啥用，分给农民，土地归集体所有，集体所有制就这样诞生的 长征国民党对共产党的四次围剿都躲过去了，第五次没抗住，开始了长征。 这个时候领导人是王明，他是左倾（第五次他改防守为进攻，没攻出去，农村也待不住了，往山里逃命，往没人的地方逃，东北那边） 34年开始，36年会师，标志成功 湘江战役是长征以来最壮烈的一战 飞夺泸定桥也是一次重要战役 遵义会议1935年1月召开 反左的会议，确定了毛泽东的领导低位 标志着共产党走向了成熟 标志着第一次独立自主（之前也用，这次是独立自主，之前听有个共产国际的，否定了这群只会纸上谈兵的家伙）运用马列主义解决中国事情的会议 一二九运动1935年12月9号 1927-1937国共在内战 1931九一八小日本来了，主要干东北三省（习大大改这里，说抗日从这里开始的，也就是14年，到1945年抗日胜利） 这个时候国共还在内战（国民党还在追杀共产党，学生又看不下去了，这就是一二九运动） 学生游街示威了，要求国共两党停止内战，一致抗日 瓦窑堡会议共产生密切联系群众，会议上面的一二九了（没隔几天，都是1935年12月份） 第二次向国民党发送要约，国民党不愿意 到1936年，张学良和杨虎城看不下去了，发动西安事变，胁迫蒋介石停止内战 瓦窑堡会议是抗日统一战线 洛川会议是全面抗战路线 洛川会议1937年，会议通过了《抗日救国的十大纲领》 西安事变1936年12月12日 七七事变1937年小日本发动在北京卢沟桥事变 1937-45全面抗战时期（8年，以前书本写的是八年，但习大大改为14年，说1931-1937年虽然国共在内战没抗日，但东北在抗） 标志着抗日民族统一战线的正式达成 标志着日本全面侵华爆发 抗日战争胜利是在1945年8月15，9月2号签订投降书，9月3号被习大大命为抗日战争纪念日 淞沪会战（不重要）小日本从东北开始打，1937年七七事变，到10月份就打到上海了。这时候蒋介石发动74个师在这里和小日本干起来了（基本全面出动），为了转业自己的家业首都（这是首都在南京，也是小日本要去的地方） 国共合作后，共产党的部队收编到国民党中，比如新四军、八路军，但还是自己指挥自己。正面蒋介石打，游击共产党打 南京大屠杀1937年12月13日 淞沪会战蒋介石败了，小日本死了四W人左右，蒋介石死了30w左右，上海失手 德国拉贝记录了南京大屠杀 美国魏特琳，救了很多儿童，她挂上美国的国旗（小日本当时还害怕美国） 中共六届六中全会1938年9月 批判了王明的右倾投降主义, 马克思主义中国化（毛主席提出的） 刘少奇秒懂，所以马上开七大 中国七大这时候抗日快胜利了，可以同患难不能同富贵，所以先开个会 毛泽东思想诞生了 1945年4月 （这个是刘少奇组织召开的） 评价意义 评价意义是灯塔指引 一大的意义是开天辟地 遵义会议的意义是生死攸关 辽沈、淮海、平津战役这是共产党干国民党的，记住先后顺序就行 这里打完国民党大势已去，但毛主席没有乘胜追击，因为党内出现了问题 七届二中全会（重要）1949年 地点西柏坡 提出了两个务必，政治思想（别骄傲自满。务必保持戒躁急噪、谦虚谨慎，务必保持艰苦奋斗）（整顿思想） 第一个整顿党，党的自身建设 习大大也整治了，在十八届六中全会，提出全面从严治党 然后向南京开始进发，开始渡江战役(1949年4月21日胜利，4月23日南京解放) 三大改造在1949年10月1日建国的时候，是新民主主义国家，那时候觉得光无产阶级领导太小，就大家一起领导。是人民明主专政的社会主义国家 但我们的目标是社会主义，社会主义就是无产阶级领导的，所以要改造，消除其他（封建制度、私有制等）改造成公有制 1956年完成了 私有变成人民公社，这个时候才是社会主义社会 由于社会是从封建-资产阶级-社会主义，由于我们现在是社会主义，比较牛逼，所以毛主席认为可以跑得快，就出来了后面的大跃进（1956-1966年） 大跃进不行，毛主义一分析，觉得应该是队伍里有反动分子，影响了，所以立刻把知识分子剔除了队伍（文化大革命，都不要读书了，都去干活，踏实做事，消灭孔子，儒家思想，等知识忘干净了，在从头到尾学习马列主义、毛泽东思想）（1966-1976文化大革命失败） 1976年9月9号毛主席去世 1976年1月8号周恩来去世 十一届三中全会1978年12月 邓小平上台 1976-1978这两年邓小平并没有上台，不是很受拥戴（他资），后来上台是十大元帅之一叶剑英推选，大家都给叶帅一个面子。 这个会议拨乱反正，把党从阶级斗争转移到社会主义建设中来 改革开放 十一届六中全会关于党建设的若干问题 科学评价毛，七分功三分过 八个会议背诵 五年一开，2对双数大，7对单数大 进行换届选举，总结归纳 中国特色理论体系包括邓小平理论、三个代表、科学发展观 十四大主要搞市场经济，南方谈话 记忆：中国特色社会主义理论体系 中国特色社会主义 — 十二大邓小平提出 理论— 十三大邓小平理论（这个时候邓小平没这么说，他说是社会主义初级阶段和党在……）–十五大写入党章 体系 –十七大胡锦涛提出的 这个中国特色社会主义理论体系还包括三个代表（十六大写入党章）科学发展观（十八大写入党章）习大大思想（十九大写入党章） 三个代表思想是十三届四中全会形成的 会议小节 会议 十九大习近平中特 积累对民主资产阶级和平赎买、四马分肥（国家一份、资本家一份、企业一份、企业员工一份） 红船精神开天辟地、敢为人先的首创精神 鉴定信念、百折不挠的奋斗精神 立党为公、忠诚为民的奉献精神 南泥湾精神自力更生、艰苦奋斗 三会一课“四党” 支部党员大会、党支部委员会、党小组会，党课 中华苏维埃第一次全国代表大会在瑞金召开 三重一大重大事项决策、重要干部任免、重要项目安排、大额资金的使用，必须经过集体讨论做决定 新发展格局内涵：构建以国内大循环为主题，国内国际双循环相互促进的新发展格局 关键：经济循环畅通无阻 本质特征：高水平的自立自强 马克思主义阶级基础无产阶级作为一支独立的力量登上了历史舞台 《改造我们的学习》文中详细地解释了“实事求是的内涵”，他认为马克思主义和中国国情相结合就是实事求是的态度。“墙上芦苇，头重脚轻根底浅；山间竹笋，嘴尖皮厚腹中空。”（贬义对联，形容傲娇自满的人，不扎实做事，偏好虚名浮事；嘴上浮夸刻薄，而肚子里没有学问和真功夫。）讽刺了主观主义学风 党员预备党员到党员 考察期是一年 延长考察期不能超过一年 党的思想路线一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理 五位一体包括：经济建设、政治建设、文化建设、社会建设、生态建设 五位一体是对国家来说的，这里是经济建设最重要。全面从严治党是从党来说的，政治建设最重要 社会主义主要矛盾随着去国社会主义矛盾的变化，我国社会主义一变三不变 一变：人民日益增长的美好生活的需要和不平衡不充分发展之间的矛盾 两不变：我国仍然长期处于社会主义初级阶段的基本国情没有变 ​ 我国是世界上最大发展中国家没有变 低碳经济低排放、低耗能、低污染 延安整风改造—整顿—反对 改造我们学习标志着开始 基础知识六大在莫斯科召开 一国两制，爱国者治港 香山是进京赶考的第一站 党的生死攸关转折点遵义会议 中华名族生死攸关转折点是抗日战争胜利 党的基层组织是党在社会基层中战斗堡垒 党的纪律必须严于国法，根本原因在于中国共产党的先进性 生产工具是衡量生产力发展水平的重要标志 井冈山是1927年的第一个农村根据地，他不是抗日的时候，是国共内战的时候，也可以说是土地革命时期 新时代的东西生态文明尊重自然是首要态度 保护自然是重要责任 顺应自然是基本原则 新发展格局 内涵 什么是新发展格局？ 构建国内大循环为主体，国内国际双循环相互促进的新发展格局 关键 经济循环畅通无阻 本质特征 高水平的自立自强 中国式现代化的五个重要特征（未来要实现的方向）人口规模巨大 全体人员共同富裕 物质文明和精神文明相协调 人与自然和谐共生 走和平发展道路 四个伟大19大习大大提出的 伟大梦想（中国梦） 伟大事业（中特事业） 伟大工程（党的建设） 伟大斗争（矛盾） 其中，伟大的工程是主体力量，（火车快不快，全靠车都带，这里的伟大工程是党） 中国共产党近一百年来全心全意为人民服务（宗旨） 实现中华名族伟大复兴（一切奋斗、一切牺牲，归结起来的 主题）（比较大，正确选项可能性大） 实现共建共治共享（社会治理） 中国精神 民族精神 爱国主义（始终把中华名族团结在一起） 时代精神 改革创新（始终鞭策我们改革开发、与时俱进） 民主党派四民二公，三九胃泰 背下来法——保障 党–保证 依法治国–重要保障 从严治党–政治保证 深化改革–动力源泉 建设社会主义现代化国家–战略目标 我国经济从高速增长到高质量发展 建设现代化经济必须重心放到实体经济中来","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"反射","slug":"反射","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:31:23.836Z","comments":true,"path":"posts/7f1ae6fg.html","link":"","permalink":"http://example.com/posts/7f1ae6fg.html","excerpt":"","text":"动态语言和静态语言动态语言是在运行的时候可以改变其结构的语言，比如说c#、javascript、PHP、Python等 静态比如说C、JAVA、C++ java不是动态语言，但java可以有一定的动态性，可以通过反射机制获得类似动态语言的特性，让编程更加灵活。 反射java reflection 反射获得类的class对象三种方式若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 Class clazz = Person.class; 已知某个类的实例，调用该实例的getClass()方法获取Class对象 Class clazz = person.getClass(); 已知一个类的全类名，且该类在路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException static Class&lt;?&gt; aclass = Class.forName(\"绝对路径\"); 内置基本类型可以通过类名.Type(例 Integer、Long) 还可以利用ClassLoader 哪些类型有可以有class对象？ Object //类 Comparable //接口 String[] //一维数组 int[] [] // 二维数组 Override //注解 ElementType //枚举 Integer //基本数据类型 void //void Class //class 快捷键alt可以竖着复制多行，方便快捷 要遍历的时候直接（遍历对象）.for 类加载 什么时候类会初始化 执行过程 通过反射能够获取到什么 package com.text; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.concurrent.atomic.AtomicInteger; public class test32 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //获取Class类 Class&lt;?&gt; c1 = Class.forName(\"com.text.Animal\"); //获取类名 System.out.println(\"--------------------获取类名--------------------\"); System.out.println(\"类名\" + c1.getSimpleName()); System.out.println(\"包名+类名:\" + c1.getName());//包名+类名 //获取类的属性 System.out.println(\"--------------------获取类的属性--------------------\"); Field[] fields = c1.getFields();//只能获取公共的字段表示属性 Field[] declaredFields = c1.getDeclaredFields();//获取所以的字段属性(包括私有的等等) for (Field declaredField : declaredFields) { System.out.println(declaredField); } //获取指定属性的值 System.out.println(\"--------------------获取指定属性的值--------------------\"); Field name = c1.getDeclaredField(\"name\"); System.out.println(name); //获取方法 System.out.println(\"--------------------获取类的方法--------------------\"); Method[] declaredMethods = c1.getDeclaredMethods();//获得本类全部方法(无关修饰符) Method[] methods = c1.getMethods(); //获得本类及父类的全部public方法 for (Method method : declaredMethods) { System.out.println(method); } //获取指定方法 System.out.println(\"--------------------获取指定方法--------------------\"); Method getNames = c1.getMethod(\"getName\", null); System.out.println(getNames); //获取Class全部的公有构造方法 System.out.println(\"---------------------获取所有公共的构造函数---------------------\"); Constructor&lt;?&gt;[] constructors = c1.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) { System.out.println(constructor); } //获取Class全部的构造方法 System.out.println(\"---------------------获取所有全部的构造函数(包括：公共的,默认的,受保护的,私有的)---------------------\"); Constructor&lt;?&gt;[] declaredConstructors = c1.getDeclaredConstructors(); for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) { System.out.println(declaredConstructor); } //获取公共构造方法v System.out.println(\"---------------------获取公共无参构造方法---------------------\"); Constructor&lt;?&gt; constructor = c1.getConstructor(null);//这里必须是一个参数类型的class,默认为null System.out.println(constructor); Object o = constructor.newInstance();//调用构造方法 // System.out.println(\"o:\"+o.toString()); // User user=(User)o; // user.user2(); //获取私有构造放 System.out.println(\"---------------------获取私有构造方法---------------------\"); Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(int.class); System.out.println(constructor); declaredConstructor.setAccessible(true); Object test = declaredConstructor.newInstance(123); System.out.println(test); //获取指定构造方法 System.out.println(\"---------------------获取指定构造方法---------------------\"); Constructor&lt;?&gt; declaredConstructor1 = c1.getDeclaredConstructor(int.class, String.class); System.out.println(declaredConstructor1); } } class Animal { private int age; private String name; public Animal() { } //这个是测试 private Animal(int a){ } private void test() { System.out.println(\"私有方法\"); } public Animal(int age, String name) { this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Animal{\" + \"age=\" + age + \", name='\" + name + '\\'' + '}'; } } class Dog extends Animal { private String name; public Dog() { this.setName(\"小狗\"); this.setAge((int) (Math.random() * 7)); } } class Cat extends Animal { public Cat() { this.setName(\"猫\"); this.setAge((int) (Math.random() * 7)); } } 反射创建对象 package com.text; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; public class test34 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { //1.创建class对象 Class&lt;?&gt; c1 = Class.forName(\"com.text.personnel\"); //2.获取构造方法 Constructor&lt;?&gt; declaredConstructor = c1.getDeclaredConstructor(); //3.通过构造方法new类(这里知道是什么类就可以强行转换了) personnel o = (personnel)(declaredConstructor.newInstance()); //4.这里获取字段(也可以获取方法全看需要) Field id = c1.getDeclaredField(\"id\"); //5.因为是私有的属性所以关闭安全检测 id.setAccessible(true); //6.设置属性，参数是(设置属性的对象,属性值) id.set(o,\"1234\"); //7.查看调用方法查看是否设置成功 System.out.println(o.getId()); } } //账号类 class personnel{ private String id; private String password; public String getId() { return id; } public String getPassword() { return password; } }","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"哲学","slug":"哲学","date":"2020-03-14T16:00:00.000Z","updated":"2023-07-09T23:21:48.187Z","comments":true,"path":"posts/7a46f35t.html","link":"","permalink":"http://example.com/posts/7a46f35t.html","excerpt":"","text":"哲学概述哲学研究世界，主要分为自然界和人类社会，人类社会主要有认识世界（停留在思考）和改变世界，认识世界又分为世界观和方法论 世界观 主要解决世界是什么的问题（从哪里来，水来还是其他？上帝创造？） 方法论 怎么做的问题，用什么样的方式去处理问题 每个人都有自己的世界观和方法论，但一门学科需要统一，这时就出现了哲学，它是系统化的世界观和方法论。但不能说它是科学的（因为哲学很多，在我们国家，只有马克思哲学才称为科学的） 世界观和方法论关系 世界观决定方法论，方法论体现世界观 一个人对世界的看法就决定了它做事情的基本方法，通过这个人解决问题的方法就可以体现这个人的世界观。比如一个人世界观认为世界是上帝创建了，人不能改变世界，听天由命，这样在做事的时候就会摆烂。反过来老摆烂，可以体现出世界观。 哲学是科学的？ 不对，只有马克思主义哲学才是科学的 哲学与具体科学的关系一般与特别，共性和特性的关系 比如物理学就是研究物理的，社会学就是研究社会的。但哲学是它们的概括，都有涉及到，范围广，研究是是共性 联系 哲学是以具体科学得成果为基础。比较好理解，因为哲学是共性，抽取其他自然科学的 哲学又为具体科学提供了引导（一般性的指导）（比如说你认为世界是物质的，这样就不用烧香拜佛了） 哲学的基本问题思想和存在（精神与物质） 基本问题是恩格斯提出的 第一性是先有谁的问题，先有物，就是唯物。 同一性就是思维能不能认识存在。比如你面前有个电脑，你看到它能不能知道它的用途等信息，能就是可知，反之不可知论 唯物主义古代朴素 注意 出现荀子、范镇……，八成是古朴 缺点 太直观了，靠感觉，靠猜测。觉得啥重要啥就是本源 形而上学认为是由原子和分子组成 缺点 机械性：认为人和机器一样，也是由零部件组成 形而上学：看到一课树，说这是树，看到一堆树，还说是树，明显是森林。这是看待问题片面（盲人摸象）。静止的眼光看问题（刻舟求剑） 老马是用联系、发展、前面的眼光看问题。 不彻底性：在自然领域是唯物的（比如问先见山后了解还是先了解后见山，他回答是先见山后了解（这里是唯物没问题）），但在社会领域不行（比如说，人类历史是谁创建的，形而上学认为是伟人、英雄或者神。老马认为是人民群众） 唯心主义主观唯心 与人有关 客观唯心（比如老子的道） 秒杀 马克思主义 组成 产生 其中，德国古典哲学是马哲的直接来源 黑格尔提供了辩证法（黑格尔是唯心主义） 费尔巴哈提出了唯物论 科学依据 进化论是达尔文提出 基本特征 马克思墓在伦敦 老马为啥科学，因为他与时俱进 一元论 世界本原有几个，有一个就是一元论，两个就是二元论 唯物论讲的物质是什么 物质物质的唯一特性：客观实在性（不以人的意志而转移） 物质是列宁提出的 物质怎样存在 物质的存在形式和根本属性是运动（有变化就是运动） 物质运动的存在形式是时间和空间 社会运动最复杂 物质和运动关系 世界上所有的物质都是运动的 离开运动谈物质，形而上学（刻舟求剑） 反过来，唯心（比如风吹的帆动，老和尚认为不是风动，也不是帆动，是心在动） 静止 动是绝对的，无条件的。静是相对的，有条件的。 静中有动，动中有静 否认运动，形而上学 否认静止，诡辩论（借钱不还，方生方死，太阳永远不会在正中央那一刻） 意识 产生条件 无生命物质比如化学反应 只有人有意识，要有人脑，但狼人不是，它虽然有人脑，但没有社会活动 人脑是产生意识的器官，但不是意识的源泉，客观世界才是源泉。（大脑不是产生意识的器官） 人的意识可以能动的认识世界（鸟–飞机，鱼–潜艇） 本质 是人脑对客观存在的主观映像 内容是客观的，形式是主观的 物质与意识物质决定意识 巧妇难为无米之炊（体现了米的重要性） 物质第一性，客观规律第一性 方法论 主观符合客观一般考政策，比如国家推选垃圾分类，先看看实用不 辩证法讲的物质是怎样存在的 两大特征普遍联系和永恒发展 联系 运气是违背联系客观性的，封建迷信也是，属相不和、喜鹊报喜，乌鸦报丧、666、888 普遍性：冒起不沾边的也有联系。比如蝴蝶效应、6度空间、唇亡齿寒、城门失火，殃及池鱼、连锁反应 整体和部分 发展 发展是不能只看眼前，要看的远 三大规律 质量互变 要把握时机 拔苗助长，学习也得劳逸结合 对立统一 相互依存，比如你的丑衬托出我的美，丑美依存 相互转化，比如整容了，从丑变美，转换（考试重点，反义词相互转换） 事物发展的源泉是内部矛盾 相互转化的词 内外因 创新属于内因 外因是条件，外因通过内因起作用 矛盾特征 主要矛盾和次要矛盾 多个矛盾，怎么做 主要方面与次要方面 单个矛盾，怎么看 否定之否定扬弃了两次 记住，否定之否定最后的落脚点是好的，经历了肯定、否定、否定之否定 五队范畴 讲课准备的充分，滔滔不绝。反之，磕磕绊绊（内容决定形式） 电闪雷鸣不是，四季交替也不是 吃的多导致肥胖是 可能性，比如说考试，每个人都可能考上，但现实惨目忍睹。 守株待兔 认识论我们能不能认识客观存在这个物质 实践 蜜蜂筑巢不是，必须是人 生产实践是最基本的，也是其他实践的基础和前提（民以食为天，填饱肚子再说其他的） 科学实验起到杠杆作用 认识 感性认识 感觉：比如你买衣服，看到后感觉如何 知觉：摸摸，看看料子怎么样，穿上试试 表象：比如一说香蕉，就能回忆起来长啥样 理性认识 感性和理性的关系 感性和理性相互包含、相互渗透。是同时存在的（比如，你看你就是卷王。这里看是感性，卷王被定义了，是理性） 第二次更加重要，因为理论是指导实践的 第二次飞跃的桥梁是表象（透过现象看本质） 实践和认识的关系 真理 内容是客观，形式是主观的 比如你说三角形内角和不是180，这是谬论。但在球面上就符合了，变成了真理，可以相互转化 认识的本质是主题对客体的反映（不是实践，实践决定认识） 历史唯物主义人民群众创造历史，不是杰出人物 社会存在 低碳出行（这就是社会存在决定社会意识，先是车太多了，才弄这个）计划生育也是 生产力是人类改造自然行不行，是人和自然的关系，是衡量社会进步的尺度 生产工具可以看出发展好不好 生产关系是人与人之间的，比如你卖货，我买货 所有制是基础，我国的所有制是公有制 要适应，先进生产关系促进生产力这是错的，适应才行 经济基础：我们国家公有制为主题，多种所有制总和。这个总的就是经济基础 关系 人民群众 所有人都是历史主题，是错误的。还有敌人呢 人民群众创造历史不能随心所欲，受制约的 补充现象和本质现象是外表直接看出来的，比如说水往低处流等 本质是添加上人的思维，深刻的认识 真象和假象 现象的两种表现形式，真象就是真实的（比如水往低处流），假象是歪曲的（比如月亮有光） 真象和假象都是现象，都可以反映事物的本质 假象和错觉 不一样，假象是客观存在的（你看到月亮亮的），错觉是个人的感觉（比如人家看了你一眼，你就觉得人家喜欢你） 马克思主义基本原则价值原则（为全世界大多数人谋利） 认识原则（实事求是） 理论原则（实践） 整体和部分整体居于主导低位统帅部分（不谋全局、不足某一略） 关键部分对整体起决定性作用（一步错，满盘皆是） 整体是各个部分的有机结合，整体具有部分没有的新功能（钟表） 注意 整体功能大于部分之和（这说法是错的，大于和不大于看具体情况，有序的大于，无序的小于） 事物发展事物发展的道路是前进和曲折性的统一 事物发展的总趋势是前进的","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"算法思想","slug":"算法","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:41:17.394Z","comments":true,"path":"posts/7f1ae6sf.html","link":"","permalink":"http://example.com/posts/7f1ae6sf.html","excerpt":"","text":"搜索二叉树遍历数组重建树 最后得节点是整棵树得头，然后想着左右树建立出来，搜索左边小右边大无重复值 （进阶：不需要一直遍历，可以二分） （无序怎么二分？这个我们可以分后与最后一个节点比较，看他大概在哪个区间。毕竟有这样一个简单得规律，后面一大堆比前面一大堆大） 左小右大，直接与根节点（最后一个节点）比较就行了 怎么确立左右树呢，一样得道理 复杂的（遍历得最差是o（n^2）（什么时候最差，单支，每一层都遍历，共n层），二分得最差是o(nlogn)） 前缀树 代码里每个节点有pass代表经过几次，还有end代表是不是结尾。 查询的时候只需要从上往下查，怎么加入的就怎么查，看end有没有 根节点的pass代表着一共多少字符串，根节点end代表空串数量 package class07; public class Code01_TrieTree { public static class TrieNode { public int path; public int end; public TrieNode[] nexts;//这个是用数组代表路，如果字符种类特别多，那可以用hash表 public TrieNode() { path = 0; end = 0; nexts = new TrieNode[26]; } } public static class Trie { private TrieNode root; public Trie() { root = new TrieNode(); } //插入 public void insert(String word) { if (word == null) { return; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { node.nexts[index] = new TrieNode(); } node = node.nexts[index]; node.path++; } node.end++; } public void delete(String word) { if (search(word) != 0) { char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (--node.nexts[index].path == 0) { node.nexts[index] = null; return; } node = node.nexts[index]; } node.end--; } } //查找加入的次数 public int search(String word) { if (word == null) { return 0; } char[] chs = word.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { return 0; } node = node.nexts[index]; } return node.end; } //查有多少字符串以***作为前缀 public int prefixNumber(String pre) { if (pre == null) { return 0; } char[] chs = pre.toCharArray(); TrieNode node = root; int index = 0; for (int i = 0; i &lt; chs.length; i++) { index = chs[i] - 'a'; if (node.nexts[index] == null) { return 0; } node = node.nexts[index]; } return node.path; } } public static void main(String[] args) { Trie trie = new Trie(); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuo\"); trie.insert(\"zuo\"); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.delete(\"zuo\"); System.out.println(trie.search(\"zuo\")); trie.insert(\"zuoa\"); trie.insert(\"zuoac\"); trie.insert(\"zuoab\"); trie.insert(\"zuoad\"); trie.delete(\"zuoa\"); System.out.println(trie.search(\"zuoa\")); System.out.println(trie.prefixNumber(\"zuo\")); } } 贪心在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到 一个答案的算法，叫作贪心算法。 也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解 例题1一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数 组，里面是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。 返回这个最多的宣讲场次 思考 我们先想按时间最早分配，显然，如果有一个项目最早开始，但贯穿一天，这种策略不行。然后考虑按时间最短分配，经过思考，也不行，比如下面中间的最短，但是他的开始时间和结束时间卡住了其他 最后我们按照结束时间最早分配，每次把不符合的给删除（因为我们的目的就是数量最多） 代码 package class07; import java.util.Arrays; import java.util.Comparator; public class Code04_BestArrange { public static class Program { public int start; public int end; public Program(int start, int end) { this.start = start; this.end = end; } } public static class ProgramComparator implements Comparator&lt;Program&gt; { @Override public int compare(Program o1, Program o2) { return o1.end - o2.end; } } public static int bestArrange(Program[] programs, int start) { Arrays.sort(programs, new ProgramComparator()); int result = 0; for (int i = 0; i &lt; programs.length; i++) { if (start &lt;= programs[i].start) { result++; start = programs[i].end; } } return result; } public static void main(String[] args) { } } 例题2给一个字符串数组，然后进行拼接成一个，要求拼接后的字典序最小 思考 每次都把最小字典序的字符串放前面，经过举例这个不对，例如。b的字典序小于ba，如果谁小谁在前，那么是bba，但是很明显bab更小。 代码 package class07; import java.util.Arrays; import java.util.Comparator; public class Code02_LowestLexicography { // 定义一个比较器，比较策略 public static class MyComparator implements Comparator&lt;String&gt; { @Override public int compare(String a, String b) { return (a + b).compareTo(b + a); } } public static String lowestString(String[] strs) { if (strs == null || strs.length == 0) { return \"\"; } //怎么比较排序，自己定义下 Arrays.sort(strs, new MyComparator()); String res = \"\"; for (int i = 0; i &lt; strs.length; i++) { res += strs[i]; } return res; } public static void main(String[] args) { String[] strs1 = { \"jibw\", \"ji\", \"jp\", \"bw\", \"jibw\" }; System.out.println(lowestString(strs1)); String[] strs2 = { \"ba\", \"b\" }; System.out.println(lowestString(strs2)); } } 例3 哈夫曼树解决 例题3 给一堆项目，有他的花费和利润，然后你有启动资金去投资它，怎么获利最大 解题思路： 如上面所示，先建立一个小根堆，这个小根堆按照所需投资钱数排，它的目的是根据我们的启动资金找出可以投资哪些项目。然后再建立一个大根堆，根据小根堆筛选出来的放进大根堆，大根堆按照利润排序，毕竟在钱够的情况下做利润大的，得到利润的钱后，在去小根堆瞅瞅哪些现在可以做了，筛选出来放大根堆，以此类推 package class07; import java.util.Comparator; import java.util.PriorityQueue; public class Code05_IPO { public static class Node { public int p; public int c; public Node(int p, int c) { this.p = p; this.c = c; } } //小根堆比较器 public static class MinCostComparator implements Comparator&lt;Node&gt; { @Override public int compare(Node o1, Node o2) { return o1.c - o2.c; } } //大根堆比较器 public static class MaxProfitComparator implements Comparator&lt;Node&gt; { @Override public int compare(Node o1, Node o2) { return o2.p - o1.p; } } //w是启动资金，k是最多处理几个项目 public static int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) { Node[] nodes = new Node[Profits.length]; for (int i = 0; i &lt; Profits.length; i++) { nodes[i] = new Node(Profits[i], Capital[i]); } //定义堆，通过比较器来看大小 PriorityQueue&lt;Node&gt; minCostQ = new PriorityQueue&lt;&gt;(new MinCostComparator()); PriorityQueue&lt;Node&gt; maxProfitQ = new PriorityQueue&lt;&gt;(new MaxProfitComparator()); //所有节点放在小根堆里 for (int i = 0; i &lt; nodes.length; i++) { minCostQ.add(nodes[i]); } for (int i = 0; i &lt; k; i++) { while (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) { maxProfitQ.add(minCostQ.poll()); } //剩下的都做不了了，提前 if (maxProfitQ.isEmpty()) { return W; } W += maxProfitQ.poll().p; } return W; } } 动态规划 啥是动态规划 空间换时间 如何你发现计算中有重复的部分，就把重复的给记录下来，下次不用重复算","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"集合常用api","slug":"集合常用api","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T12:39:05.068Z","comments":true,"path":"posts/7f1ae6ui.html","link":"","permalink":"http://example.com/posts/7f1ae6ui.html","excerpt":"","text":"String获取功能1）length():获取字符串的长度，其实也就是字符个数2）charAt(int index):获取指定索引处的字符 3）indexOf(String str):获取str在字符串对象中第一次出现的索引4）substring(int start):从start开始截取字符串5）String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end 判断功能1）equals(Object obj):比较字符串的内容是否相同 2）isEmpty()：判断指定字符串是否为空 3）compareTo(String anotherString)：比较字符串的大小，前者大返回整数，后者大返回负数，相等返回0 转换方法1）toCharArray():把字符串转换为字符数组 2）toLowerCase():把字符串转换为小写字符串 3）toUpperCase():把字符串转换为大写字符串 其他方法1）replace(char oldChar, char newChar)：将指定字符替换成另一个指定的字符 2）replaceAll(String regex,String replasement)：用新的内容替换全部旧内容 replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\\d”, “*”)把个字符串所有的数字字符都换成星号; String src = new String(\"ab43a2c43d\"); System.out.println(src.replace(\"3\",\"f\"));=&gt;ab4f2c4fd. System.out.println(src.replace('3','f'));=&gt;ab4f2c4fd. System.out.println(src.replaceAll(\"\\\\d\",\"f\"));=&gt;abffafcffd. 3）replaceFirst(String regex,String replacement)：替换首个满足条件的内容 4）contains(CharSequence s)：查看字符串中是都含有指定字符 hashmap1：put方法：put(key，value)，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。 2：get方法：get(key)，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。 3：remove方法：remove(key)，主要用来删除map中对应的key及其value值。 4：clear方法，用法：clear()，会清空map中的数据。 5：containsKey(key)，判断map集合中是否包含某个key。 6：containsKey(value)，判断map集合中是否包含某个value。 7：entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。 8：keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。 TreeMap构造方法 TreeMap()：创建一个空TreeMap，keys按照自然排序 TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(); TreeMap(Comparator comparator)：创建一个空TreeMap，按照指定的comparator排序 TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(Comparator.reverseOrder()); map.put(3, \"val\"); map.put(2, \"val\"); map.put(1, \"val\"); map.put(5, \"val\"); map.put(4, \"val\"); System.out.println(map); // {5=val, 4=val, 3=val, 2=val, 1=val} TreeMap(Map m)：由给定的map创建一个TreeMap，keys按照自然排序 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, \"val\"); ... TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;(map); TreeMap(SortedMap m)：由给定的有序map创建TreeMap，keys按照原顺序排序 常用方法V put(K key, V value)：将指定映射放入该TreeMap中 void clear()：清空TreeMap中的所有元素 V remove(Object key)：从TreeMap中移除指定key对应的映射 V replace(K key, V value)：替换指定key对应的value值 boolean containsKey(Object key)：判断该TreeMap中是否包含指定key的映射 boolean containsValue(Object value)：判断该TreeMap中是否包含有关指定value的映射 Set&lt;Map&lt;K, V&gt;&gt; entrySet()：返回由该TreeMap中的所有映射组成的Set对象 int size()：返回该TreepMap中包含的映射的数量 遍历方式 for循环 for (Map.Entry entry : treeMap.entrySet()) { System.out.println(entry); } 迭代器循环 Iterator iterator = treeMap.entrySet().iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 自定义比较器Map&lt;Integer, Object&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); map.put(5, new Object()); map.put(10, new Object()); map.put(8, new Object()); map.put(12, new Object()); System.out.println(map); ArrayList1、add(Object element) 方法add(Object element) 方法用于向ArrayList集合中的添加元素。 2、size() 方法size()方法用于返回ArrayList集合中元素个数 3、get(int index) 方法get(int index)方法用于返回集合中对应位置的元素 4、add(int index, Object element) 方法add(int index, Object element) 方法用于在集合指定位置添加元素，原集合中从指定位置开始的元素全部后置 5、set(int i, Object element) 方法set(int i, Object element) 方法用于将索引i位置元素替换为元素element并返回被替换的元素 6、clear() 方法clear() 方法用于清空集合中元素 7、isEmpty() 方法isEmpty() 方法用于判断集合容器是否为空，如果为空，则返回true，否则返回false。 8、iterator()iterator（）不是一个方法而是一个用于返回按适当顺序在列表的元素上进行迭代的迭代器可以用它遍历集合元素 9、contains(Object o) 方法contains(Object o) 方法用以判断集合容器中是否含有指定元素，有返回值，且为boolean型。 10、remove(int index) 方法remove（int index）方法用于移除列表中指定位置的元素，并返回被删元素 11、remove(Object o) 方法remove(Object o) 方法用于移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。 转字符串数组方法一、 String[] arr = new String[list.size]; list.toArray(arr);//此时arr就有了list中的值了` 方法二、 String[] arr = (String[])list.toArray(new String[0]);` 构造方法List&lt;String&gt; list3 = new ArrayList&lt;&gt;(list2); List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); //构造一个具有指定初始容量的空列表。 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(6); StringBufferStringBuffer对象的初始化StringBuffer s = new StringBuffer(); StringBuffer s = new StringBuffer(“abc”); StringBuffer对象和String对象之间的互转String s = “abc”; StringBuffer sb1 = new StringBuffer(“123”); StringBuffer sb2 = new StringBuffer(s); //String转换为StringBuffer String s1 = sb1.toString(); //StringBuffer转换为String 常用方法1、append方法StringBuffer sb = new StringBuffer(); String user = “test”; String pwd = “123”; sb.append(“select * from userInfo where username=“) .append(user) .append(“ and pwd=”) .append(pwd); 这样对象sb的值就是字符串“select * from userInfo where username=test and pwd=123” 2、deleteCharAt方法该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字 StringBuffer sb = new StringBuffer(“Test”); sb. deleteCharAt(1); 该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变为”Tst” 3、delete方法public StringBuffer delete(int start,int end) StringBuffer sb = new StringBuffer(“TestString”); sb. delete (1,4); 4、insert方法public StringBuffer insert(int offset, boolean b) StringBuffer sb = new StringBuffer(“TestString”); sb.insert(4,false); 该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"秋招","slug":"面","date":"2020-03-14T16:00:00.000Z","updated":"2023-06-04T03:43:11.542Z","comments":true,"path":"posts/7f1ae999.html","link":"","permalink":"http://example.com/posts/7f1ae999.html","excerpt":"","text":"秒杀测试jmeter 请求组 http请求 结果在监听器显示 redis引入redis setIfAbsent 和 setnxsetIfAbsent 是java中的方法setnx 是 redis命令中的方法 BoundValueOperations boundValueOperations = this.redisTemplate.boundValueOps(redisKey); flag = boundValueOperations.setIfAbsent(value); // flag 表示的是否set boundValueOperations.expire(seconds, TimeUnit.SECONDS); if(!flag){ // 重复 repeatSerial.add(serialNo); continue; }else{// 没有重复 norepeatSerial.add(serialNo); } 问题 b线程释放a线程的锁 可以在value随机值，然后删的时候判断一下还是原来的随机值吗，但是这个是一个过程，先查是不是原来的，再删，这不是一个原子操作。用lua脚本、 如何用lua 可以在服务器写好，然后调用，优点是方便，但是修改了或者调用有资源消耗了 在java代码里直接写麻烦 java代码里写 先在resources中创建一个lock.lua（要和application.yml同级目录） 在测试 threadlocal和synchronized区别 threadlocal原理 spring bean生命周期1.创建前准备，比如调用工厂的后置处理器2.对象实例化，根据bean定义，找到类信息，使用反射创建对象（默认用无参构造，如果没有无参(有一个有参，则用有参；如果有多个有参，报错)（有参参数是在spring容器里面找，先bytype后byname）） 3.对象属性装填，装填成员变量，如果成员变量有其他bean，则加载其他bean（比如autoware resource这些）4.执行初始化，某些对象可能有初始化方法，在此时调用 5.销毁 首先初始化，因为spring容器中都是存放的一个个对象。这个初始化是用反射创建，默认使用无参构造，（如果没有看上面）。然后对对象进行属性填充（依赖注入），比如autowire、resource等。然后某些对象可能有初始化方法，比如实现initiallizingbean方法，实现afterproperitiesset进行初始化。然后判断是否存在aop切入点，如果有，则创建aop代理类，放进spring容器里的也是aop代理类。最后销毁。 单例bean和单例模式不是一回事 spring事务加这样一个注解 数据库表设计规范 字段 加注释 3范式 建议有创建时间和修改时间 固定的用char 线程同步的四种方式一，什么是线程同步和互斥 同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！ 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。 解决 方法一：使用synchronized关键字 方法二：wait和notify 线程间通信的几种实现方式方式一：使用 volatile 关键字 方式二：使用Object类的wait() 和 notify() 方法 Session的执行流程浏览器发起一个请求到服务器，服务器先检查是否携带了一个叫做JSEESIONID的Cookie。 如果有携带，会将此cookie值取出来（比如abc），然后从服务器的session池中找到ID为abc的session返回给调用者。如果没有携带JSESSIONID 这个Cookie，服务器就会自动创建一个session对象并且生成一个随机字符串（abc）作为此sessionID保存到session池中，在服务器为客户端响应时会自动创建一个键为“JSESSIONID”，值为“abc”的cookie对象让浏览器存储起来，以便下次访问的时候带着 怎么看走没走索引 解释Explain得到的结果 type 反应查询语句的性能我们主需要注意一个最重要的的 type 的信息很明显地体现出是否用到了索引： type 结果值从好到坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 一般来说，得保证查询至少达到 range 级别，最好能达到 ref 级别，否则就可能出现性能问题。 解析 反映用什么样的方式查询数据的 possible_keys: SQL查询时用到的索引。可以看到，没加索引时，possible_keys 的值为 NULL，加了索引后的值为 address，即用到了索引address(索引默认为(column_list)中的第一个列的名字). key 显示SQL实际决定查询结果使用的键(索引)。如果没有使用索引，值为NULL可以看到，没加索引时，key 的值为 NULL，加了索引后的值为 address，即决定查询结果用到了索引address rows 显示MySQL认为它执行查询时必须检查的行数可以看到，没加索引时，rows 的值为17，即数据表student中所有数据，说明没加索引时的SQL查询是全表扫描； 加了索引后，rows 的值为6，数据库表中address以“北京市”开头的一共也就6条，SQL在执行查询操作时，一共也检查了6行，不必进行全表扫描查询，可以很容易得出结论：加索引的SQL查询性能远高于不加索引的情况。 5）extra 模糊查询不走怎么解决 通过业务手段避免，举个实际栗子，博主之前做了一个汽车仓储项目，需求要求汽车表查询时候，车架号要有模糊查询操作，但是实际上对于车架号这个东西有个特殊的业务属性，就是车架号的后六位，基本可以在全省锁定到某一台车，全国不会超过三台车。所以业务人员在实际使用系统的时候，也只是输入后六位进行模糊查询，因此，在表设计的时候就将车架号字段冗余了一个字段，用于存储倒序的车架号，在进行模糊查询的时候，使用这个倒序字段进行右模糊查询，从而达到走索引的目的。有些时候，通过业务手段是可以达到一个优化要求的。 内连接 解决地址https://www.cnblogs.com/Marydon20170307/p/15866354.html synchronizedhttps://blog.csdn.net/m0_53474063/article/details/112389756 循环依赖 （属性相互赋值） 自己写出来的比较好解决 ioc的话比较难解决，主要有两个问题 从单例池中，属性注入b，由于b没有，去创建b，创建的过程有需要注入a。此时a没有，死循环了 解决方法 半成品池 a一旦被实例化，就把他放在半成品池中（二级缓存解决，为啥用三级缓存，因为解决不了aop代理） aop代理问题 等于说有一个前置方法，在调用的时候提前创建这个代理类 负载均衡1、轮询法 轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。 2、随机法 随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子[5]。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。 3、最小连接法 最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。 Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用 Ribbon默认负载轮询算法原理默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。 注解LoadBalancer 查看内存使用情况1 查看系统内存freenetstat -anp |grep 端口号 top 查看进程 cup使用情况 内存的使用情况 ** Load Average**load average: 1.79, 2.10, 2.28 系统负载，三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。如1.79，表示最近一分钟平均负载。 free -h ps 可以看pid 这个杀死用，也可以看cup使用情况内存使用情况 断开通信除了四次挥手还有什么方式？ 如果主机需要尽快关闭连接（或连接超时，或端口、主机不可达）时，发送RST包（RST表示复位）强制关闭TCP连接。 发送RST包关闭连接时，可以丢弃缓存区的包直接发送RST包，而接收端收到RST包后，也不必发送ACK包来确认。 线程池场景https://www.bilibili.com/video/BV1dt4y1i7Gt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc（B站） https://www.bilibili.com/video/BV1ca411B78i/?spm_id_from=333.880.my_history.page.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc 报警那块 我是把每个传感器作为一块子的，每一个子的都用线程池 这里设置了一个计数器来阻止主线程继续，让主线程等线程池中弄完再走 CountDownLatch 这个是同步工具类中的计数器，有几组（我这里是传感器的数量（这里就16了））设置初始值为多少 CountDownLatch原理 https://zhuanlan.zhihu.com/p/95835099 池化思想 线程池、数据库连接池、字符串常量池都是这样，池化思想，目的是为了提高资源利用率 常见知识点 https://blog.csdn.net/tumu6889/article/details/125257712 阻塞队列 线程池方法 这些本质也是调用的threadpool 拒绝策略 AbortPolicy中止策略：丢弃任务并抛出异常。比较关键的业务推荐使用该策略，这样在系统不能承载更大并发量的时候就能通过异常发现 DiscardPolicy丢弃策略：丢弃任务不抛异常。一些无关紧要的任务可以使用这个策略 DiscardOldestPolicyi弃老策略：根据实际业务来决定是否允许丢弃老任务 CallerRunsPolicy：由调用者处理。一般在不允许失败、对性能要求不高、并发量小的场景使用 AQS node 有一个内部类node，如上图所示，每个node都有prev、next、waitstatus（记录上一个节点是谁，下个节点，状态（这个状态是上面那两个标志exclusive、signal）） 还有这一个属性，记录当前绑定的线程 头和尾节点 state 只要不是0，说明拿到锁 结构图 Renntralock 非公平锁 通过cas，如果把0修改成1，说明成功获取到了锁（这里通过cas怕别人并发拿到） 锁重入 参考资料 https://zhuanlan.zhihu.com/p/45305463 https://zhuanlan.zhihu.com/p/540999126 redis 数据类型 zset数据结构 压缩链表和跳表 压缩列表 压缩列表本质上就是一个数组，只不过增加了一些节点 如上图所示，黄色是增加的部分 在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素。 跳表 之前只能从头一个一个遍历，时间复杂度为 O(N) 跳表是增加了多级索引 例如每隔一个数据就建立一层索引，建立多层就类似于二分查找了，时间复杂度 O(logN) 什么时候用压缩列表，什么时候用跳表？ 有序集合保证元素数量小于128个时，用压缩列表 红黑树的时间复杂度也是O（logn），为啥 不用它，而选择跳表 首先，跳表可以查范围数据，比如上述查22-27，这样可以找到22后直接遍历即可 其次，跳表是通过多层索引，结构比较简单，更加容易实现。红黑树还要调节点 参考资料 https://www.bilibili.com/video/BV1kh411x7Jc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc Redis为什么不用b+树？MySQL为什么不用跳表？ 这个问题在于 Redis是直接操作内存的并不需要磁盘io而MySQL需要去读取io，所以mysql要使用b+树的方式减少磁盘io，B+树的原理是 叶子节点存储数据，非叶子节点存储索引，每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一 而Redis是 内存中读取数据，不涉及IO，因此使用了跳表，跳表明显是更快更简单的方式。 什么是布隆过滤器 原理 布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。 简单来说就是准备一个长度为 m 的位数组并初始化所有元素为 0，用 k 个散列函数对元素进行 k 次散列运算跟 len(m)取余得到 k 个位置并将 m 中对应位置设置为 1。 优点 空间占用极小，因为本身不存储数据而是用比特位表示数据是否存在，某种程度有保密的效果。 插入与查询时间复杂度均为 O(k)，常数级别，k 表示散列函数执行次数。 散列函数之间可以相互独立，可以在硬件指令层加速计算。 缺点 可能存在误判 redis为啥快1.在内存 2.数据结构多，找到对应的 3.单线程，没有啥切换","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"马哲","slug":"马哲","date":"2020-03-14T16:00:00.000Z","updated":"2023-04-25T10:24:16.944Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"http://example.com/posts/7a46f93c.html","excerpt":"","text":"第一天立德树人是教育之本 民主党派成员最多的是民盟 新民主革命的动力包括：工人、农民、小资产阶级、民族阶级 马克思主义哲学是无产阶级世界观 我党把马列主义和中国实际相结合的最初成果：《中国社会各阶级的分析》、《湖南农民运动考察报告》 1956年4月，毛泽东同志提出“百花齐放，百家争鸣”是我国发展科学、繁荣文学艺术的方针 习近平外交思想始终坚持实践第一的观点 古田会议决议了中心思想是要用无产阶级思想进行军队和党的建设（第九次党代表大会） 八七会议结束了陈独秀右倾投降主义在中央的统治，确立了土地革命和武装反抗国民党反动派的总方针，并发动了农民进行秋收起义（大革命失败后） 洛川会议为了动员一切力量抗日，并具体指定、建立党领导抗战的纲领和政府。 遵义会议是中国共产党第一次独立自主地运用马克思列宁主义解决自己路线、方针和政策的会议。挽救党、挽救红军、挽救新中国，是生死攸关转折点，提出红军应该采取积极防御的战略方针 邓小平提出了一国两制 陈独秀上海创办《青年杂志》，后改名《新青年》（它也是中国共产党第一个公开性机关刊物），迁往北京成为新文化运动的主要阵地，标志着新文化运动的兴起，口号为民主和科学，没有参加中共一大 董必武参加了上海兴业路一大会址纪念馆。为纪念馆写下了“作始也简，将毕也钜”。他出席了中共一大 李大钊是中国传播马克思主义最早的革命先驱，被称为“引来天火的人”，没有参加中共一大 《中国革命和中国共产党》一文中，毛泽东指出现阶段的敌人是帝国主义和封建地主阶级，主要任务也是干这两个，但最主要的是干帝国主义 党员开除党籍，五年内不得重新入党 生产实践、社会实践、科学实践，最基础的最重要的是生产实践 两个务必是毛泽东提出来的，在七届二中全会（务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续地保持艰苦奋斗的作风） 三湾改编首次提出官兵平等 毛泽东思想初步形成的标志是农村包围城市 1927年8月1号，八一南昌起义，让南昌获得了英雄城市的美誉 第二天十三大概况“一个中心、两个基本点”基本路线（一个中心，指以经济建设为中心；两个基本点，指坚持四项基本原则，坚持改革开放。），第一次比较系统地概述了社会主义初级阶段理论。 十二大提中特 十五大邓小平指导 十六大三个代表 十七大科学发展观 十八大全面建成小康 一大建党，二大立岗 三大国共合作 一大立党二立纲，三大国共要合作。四大领导工农忙，五大批评陈独秀。六大苏联求帮忙，南昌打响第一枪。八七枪杆出政权，三湾军队要听党。古田军队建新军，遵义军事与组织。瓦統洛后。毛六六论马🐎，七大确定毛指导。七届二中转城市，八大主矛和建设。十一三中要开放，十二小平提中特。十三阶段路线定，南方三猫论本质。十四目标在市场，十五小平成指导。十六提出三代表，十七科学发展观。十八科学成指导，十九走进新时代。 党的一大在莫斯科召开 陈独秀和李大钊都未参加一大 我国对资本主义工商业进行社会改造的基本政策是“和平赎买” 科学发展观第一要义是发展，核心是以人为本，基本要求是全面协调可持续性，根本方法是统筹兼备 马克思主义中国化的第一个重要理论成果是毛泽东思想 我国经济已经由高速增长转向高质量发展 红船精神是敢为人先的首创精神 长征精神是把全国人民和中华民族的根本利益看得高于一切 意识反作用于物质的基本途径是实践 我国进行土地改革的基本原因是封建土地制度阻碍了农村经济和社会的发展 社会主义的根本方向是消灭剥削、消灭两级分化 《实践论》《矛盾论》标志着毛泽东哲学思想形成 邓小平邓小平南方谈话内容是‘三个有利于标志’（两力一平）（是否提高生产力、综合国力、生活水平）（黑猫白猫，能抓老鼠就好） 一国两制是邓小平提出来的 十五大将邓小平理论写入党章 《星星之火可以燎原》毛主席回复林彪的，林彪问毛主席红旗还需要打多久 《论联合政府》是七大提出的，主要弄了三大作风，（理论和实践相结合，与人民群众紧密联系在一起，自我批评） 实践决定意识，是因为实践具有直接现实性（通过实践，直接可以变成现实，比如盖一个房子，直接就有了） 实践具有主观能动性，因为它是有目的有意思的去实践，这是和动物区分的，比如动物也会盖房子，它们没有目的和意识 实践具有社会历史性，具有社会性受到历史条件的制约，比如你实践割麦子，有条件用机器，没条件用手 意识是对客观世界的主观反映，意识的内容是客观的，表现形式是主观的 所有的意识都要来源于客观存在 无产阶级领导的中心问题是农民问题（农民也是最多的，主力军） 外因要通过内因起作用（比如说你妈妈天天唠叨你好好学习，这是个外因，但如果你不听，也起不到作用） 党的性质是先进性和纯洁性 毛泽东最先提出马克思主义中国化（马66论马） 社会的基本矛盾是社会发展的基本动力（社会基本矛盾包括：生生经上。生产力和生产关系，经济基础和上层建筑） 生产力决定生产关系，生产关系反作用于生产力（反作用是两面的，好的促进，坏的抑制） 生产力是人类改造自然的能力（人与自然），生产关系是人们之间的关系（人与人） 马克思的两大发现：唯物史观、剩余价值学说 红船精神包括：开天辟地、敢为人先的首创精神，坚定理想、百折不挠的奋斗精神，立党为公、忠诚为民的奉献精神 第三天神州十号载人飞船，男的有聂海胜、张晓光，女的有王亚平，其中，聂海胜担任指令长 中华名族由危亡走向振兴的转折点是抗日战争的胜利（党的是遵义会议） 主次矛盾与矛盾的主要方面（主次矛盾讲的是不同的事情，至少是两件事，比如发展面对经济、环境、人口问题等）（矛盾的主要方面是讲的一件事情，例如科技是把双刃剑） 群众路线的核心是一切为了群众，一切依靠群众 延安精神的核心是自力更生、艰苦奋斗 中共七大还没有建国，八大规模大 机械唯物主义（形而上学）（原子是事物的属性） 朴素唯物主义（看到的） 物质的唯一特性是客观实在性（不随人的意志改变），唯一属性是运动 实践是认识的来源，一切认识归根到底是从实践中获得（实践是认识的唯一源泉）（但实践不是认识的唯一途径，也可通过视频、图片等认识） 实践是认识的发展动力。实践中遇到的新问题需要新认识去解决，从而推动认识的发展 （前两个实践：先有实践。后面两个是先有认识。这样来做题） 实践是认识的目的，从实践中来，到实践中去，认识的目的是改造世界，到实践中去 实践是检验真理的唯一标志 毛泽东中国革命最后一个农村根据地是西柏坡（七届二中，提出了两个务必，进京赶考），像北平进发，进了北平香山，标志着中国革命重心从农村转向城市 意识具有目的性和计划性（比如想上岸，一天计划做多少题） 意识具有主动创造性（比如龙） 意识能指导实践改造世界（指导是中心词，包含正确和错误，考的时候要都说） 意识对人体的生理活动具有调节和控制作用（比如笑一笑十年少）（望梅止渴） 意识只有人有 意识没有客观实在性，物质才有 意识受到主题的影响（比如不同人看到同一个问题意识不同） 发展是前进性和曲折性的统一 发展有其自身的客观规律，不以人的意志为转移（种啥得啥） 毛泽东思想和中国特色社会主义的区别：毛不改革，中特不革命 建设现代化经济体系，着力点放在实体经济上 中华苏维埃第一次在瑞金召开 一国两制 ”爱国者治港“ 毛泽东思想围绕的主题是革命和建设 邓小平理论主题是什么是社会主义，怎样建设社会主义 十九大报告：以人民安全为宗旨，以政治安全为根本 三大规律：对立统一；质量互变规律；否定之否定规律 辩证否定的实质是扬弃。矛盾是事物发展的源泉和动力。辩证否定是事物联系和发展的环节。 大革命失败后，中国共产党建立的第一个农村根据地是井冈山根据地 中国革命农村包围城市、武装夺取政权根本在于处理好土地革命、武装斗争、农村革命根据地之间的关系 新民主主义的三大法宝：统一战线、武装斗争、党的建设 人民统一战线：工人阶级、农民阶级、名族资产阶级三者之间的关系 抗战统一战线：进步势力、中间势力、顽固势力 瓦窑堡会议确定了建立抗日民族统一战线方针 1938年《论持久战》提出了民兵是胜利之本 延安整风：反对主观主义以整顿学风（中心任务）、反对宗派主义以整顿党风、反对党八股文以整顿文风 意识对于客观事物的反映是主动的、有选择的（每个人看同一件事物的意识不同，比如蛋糕，艺术家看到的和普通人不一样） 第四天十八届三中全会提出市场在配置中发挥决定性作用（2013年习总书记主持） 十八届四中（2014）提出了依法治国 十八大（一选举，二宪法，三改革，四法律，五经济，六党建） 毛泽东思想灵魂包括：实事求是（根本点，出发点），群众路线（工作路线），独立自主（立足点）。 本本主义也是教条主义，就是做什么事情都不从实际出发，生搬硬套 在党的纪律中，政治纪律最重要、最根本、最关键 画梅不能止渴反映了观念东西不能代替物质东西 精神和物质的同一性，这个是你认为这个世界是否是可知的，如果你认为是可知的，就是同一的，这也是可知论 精神对物质的相对独立性：意识可能超前，也可能落后 精神可以转化成物质，通过实践 小康：邓小平提出放入国家。十二大提出，十六大建设，十八大建成 家庭是道德建设的起点，学校是道德建设的阵地 经济特区：生下三头猪（深圳、厦门、汕头、珠海）去海南度假，结果去了新疆喀什（kā shí）霍尔果斯 伟大载人航天精神：淡泊名利，默默奉献 实践高于理论认识，是因为实践具有直接现实性 第五天主要矛盾对事物发展起决定性作用 中国精神包括民族精神（核心爱国主义）和时代精神（核心改革创新） 爱国主义始终是把中华民族坚强团结在一起的精神力量，改革创新始终是鞭策我们在改革开放中与时俱进的精神力量 整体与部分关系：1.整体居于主导地位 2.关键部分对整体起决定性作用 3.整体是各部分的有机构成，具有部分没有的功能（比如说钟表，有计时功能，但是拆开后每个指针没有该功能） 中国共产党主题就是为了实现中华民族伟大复兴 实事求是的“是”为规律性","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"},{"title":"马哲错题","slug":"马哲错题","date":"2020-03-14T16:00:00.000Z","updated":"2023-07-03T10:03:25.428Z","comments":true,"path":"posts/7a06f35t.html","link":"","permalink":"http://example.com/posts/7a06f35t.html","excerpt":"","text":"理论马克思恩格斯的两大发现是《唯物史观》、《剩余价值学说》 杰出人物，这里体现了必然性与偶然性的统一 量积累到一定程度才会发生质变，量的积累不一定会有质的变化 时间的概念 “贯彻新发展理念”没有体现否定之否定定律 否定之否定是三个阶段，贯彻新发展能够更好地指导我们实践，可以促进事物发展，没有三个阶段 实践实践是认识发展的动力理解：强调实践中产生的新问题需要新的认识去解决问题，从而推动认识的发展。 整体部分 诗句判别","categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"蜗牛"}],"categories":[{"name":"公共知识","slug":"公共知识","permalink":"http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"mysql","slug":"mysql","permalink":"http://example.com/categories/mysql/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"}]}