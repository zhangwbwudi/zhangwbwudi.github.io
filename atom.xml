<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蜗牛</title>
  
  <subtitle>boの博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-25T11:43:01.933Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>蜗牛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/posts/0.html"/>
    <id>http://example.com/posts/0.html</id>
    <published>2023-04-25T11:43:01.441Z</published>
    <updated>2023-04-25T11:43:01.933Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/posts/0.html"/>
    <id>http://example.com/posts/0.html</id>
    <published>2023-04-25T10:26:53.647Z</published>
    <updated>2023-04-25T10:26:53.920Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？</h1><p>启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解：</p><p>1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。</p><p>2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 </p><p>3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。</p><h1 id="springboot内置tomcat"><a href="#springboot内置tomcat" class="headerlink" title="springboot内置tomcat"></a>springboot内置tomcat</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ShardingSphere</title>
    <link href="http://example.com/posts/7f1ae6sd.html"/>
    <id>http://example.com/posts/7f1ae6sd.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-05-28T09:18:39.979Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/../images/typora-user-images/image-20230320160459329.png" alt="image-20230320160459329"></p><p><img src="/../images/typora-user-images/image-20230320160616110.png" alt="image-20230320160616110"></p><p><img src="/../images/typora-user-images/image-20230320163748877.png" alt="image-20230320163748877"></p><p><img src="/../images/typora-user-images/image-20230320171201988.png" alt="image-20230320171201988"></p><p>添加事务后均是主库，在没添加事务的时候插入是主，查询是从</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="/../images/typora-user-images/image-20230320171910169.png" alt="image-20230320171910169"></p><p>springboot只需要在配置文件里配置一下，这里配置数据源</p><p><img src="/../images/typora-user-images/image-20230320172118654.png" alt="image-20230320172118654"></p><p>只需要配置一下，哪个数据源是读得，那个是写的</p><p><img src="/../images/typora-user-images/image-20230320172207339.png" alt="image-20230320172207339"></p><p><img src="/../images/typora-user-images/image-20230320172239900.png" alt="image-20230320172239900"></p><p>配置负载均衡</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>docker</p><p><img src="/../images/typora-user-images/image-20230415110726860.png" alt="image-20230415110726860"></p><p>这是映射到主机</p><p><img src="/../images/typora-user-images/image-20230415110756798.png" alt="image-20230415110756798"></p><p>修改my。cof</p><p><img src="/../images/typora-user-images/image-20230415111346062.png" alt="image-20230415111346062"></p><p><img src="/../images/typora-user-images/image-20230415111405205.png" alt="image-20230415111405205"></p><p><img src="/../images/typora-user-images/image-20230415111503055.png" alt="image-20230415111503055"></p><p><img src="/../images/typora-user-images/image-20230415113116725.png" alt="image-20230415113116725"></p><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><p>雪花</p><p><img src="/../images/typora-user-images/image-20230521222742697.png" alt="image-20230521222742697"></p><h2 id="水平分库分表策略"><a href="#水平分库分表策略" class="headerlink" title="水平分库分表策略"></a>水平分库分表策略</h2><p><img src="/../images/typora-user-images/image-20230521223732527.png" alt="image-20230521223732527"></p><p>如上图所示，定义好数据库的放置，这里是通过userid，偶数放在1号库，奇数放在2号库。定义完成后再定义每个库中表的策略，这里是根据cid进行划分，偶数放在1号表，奇数放在2号表。</p><h2 id="公共表"><a href="#公共表" class="headerlink" title="公共表"></a>公共表</h2><blockquote><p>何为公共表</p></blockquote><p>不长变的，经常需要做关联工作，比如地表沉降系统中的传感器节点信息表。（要在每个库中创建同样一张表）</p><p>这里也是通过shardingsphere做的，在papertie里设置公共表，如下</p><p><img src="/../images/typora-user-images/image-20230521224724564.png" alt="image-20230521224724564"></p><p>这样的话，插入和删除都是对每个数据的公共表同时操作。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ol><li>修改这个文件</li></ol><p><img src="/../images/typora-user-images/image-20230521225102898.png" alt="image-20230521225102898"></p><ol start="2"><li>改端口号</li></ol><p><img src="/../images/typora-user-images/image-20230521225144710.png" alt="image-20230521225144710"></p><ol start="3"><li>修改文件路径（存数据的）</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote><p>TCC</p></blockquote><p><img src="/../images/typora-user-images/image-20230525102454126.png" alt="image-20230525102454126"></p><p><img src="/../images/typora-user-images/image-20230525104011702.png" alt="image-20230525104011702"></p><p><img src="/../images/typora-user-images/image-20230525104033057.png" alt="image-20230525104033057"></p><p>分布式事务可以通过TCC来解决，分别是上面三个单词的缩写。使用TCC需要给表加上冗余列，例如上述订单表和库存表，需要在订单表中添加预增金额和状态，库存服务里需要添加冻结库存。</p><p>在执行TCC时候，Try是对资源进行锁定，在这一步预增金额这里设置一下（比如买10瓶水，一瓶水3块钱，这里的预增金额就设置为30，把状态改为初始），库存表也是这样（因为要取，所以库存要减少，这里是冻结库存设置为10，因为要取10瓶水）。</p><p>Confirm进行提交，这里如果提交成果，就把上面的预增金额和冻结库存给真正处理。状态设置为完成。</p><p>cancel取消，取消的话放弃预设金额和冻结库存，状态码设置为取消。</p><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>可以使用UUID和雪花算法，但一般使用的是雪花算法。</p><blockquote><p>原因</p></blockquote><p> UUID 生成的是一个无序的字符串（影响查询效率）</p><h3 id="雪花算法（SnowFlake）"><a href="#雪花算法（SnowFlake）" class="headerlink" title="雪花算法（SnowFlake）"></a>雪花算法（SnowFlake）</h3><p>雪花算法的原理就是生成一个的 64 位比特位的 long 类型的唯一 id。</p><ul><li>最高 1 位固定值 0，因为生成的 id 是正整数，如果是 1 就是负数了。</li><li>接下来 41 位存储毫秒级时间戳，2^41/(1000<em>60</em>60<em>24</em>365)=69，大概可以使用 69 年。</li><li>再接下 10 位存储机器码，包括 5 位 datacenterId 和 5 位 workerId。最多可以部署 2^10=1024 台机器。</li><li>最后 12 位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成 2^12=4096 个不重复 id。</li><li>可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。</li></ul><p>对于每一个雪花算法服务，需要先指定 10 位的机器码，这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的 10 位比特位的整数值都行。<br><img src="/../images/typora-user-images/format,png" alt="img"></p><blockquote><p>具体网址</p></blockquote><p><a href="https://blog.csdn.net/jiaomubai/article/details/124385324?spm=1001.2014.3001.5506">https://blog.csdn.net/jiaomubai/article/details/124385324?spm=1001.2014.3001.5506</a></p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>分库分表后分页查询比较麻烦，比如差10条，一般从第一张表里查10条，再从第二章表里查10条，然后再排序获取。</p><h2 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h2><blockquote><p>方案一</p></blockquote><p>shardingsphere支持夸库join查询</p><blockquote><p>方案二</p></blockquote><p>先查一个字段，从这里获得关联的第二个字段，再通过第二个字段查</p><blockquote><p>方案三</p></blockquote><p>增加冗余列，把链接这个直接作为冗余字段存储</p><h2 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h2><p>使用shardingsphere进行主从复制，默认是查走从，插找主，但是主和从节点的数据同步是需要一些时间的，如果我们查最新插入的数据可能会导致查不到（因为数据还没有同步过去）</p><p>以地表沉降系统为例，查询最新的数据可能会导致查不到，原因如上。</p><blockquote><p>方案一</p></blockquote><p>可以设置查询最新的消息都走主库</p><blockquote><p>方案二</p></blockquote><p>在插入数据的时候同时插入缓存一个标志，比如设置60秒过期（根据业务定，差不多可以主从同步的时间），再查的时候先判断这个缓存还有没，如果有则查主，如果没有（说明已经主从辅助完成了）查从。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>在形变模块，为了提升查询速度，对数据库进行了分库分表工作，对表进行了水平拆分，拆分了三个表。用到了数据库中间件shardingshere，采用了mod进行分片（利用传感器id），分布式id采用雪花策略，这样可以把同一个传感器的数据分到同一个表里，查询的时候就不需要查多张表了，提升速度。另外，项目里面有根据时间进行查询的，根据上面的分片策略可以实现，但需要到多张表中查寻，这样性能会低。我的解决方法采用看冗余数据，在通过时间进行范围分片。另外，做了主从复制，共搭建了两个从节点（在mini中配置），这里出现了一个问题，最新的数据有一部分查不到，原因是（通过shardingshere配置了查走从，其他走主。可能从还没有同步过来数据），解决方案是在插入数据的时候在redis中查如一个缓存，类似标志位，设置60秒（主从时间够就行），查的时候判断这个缓存还在吗，如果不在了就说明同步完成，查从。否则查主。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>jvm</title>
    <link href="http://example.com/posts/7f1ae6dp.html"/>
    <id>http://example.com/posts/7f1ae6dp.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-04-25T11:26:39.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Class字节码文件"><a href="#Class字节码文件" class="headerlink" title="Class字节码文件"></a><strong>Class字节码文件</strong></h2><pre><code>     是一个[二进制](https://so.csdn.net/so/search?q=二进制&amp;spm=1001.2101.3001.7020)文件，包含了JAVA程序执行的字节码，包含的信息有版本、访问标志、常量池、当前类、超级类、接口、字段、方法、属性等，中间没有任何分隔符，文件开头有一个特殊标志，用16进制表示为0xcafebabe。</code></pre><h2 id="类的实例化顺序"><a href="#类的实例化顺序" class="headerlink" title="类的实例化顺序"></a>类的实例化顺序</h2><p><strong>比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序</strong></p><p>先静态、先父后子。</p><p>先静态：父静态 &gt; 子静态</p><p>优先级：父类静态代码块–&gt;子类静态代码块–&gt;父类代码块–&gt;父类<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&amp;spm=1001.2101.3001.7020">构造方法</a>–&gt;子类代码块—&gt;子类构造方法</p><p><strong>一个类的实例化过程：</strong></p><p><strong>1、</strong> 父类中的static代码块，当前类的static（这是类初始化，这个main所在的也会初始化）</p><p><strong>2、</strong> 顺序执行父类的普通代码块(还有非静态变量)（下面是实例初始化）</p><p><strong>3、</strong> 父类的构造函数</p><p><strong>4、</strong> 子类普通代码块(还有非静态变量)</p><p><strong>5、</strong> 子类（当前类）的构造函数，按顺序执行。</p><p><strong>6、</strong> 子类方法的执行，、</p><blockquote><p>例子</p></blockquote><p><img src="/../images/typora-user-images/image-20220708115309577.png" alt="image-20220708115309577"></p><p><img src="/../images/typora-user-images/image-20220708111746713.png" alt="image-20220708111746713"></p><p>解释</p><p><img src="/../images/typora-user-images/image-20220708113024057.png" alt="image-20220708113024057"></p><p><img src="/../images/typora-user-images/image-20220708113036644.png" alt="image-20220708113036644"></p><p><img src="/../images/typora-user-images/image-20220708115245693.png" alt="image-20220708115245693"></p><h2 id="jvm-常用配置参数"><a href="#jvm-常用配置参数" class="headerlink" title="jvm 常用配置参数"></a>jvm 常用配置参数</h2><blockquote><p>分配堆内存s</p></blockquote><table><thead><tr><th>-Xms</th><th>最小堆</th></tr></thead><tbody><tr><td>-Xmx</td><td>最大堆</td></tr></tbody></table><blockquote><p>栈</p></blockquote><table><thead><tr><th>-Xss</th><th>栈大小</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h2><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><blockquote><p>类需要同时满足下面3个条件才能算是 “无用的类” ：</p></blockquote><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。<br>加载该类的 ClassLoader 已经被回收。<br>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>是对象只在当前函数范围内使用，因而改为在栈上申请空间，因为栈是用完就释放掉，不用等gc，缓解了gc的压力。测试可以用一个while循环创建对象来查看</p><h2 id="JVM的GC-ROOTS有哪几个地方呢？"><a href="#JVM的GC-ROOTS有哪几个地方呢？" class="headerlink" title="JVM的GC ROOTS有哪几个地方呢？"></a>JVM的GC ROOTS有哪几个地方呢？</h2><p>a. java<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;spm=1001.2101.3001.7020">虚拟机</a>栈中的引用的对象。<br>b.方法区中的类静态属性引用的对象。 （一般指被<a href="https://so.csdn.net/so/search?q=static&amp;spm=1001.2101.3001.7020">static</a>修饰的对象，加载类的时候就加载到内存中。）<br>c.方法区中的常量引用的对象。<br>d.本地方法栈中的JNI（<a href="https://so.csdn.net/so/search?q=native&amp;spm=1001.2101.3001.7020">native</a>方法）引用的对象</p><h2 id="GC日志的real、user、sys是什么意思？"><a href="#GC日志的real、user、sys是什么意思？" class="headerlink" title="GC日志的real、user、sys是什么意思？"></a>GC日志的real、user、sys是什么意思？</h2><p>real:指的是从开始到结束所花费的时间。比如进程在等待I/O完成，这个阻塞时间也会被计算在内。<br>user：指的是进程在用户态（User Mode）所花费的时间，只统计本进程所使用的时间，注意是指多核。<br>sys：指的是进程在核心态（Kernel Mode）花费的CPU时间量，指的是内核中的系统调用所花费的时间，只统计本进程所使用的时间。</p><blockquote><p>real time &gt; sys + user time 的情况</p></blockquote><p>一般的GC事件中，real time是小于sys+user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys+user time的。比如说：user+sys是2秒，如果是有5个GC线程并发的做垃圾回收，那么real time差不多是2000/5=400ms左右。 但是，有时候会见到real time大于sys+user time的情况</p><blockquote><p>原因</p></blockquote><p> IO负载繁重</p><p>当服务器的IO负载非常重的时候（网络、磁盘访问、用户交互），real time就会变大。应用做GC日志打印的时候，也需要访问磁盘。当磁盘的负载非常重的时候，GC事件就有可能被阻塞，这会导致real time变长。 注意：就算不是你的应用导致的磁盘负载重，如果服务器上其他的应用导致的磁盘负载重也会导致real time变长。 可以用如下命令来监控服务器的磁盘负载情况：</p><p>CPU不够用</p><p>如果服务器上跑了很多进程，你的应用很不幸没有得到足够的CPU时间，它就需要很多的等待。当你的进程在等待的时候，real time显然就比sys+user时间长了。</p><h2 id="safepoint是什么？"><a href="#safepoint是什么？" class="headerlink" title="safepoint是什么？"></a>safepoint是什么？</h2><h2 id="g1什么时候引发full-gc"><a href="#g1什么时候引发full-gc" class="headerlink" title="g1什么时候引发full gc"></a>g1什么时候引发full gc</h2><p>young GC触发时机：young区不够用</p><p>full GC触发时机: 没有足够的Region</p><h2 id="垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器"><a href="#垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器" class="headerlink" title="垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器"></a>垃圾回收器之串行、吞吐量优先、响应时间优先的的垃圾回收器</h2><blockquote><p>串行</p></blockquote><p>单线程<br>堆内存较小，适合个人电脑</p><blockquote><p>吞吐量优先</p></blockquote><p>多线程<br>堆内存较大，多核cpu<br>让单位时间内，STW 的时间最短 0.2 0.2 = 0.4</p><blockquote><p>响应时间优先</p></blockquote><p>多线程<br>堆内存较大，多核cpu<br>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5</p><blockquote><p>解释</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">接下来我们来学习垃圾回收器，垃圾回收器我们可以把它分为这三类，第一类叫串行的垃圾回收器，第二类叫吞吐量优先的垃圾回收器，第三类叫响应时间优先的垃圾回收器。下面就解释一下，第一个串行的垃圾回收器，这个从名字上也能猜出来，它的底层是一个单线程的垃圾回收器，也就是说，它在垃圾回收发生时，其他的线程都暂停，这时候一个单线程的垃圾回收器就登场了，它一个线程来完成垃圾回收，显然它的适用场景是堆内存较小的时候，而且cpu的核数多了也没用，因为只有一个线程，适合个人电脑这就好比我们有一个居民楼，有一个保洁工人来打扫卫生，一个保洁工人就类似于这种单线程的垃圾回收器，如果楼层比较矮，小三层，那保洁工人可能一天就能把卫生打扫完了，但是如果楼层特别的高，是一个三十几层的高层建筑，那一个保洁工人来打扫，这个工作量可能是非常大的，干好几天都干不完。这是串行垃圾回收器它的适用场景。它适合堆内存小，个人电脑也就是cpu个数少的这么一个工作环境。而下两种吞吐量优先和响应时间优先的这两种垃圾回收器，它们都是多线程的，多线程的好处，还拿刚才那个例子作比喻，这个楼层很高，但是我可以多找几个保洁工人啊，它们每个人打扫一层或者几层，人多力量大，肯定还是可以在规定时间内完成垃圾回收的任务。所以后两种垃圾回收器都适合堆内存较大的场景，并且一般它需要多核的cpu来支持，为什么非要说多核cpu呢，虽然有多个线程，但是假设只有一个cpu，那么工作的时候也是多个线程轮流去争抢这单核cpu的时间片，其实这个效率还不如单线程呢，举个例子，就好比虽然有多个保洁工人来打扫卫生，但是扫帚只有一把，那要打扫卫生必须轮流使用这把扫帚，这个效率显然跟一个人来打扫是一样的，所以后两种垃圾回收器它们的工作适用场景是堆内存很大，但是有一个要求，就是必须是多核cpu才能充分发挥它俩的威力，显然多核cpu都是服务器电脑，所以它们都适合工作在服务器上。后两种吞吐量优先跟响应时间优先它们都是多线程的，那它俩之间又有什么区别呢。我们先说响应时间优先，响应时间优先它就是注重的是让垃圾回收时它的 Stop The World 的时间尽可能的短，我们都知道垃圾回收时它要把其他的线程暂停下来，等打扫完垃圾了，其他线程才能恢复运行，这段时间我们把它叫做 STW，就是世界暂停，这个世界暂停时间显然是越短越好了，那响应时间优先的垃圾回收器它要考虑的就是尽可能的让这个暂停时间变短，尽可能让 STW 的时间最短，这是它的一个目标。那么吞吐量优先呢，它的目标就不太一样，吞吐量优先是指我要在单位时间内让我的垃圾回收所占用的 STW 的时间最短，让单位时间内 STW 的时间最短。吞吐量优先和响应时间优先都是 STW 最短，那么它俩有什么区别呢，这个线程优先它是让单次的 STW 时间最短，举个例子，比如说，单位时间内触发了很多次垃圾回收，每一次垃圾回收都只花了 <span class="token number">0</span>.1s，假设1小时内发生了5次垃圾回收，每次都是0.1，那么它们加起来最后等于0.5s，也就是一小时内花费了0.5s，但是每次都很短，这是响应时间优先它的目标。但是吞吐量优先则不同，它可能单次的垃圾回收时间花费的较长，比如说1次花了0.2s，但是在一个小时内它只发生了两次垃圾回收，所以它的总时间来讲只有0.4s，从这一点上来讲，它似乎在总时间上又要优于响应时间优先，所谓的吞吐量就是指垃圾回收的时间占程序运行时间的占比，垃圾回收时间占比越低，那么就指吞吐量越高，这是吞吐量它的一个含义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>都要哪些</p></blockquote><p>对于吞吐量优先的场景，就只有一种选择，就是使用 PS 组合（Parallel Scavenge+Parallel Old ）。<br> 对于响应时间优先的场景，在 JDK1.8 的话优先 G1，其次是 CMS 垃圾回收器，另外还有PN、ZGC、Shenandoah。</p><h2 id="jdk1-8新特性"><a href="#jdk1-8新特性" class="headerlink" title="jdk1.8新特性"></a>jdk1.8新特性</h2><p>1.<a href="https://so.csdn.net/so/search?q=Lambda&amp;spm=1001.2101.3001.7020">Lambda</a>表达式</p><p>2.函数式接口</p><p>3.方法引用</p><p>等</p><h2 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h2><p>主动</p><p>主动使用，又分为七种情况：</p><p>创建类的实例</p><ul><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（ 比如：Class.forName(“cn.sxt.Test”) )</p></li><li><p>初始化一个类的子类</p></li><li><p>Java虚拟机启动时被标明为启动类的类</p></li><li><p>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</p><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit( ) 方法和 init( ) 方法）</p><blockquote><p>被动</p></blockquote><p>子类引用父类的静态字段，不会导致子类初始化</p><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</p></li></ul><h2 id="局部变量、成员变量、类变量"><a href="#局部变量、成员变量、类变量" class="headerlink" title="局部变量、成员变量、类变量"></a>局部变量、成员变量、类变量</h2><p>栈，堆，方法区</p><h2 id="i-和-i"><a href="#i-和-i" class="headerlink" title="i++和++i"></a>i++和++i</h2><h2 id="栈帧都有哪些数据？"><a href="#栈帧都有哪些数据？" class="headerlink" title="栈帧都有哪些数据？"></a>栈帧都有哪些数据？</h2><p>JVM的运行是基于栈的，和C语言的栈类似，它的大多数数据都是在堆里面的，只有少部分运行时的数据存在于栈上。</p><p>在JVM中，每个线程栈里面的元素，就叫<code>栈帧</code>。</p><p>栈帧包含：局部变量表、操作数栈、动态连接、返回地址等。</p><blockquote><p>栈结构</p></blockquote><img src="../images/typora-user-images/20210511100429508.png" alt="img" style="zoom:50%;"><img src="../images/typora-user-images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDQwODk3OQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;"><blockquote><p>栈帧的内部结构</p></blockquote><p><img src="/../images/typora-user-images/watermar" alt="img"></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><blockquote><p>组成</p></blockquote><p>最基本的存储单元是Slot（变量槽）</p><ul><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量</li><li>在局部变量表里，32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maxmum variables数据项中。在方法运行期间是不会改变局部变量表大小的。</li></ul><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出（Last-in-first-out）的操作数栈，也可以称之为表达式栈（Expression Stack）<br>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）<br>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。<br>比如：执行复制、交换、求和等操作</p><p><img src="/../images/typora-user-images/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88" alt="img"></p><p>图解：将8和15出栈，执行求和操作后再将结果进栈操作。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）.比如：invokedynamic指令<br>在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p><blockquote><p>1.举例栈溢出的情况</p></blockquote><p>答：StackOverflowError，通过-Xss设置大小，<br>1.局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。<br>2.递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。<br>3.指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p><blockquote><p>2.调整栈大小，就能保证不出现栈溢出吗？</p></blockquote><p>答：不能，如果说一个执行6000次递归就结束的程序，在可执行递归5000次的内存空间中会出现StackOverflowError，而在调整为可递归7000次的内存空间时就不会出现StackOverflowError。 如果程序是类似死递归情况无论怎样调整栈大小，都会出现溢出现象，对于这种情况，调整栈的大小理论上只能说是出现异常的时间晚一些而已’</p><blockquote><p>3.分配栈内存越大越好吗</p></blockquote><p>不是，理论上好像会在一定时间或单位时间内减少StackOverflowError的概率，避免出现StackOverflowError过早，但是避免不了出现StackOverflowError。对栈空间来说是好事，但是这样会导致可执行的线程数减少，对其他内存结构也是有影响的</p><blockquote><p>4.垃圾回收是否会设计到虚拟机栈</p></blockquote><p>不涉及，虚拟机栈会出现StackOverflowError，但是不会出现GC，因为只有进栈出栈，出栈的过程就相当于GC（程序计数器不会Error和GC，堆会GC和ERROR，方法区也会出现GC和ERROR）</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>标记-清除”算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<br>    它的主要缺点有两个：<br>        （1）效率问题：标记和清除过程的效率都不高；<br>        （2）空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，碎片过多会导致大对象无法分配到足够的连续内存，从而不得不提前触发GC，甚至Stop The World。<br><img src="/../images/typora-user-images/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4" alt="img"></p><h2 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h2><p>   为解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>    这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br>   它的主要缺点有两个：<br>        （1）效率问题：在对象存活率较高时，复制操作次数多，效率降低；<br>        （2）空间问题：內存缩小了一半；需要額外空间做分配担保(老年代)</p><blockquote><p><strong>From Survivor</strong>, <strong>To Survivor</strong>使用的就是复制算法。老年代不使用这种算法，</p></blockquote><p><img src="/../images/typora-user-images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95" alt="img"></p><h2 id="标记-整理-Mark-Compact"><a href="#标记-整理-Mark-Compact" class="headerlink" title="标记-整理(Mark-Compact)"></a>标记-整理(Mark-Compact)</h2><p>  复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>    根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存<br><img src="/../images/typora-user-images/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86" alt="img"></p><h2 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h2><p> GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。<br>   “分代收集”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p><h2 id="你知道哪些垃圾收集器？"><a href="#你知道哪些垃圾收集器？" class="headerlink" title="你知道哪些垃圾收集器？"></a>你知道哪些垃圾收集器？</h2><blockquote><p>serial</p></blockquote><p>串行回收</p><p>新生代</p><p>采用复制算法</p><p>Serial是一个单线程的收集器，Serial的特点是它在进行垃圾收集时，必须“<strong>Stop the World</strong>”，意思就是当这个垃圾收集器开始工作时，必须停止其他所有的工作线程。听起来似乎很不靠谱，但是对于限定单个CPU的场景下，这种方式简单而高效。对于简单的桌面应用，分配给虚拟机的内存不会很大，对于一两百兆的新生代，Serial的垃圾收集时间可以控制在一百毫秒以内，对于用户来说基本上是无影响的。</p><blockquote><p>serial old</p></blockquote><p>采用标记-压缩算法</p><p>老年代</p><p><img src="/../images/typora-user-images/image-20220619115320865.png" alt="image-20220619115320865"></p><blockquote><p>ParNew</p></blockquote><p>并行回收</p><p>ParNew垃圾收集器是Serial的多线程版本，<strong>使用多条线程进行垃圾收集</strong>。除此之外，和Serial基本相同，ParNew在多线程收集垃圾时依旧需要<strong>“Stop the World”</strong>。ParNew可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数量。</p><p>ParNew收集器在新生代使用<strong>复制算法</strong></p><blockquote><p>Parallel Old</p></blockquote><p>Parallel Scavenge收集器的老年版本，多线程收集器，<strong>采用标记-整理算法</strong>，也是吞吐量优先。</p><p><img src="/../images/typora-user-images/image-20220619115618468.png" alt="image-20220619115618468"></p><blockquote><p>Parallel Scavenge</p></blockquote><p>Parallel Scavenge也是新生代收集器，也同样是多线程的收集器，但是和ParNew不同，Parallel Scavenge收集器<strong>关注的是一个可控制的吞吐量</strong>（Throughput）。所谓吞吐量指的是CPU用于运行代码的时间和CPU总消耗的时间比例。</p><p><strong>吞吐量=运行代码的时间 /（运行代码的时间+垃圾收集时间）</strong></p><p>理论上吞吐量越高，用户就越不能感受到停顿时间。</p><p>Parallel Scavenge提供了两个参数用来控制吞吐量： <strong>-XX:MaxGCPauseMillis</strong>和**-XX:GCTimeRatio**</p><p><strong>-XX:MaxGCPauseMillis</strong>设置内存回收花费时间最高毫秒值，但是不要一味地认为只要把值设置很小，垃圾回收就更快了。<strong>这个停顿时间是以牺牲吞吐量和新生代空间换来的。</strong></p><p><strong>-XX:GCTimeRatio</strong>表示垃圾收集时间占总时间的比例，（1~100），也就是吞吐量的倒数。默认这个值是99，就是允许最大百分之1的垃圾手机时间（1/(1+99)）。</p><p>还有一个参数**-XX:+UseAdaptiveSizePolicy**，打开这个参数后，就不需要自己设置新生代大小、晋升老年代对象年龄等参数，因此Parallel Scavenge收集器也被叫做吞吐量优先垃圾收集器。</p><p>Parallel Scavenge采用<strong>复制算法。</strong></p><blockquote><p>cms</p></blockquote><p>主要特点：低延迟</p><p>尽可能缩短垃圾收集时候用户线程的停顿时间</p><p>采用的标记-清除算法</p><p>老年代垃圾回收器</p><p><img src="/../images/typora-user-images/image-20220619123441109.png" alt="image-20220619123441109"></p><p><strong>1、初始标记：标记GC Roots可以直接关联到的对象，速度很快（stop the world）</strong></p><p><strong>2、并发标记：根搜索算法的过程</strong></p><p><strong>3、重新标记：为了修正并发标记期间，因程序运行导致标记产生变动的对象。（stop the world）</strong></p><p><strong>4、并发清除：清除垃圾</strong></p><p>它的优点就是<strong>并发收集、并发清除、低停顿</strong>。</p><p>但是它有三个显著的缺点：</p><p>1、<strong>对CPU资源十分敏感</strong>，因为并发标记和并发清除都是和程序同时运行，因此会占用CPU导致应用程序变慢。</p><p>2、<strong>无法处理浮动垃圾</strong>，浮动垃圾就是在并发清除过程中新生成的垃圾，这部分垃圾CMS无法在本次被清理，可能出现Concurrent Mode Failed报错，因此需要预留一定的内存空间，无法等到老年代快被占满时再清除。默认情况下，CMS在老年代使用了68%后就会被激活。可以设置-XX:CMSInitiatingOccupancyFraction设置这个值。</p><p>3、<strong>产生空间碎片</strong>，由于采用的是标记-清除算法，那就无法避免会产生空间碎片的问题，这会给分配大对象带来困难。</p><blockquote><p>G1</p></blockquote><p>区域化分代式</p><p>同时兼顾新生和老年代</p><p><img src="/../images/typora-user-images/image-20220619133131462.png" alt="image-20220619133131462"></p><p>划分为一个个region，region内部采用复制算法，整体是标记压缩算法。没有碎片化。</p><p>只选取部分region进行内存回收，这样缩短了回收范围，减少了停顿。</p><p>后天有一个优先列表，优先回收大的（这个也根据自己给的限制时间内选择较大的）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="http://example.com/posts/7f1ae6do.html"/>
    <id>http://example.com/posts/7f1ae6do.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-04-25T11:21:54.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>bin sbin etc home usr root tmp</p><h2 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h2><p><img src="/../images/typora-user-images/image-20230425191658866.png" alt="image-20230425191658866"></p><h2 id="关机和重启的命令"><a href="#关机和重启的命令" class="headerlink" title="关机和重启的命令"></a>关机和重启的命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">shutdown</span> -h now立刻进行关机<span class="token function">shutdown</span> -h <span class="token number">1</span>”hello，1分钟后会关机了“<span class="token function">shutdown</span> -r now现在重新启动计算机<span class="token function">halt</span>关机<span class="token function">reboot</span>重新启动syn把内存的数据同步到磁盘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：目前的shutdown/reboot/halt 等命令均已经在关机前进行了sync，但是在执行关机或重启前sync一下，小心驶得万年船</p></blockquote><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><blockquote><p>用户切换</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>halo@zwb-lucky root<span class="token punctuation">]</span>$ <span class="token function">su</span> rootPassword: <span class="token punctuation">[</span>root@zwb-lucky ~<span class="token punctuation">]</span><span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>su - 用户名“<strong>命令来切换</strong></p><p><strong>注意</strong></p><p>1.从权限高的用户切换到权限低的用户时，不需要输入密码，反之需要</p><p>2.当需要返回到原来用户时，使用exit/logout指令</p><blockquote><p>添加用户</p></blockquote><ul><li>基本语法</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>实列(root权限下)</li></ul><pre class="line-numbers language-bah" data-language="bah"><code class="language-bah">useradd hucheng添加一个用户chucheng，默认该用户的家目录在/home/hucheng<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>细节说明</li></ul><pre class="line-numbers language-none"><code class="language-none">1、当用户创建成功后果，会自动的创建和用户同名的家目录2、也可以通过useradd -d 指定目录  新的用户名     来给新创建的用户指定家目录12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../images/typora-user-images/20210620104231917.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">新建用户zhanzhiwen的home目录下的文件夹名称是muluming<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>指定/修改密码</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span> 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：修改密码要在root下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>zhangsan@zwb-lucky home<span class="token punctuation">]</span>$ <span class="token function">passwd</span> zhangsanpasswd: Only root can specify a user name.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>删除用户</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">userdel</span>   用户名<span class="token function">userdel</span> -r 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>查询用户信息指令</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">id</span> 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@zwb-lucky ~<span class="token punctuation">]</span><span class="token comment"># id root</span><span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">[</span>root@zwb-lucky ~<span class="token punctuation">]</span><span class="token comment"># id halo</span><span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>halo<span class="token punctuation">)</span> <span class="token assign-left variable">gid</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>halo<span class="token punctuation">)</span> <span class="token assign-left variable">groups</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">(</span>halo<span class="token punctuation">)</span>,10<span class="token punctuation">(</span>wheel<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>查看当前用户/登录用户</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">whoami/who am i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>用户组</p></blockquote><p>类似于角色，系统可以对有共性/权限的多个用户进行统一的管理</p><p>新增组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">指令：groupadd 组名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">指令（基本语法）：groupdel 组名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：如果当添加用户时没有指定组，会默认创建和这个<strong>用户同名的组</strong>，同时把用户放到该组里</p><p>增加用户时直接加上组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">指令：useradd -g 用户组 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>移动组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">usermod</span> -g 组名 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="运行级别说明："><a href="#运行级别说明：" class="headerlink" title="运行级别说明："></a>运行级别说明：</h2><p>0：关机</p><p>1：单用户【找回丢失密码】</p><p>2：多用户状态没有网络服务</p><p>3：多用户状态有网络服务</p><p>4：系统未使用保留给用户</p><p>5：图形界面</p><p>6：系统重启</p><p>常用运行级别是3和5，也可以指定默认运行级别</p><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul><li>man获得帮助信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">基本语法：man <span class="token punctuation">[</span>命令或配置文件<span class="token punctuation">]</span>（功能描述：获得帮助信息）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在linux下隐藏文件是以 “.” 开头的</p><ul><li>help指令</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">基本语法：help 命令 （功能描述：获得shell内置命令的帮助信息）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><ul><li>pwd指令</li></ul><pre class="line-numbers language-none"><code class="language-none">基本语法：pwd    （功能描述：显示当前工作目录的绝对路径）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>ls指令</li></ul><pre class="line-numbers language-none"><code class="language-none">基本语法：ls [选项] [目录或是文件]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用选项</p><p>-a ： 显示当前目录所有的文件和目录，包括隐藏的</p><p>-l ： 以列表的方式显示信息</p><ul><li>cd指令</li></ul><pre class="line-numbers language-none"><code class="language-none">基本语法：cd [参数] （功能描述：切换到指定的目录）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>理解：绝对路径和相对路径（相对路径是针对当前位置的路径）</p><p>cd ~ 或者cd 回到自己的家目录</p><p>cd … 回到当前目录的上一级目录</p><ul><li>mkdir指令</li></ul><pre class="line-numbers language-none"><code class="language-none">基本语法：mkdir [选项] 要创建的目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>理解：mkdir指令用于创建目录（默认只能创建一级目录）</p><p>-p :创建多级目录</p><ul><li>rmdir指令（用于删除空目录）</li></ul><pre class="line-numbers language-none"><code class="language-none">基本语法：rmdir [选项] 要删除的空目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用细节：</p><p>rmdir删除的是空目录，如果欲删除的目录下有内容则无法删除</p><p>==如果需要删除非空目录，需要使用rm -rf 要删除的目录</p><ul><li>touch指令（用于创建空文件）</li></ul><pre class="line-numbers language-none"><code class="language-none">touch 文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>cp指令（copy拷贝文件导指定目录）</li></ul><pre class="line-numbers language-none"><code class="language-none">cp [选项] source dest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用选项：-r 递归复制真个文件夹</p><p>应用实例:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">将 /home/hello.txt 拷贝到 /home/bbb 目录下<span class="token function">cp</span> /home/hello.txt /home/bbb递归复制整个文件夹，将/home/aaa 目录下的文件全部拷贝到/home/bbb下<span class="token function">cp</span> -r /home/aaa /hom/bbb<span class="token punctuation">(</span>是将整个目录和目录本身拷贝进来<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>rm指令（remove，移除文件或目录）=一定要小心！！！</li></ul><pre class="line-numbers language-none"><code class="language-none">基本语法：rm [选项] 要删除的文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用选项</p><p>-r : 递归删除整个文件夹</p><p>-f ：强制删除不提示</p><p>使用细节：强制删除不提示的方式，带上-f参数即可</p><ul><li>cat指令（查看文件内容）</li></ul><pre class="line-numbers language-none"><code class="language-none">cat [选项] 要查看的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用选项： -n 显示行号</p><p>使用细节：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 |more</p><pre class="line-numbers language-none"><code class="language-none">cat -n /etc/profile |more<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入到控制台</p><p>查看历史</p><p>过滤查找，带行号</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="linux" scheme="http://example.com/categories/linux/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="http://example.com/posts/7f1ae090.html"/>
    <id>http://example.com/posts/7f1ae090.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-06-05T03:09:20.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java-中-sleep-方法和-wait-方法的区别？"><a href="#Java-中-sleep-方法和-wait-方法的区别？" class="headerlink" title="Java 中 sleep 方法和 wait 方法的区别？"></a>Java 中 sleep 方法和 wait 方法的区别？</h2><p>​    虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p><ol><li>sleep()是Thread类中的方法，而wait()则是<a href="https://so.csdn.net/so/search?q=Object%E7%B1%BB&amp;spm=1001.2101.3001.7020">Object类</a>中的方法。</li></ol><h2 id="程序计数器-线程私有"><a href="#程序计数器-线程私有" class="headerlink" title="程序计数器(线程私有)"></a>程序计数器(线程私有)</h2><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。</p><p>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。</p><p>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</p><h2 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h2><p>首先说一下迭代器模式，它是 Java 中常用的设计模式之一。用于顺序访问集合对象的元素，无需知道集合对象的底层实现。</p><p> Iterator 是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。</p><p>缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">调用 it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 会返回迭代器的下一个元素，并且更新迭代器的状态。调用 it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 用于检测集合中是否还有元素。调用 it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 将迭代器返回的元素删除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 引入 ArrayList 和 Iterator 类</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunoobTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建集合</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sites <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sites<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Google"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sites<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Runoob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sites<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Taobao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sites<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Zhihu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取迭代器</span>        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> sites<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 输出集合中的第一个元素</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep()方法和 yield()方法有什么区别？"></a>线程的 sleep()方法和 yield()方法有什么区别？</h2><p><strong>1、</strong> sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p><p><strong>2、</strong> 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p><p><strong>3、</strong> sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p><p><strong>4、</strong> sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p><h2 id="volatile关键字的作用和原理"><a href="#volatile关键字的作用和原理" class="headerlink" title="volatile关键字的作用和原理"></a>volatile关键字的作用和原理</h2><blockquote><p>volatile关键字的作用</p></blockquote><p>1、保证可见性；<br>2、防止指令重排；<br>3、但是不保证<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&amp;spm=1001.2101.3001.7020">原子性</a>；</p><blockquote><p>可见性是什么？</p></blockquote><p>在JMM（java memory <a href="https://so.csdn.net/so/search?q=model&amp;spm=1001.2101.3001.7020">model</a>）java内存模型中，其他线程从主内存空间把值拷贝到自己的工作空间，线程修改之后的值会返回给主内存，主内存会通知其他线程，此为可见性。</p><blockquote><p>指令重排</p></blockquote><p>CPU为了执行效率会<a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91&amp;spm=1001.2101.3001.7020">并发</a>执行操作指令，volatile可以使指令一个一个的执行。</p><blockquote><p>为什么不保证原子性</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//自定义的类</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyTest</span> <span class="token punctuation">{</span>  <span class="token comment">//类的内部成员变量num</span>  <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">numPlusPlus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如说，在多个线程同时执行num++时候，他们都是把num值copy到自己的工作内存中，++后再写回主内存。问题出现了这里，比如说A线程刚要写回内存时候，被抢占挂起了，然后B线程写进去了，然后通知所有线程修改了。但是这个时间太短了，所以A也写进来了，把刚刚的覆盖了。</p><blockquote><p>如何解决原子性问题</p></blockquote><p>1、通过synchronized关键字。(不建议，因为volatile自身就是轻量级的，可以说是乞丐版本的synchronized，加这个太重了)<br>2、通过使用AtomicXX，不加锁,采用<a href="https://so.csdn.net/so/search?q=CAS&amp;spm=1001.2101.3001.7020">CAS</a>（compareAndSet）解决。其本质是使用UnSafe本地方法（CPU原语）。<br>3、使用LongAdder:最快（在线程多的情况下，使用分段锁）1、通过synchronized关键字。</p><h2 id="Java-中能创建-volatile-数组吗？"><a href="#Java-中能创建-volatile-数组吗？" class="headerlink" title="Java 中能创建 volatile 数组吗？"></a>Java 中能创建 volatile 数组吗？</h2><p>可以创建volatile数组，但是volatile只保证对数组的引用可见，即如果是改变引用只向的数组，将受到volatile的保护，但是对多个线程想要去改变数组里面的元素，volatile不能保证。</p><h2 id="java-equals于"><a href="#java-equals于" class="headerlink" title="java equals于=="></a>java equals于==</h2><blockquote><p>什么时候不同</p></blockquote><p>对于<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020">字符串</a>变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。</p><p>“==”比较两个变量本身的值，即两个对象在<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>中的首地址。</p><p>“equals()”比较字符串中所包含的内容是否相同。</p><blockquote><p>注意</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span>s3 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">,</span> s4 <span class="token operator">=</span><span class="token string">"abc"</span> <span class="token punctuation">;</span>s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>s1==s2  是 false   //两个变量的内存地址不一样，也就是说它们指向的对象不 一样，故不相等。</p><p>s1.equals(s2) 是 true  //两个变量的所包含的内容是abc，故相等。</p><p>（上述的是因为string重写了equals方法，比较的是值）</p><blockquote><p>重点1</p></blockquote><p>如果：          StringBuffer s1 = new StringBuffer(“a”);</p><p>StringBuffer s2 = new StringBuffer(“a”);</p><p>结果：           s1.equals(s2)  //是false</p><p>解释：StringBuffer类中<strong>没有重新定义equals这个方法</strong>，因此这个方法就来自Object类，</p><p>而Object类中的equals方法是用来比较“地址”的，所以等于false</p><blockquote><p>重点2</p></blockquote><p>对于s3和s4来说，有一点不一样要引起注意，由于s3和s4是两个字符</p><p>串常量所生成的变量，其中所存放的内存地址是相等的，</p><p>所以s3==s4是true(即使没有s3=s4这样一个赋值语句)</p><blockquote><p>重点3</p></blockquote><p>对于非字符串变量来说，”==”和”equals”方法的作用是相同的都是用来比较其</p><p>对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。</p><h2 id="如何判断对象是否是垃圾？"><a href="#如何判断对象是否是垃圾？" class="headerlink" title="如何判断对象是否是垃圾？"></a>如何判断对象是否是垃圾？</h2><p><strong>引用计数：</strong>在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。</p><p><strong>可达性分析：</strong>主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。</p><h2 id="线程四种创建方式？"><a href="#线程四种创建方式？" class="headerlink" title="线程四种创建方式？"></a>线程四种创建方式？</h2><blockquote><p>创建线程的四种方式</p></blockquote><p><strong>继承Thread类</strong>（Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法）,<strong>实现Runnable接口</strong>,<strong>实现Callable接口</strong>,<strong>线程池</strong>。</p><blockquote><p>线程池的好处</p></blockquote><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p><h2 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h2><p>1、互斥条件：一个资源每次只能被一个进程使用；</p><p>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</p><p>3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；</p><p>4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；</p><h2 id="什么是IoC和DI？"><a href="#什么是IoC和DI？" class="headerlink" title="什么是IoC和DI？"></a>什么是IoC和DI？</h2><p>IoC(控制反转) 、DI(依赖注入)</p><blockquote><p>ioc</p></blockquote><p>IOC—Inversion of Control，即“<a href="https://so.csdn.net/so/search?q=%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC&amp;spm=1001.2101.3001.7020">控制反转</a>”，不是什么技术，而是一种设计思想。它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><blockquote><p>di</p></blockquote><p> DI—Dependency Injection，即“<a href="https://so.csdn.net/so/search?q=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&amp;spm=1001.2101.3001.7020">依赖注入</a>”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><blockquote><p>两者关系</p></blockquote><p>在平时的Java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象或者依赖对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，*<strong>*创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起**</strong>，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象B之后，两个人一起协作完成要完成的工作即可。</p><p>　　所以控制反转IOC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IOC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IOC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IOC容器了，通过IOC容器来建立它们之间的关系。<br>　　DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结道：控制的什么被反转了？就是获得依赖对象的方式反转了。</p><h2 id="Java的内存模型是什么？（JMM是什么？）"><a href="#Java的内存模型是什么？（JMM是什么？）" class="headerlink" title="Java的内存模型是什么？（JMM是什么？）"></a>Java的内存模型是什么？（JMM是什么？）</h2><p>JMM 是<a href="https://so.csdn.net/so/search?q=Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020">Java内存模型</a>（ Java Memory Model），简称JMM。它本身只是一个抽象的概念，并不真实存在，它描述的是一种规则或规范。通过这组规范，定义了程序中对各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><p> 计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><blockquote><p>三大特性</p></blockquote><p>1.原子性<br>一个或多个操作，要么全部执行（执行的过程是不会被任何因素打断的），要么全部不执行。</p><p>2.可见性<br>只要有一个线程对共享变量的值做了修改，其他线程都将马上收到通知，立即获得最新值。</p><p>3.有序性<br> 有序性可以总结为：在本线程内观察，所有的操作都是有序的；而在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as-if-serial 语义：线程内似表现为串行，后半句是指：“指令重排序现象”和“工作内存与主内存同步延迟现象”。处理器为了提高程序的运行效率，提高并行效率，可能会对代码进行优化。编译器认为，重排序后的代码执行效率更优。这样一来，代码的执行顺序就未必是编写代码时候的顺序了，在多线程的情况下就可能会出错。</p><h2 id="java类型转换规则"><a href="#java类型转换规则" class="headerlink" title="java类型转换规则"></a>java类型转换规则</h2><p>自动转换规则</p><ol><li><p>布尔型不参与转换</p></li><li><p>转换规则（总）： byte/char/short -&gt; int -&gt; long -&gt; float -&gt; double</p></li><li><p>转换规则（详）<br>3.1 操作数之一为double，则另一个操作数先被转化为double，再参与算术运算；<br>3.2 操作数均不为double，当操作数之一为float，则另一操作数先被转换为float，再参与运算；<br>3.3 操作数均不为double或float，当操作数之一为long，则另一操作数先被转换为long，再参与算术运算；<br>3.4 操作数均不为double、float或long，则操作数先被转换为int，再参与运算。</p></li><li><p>特殊：<br>4.1 如采用+=、*=等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型。<br>4.2 当运算符为自动递增运算符（++）或自动递减运算符（–）时，如果操作数为byte，short或char类型不发生改变；</p><blockquote><p>Java的char能否存汉字<br>当然可以 Java的char类型占两个字节，存的是Uicode码，其中就包含了汉字。怎么将 byte 转换为 String？</p></blockquote></li></ol><h2 id="怎么将-byte-转换为-String？"><a href="#怎么将-byte-转换为-String？" class="headerlink" title="怎么将 byte 转换为 String？"></a>怎么将 byte 转换为 String？</h2><p>一、String转化为byte[]</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Convert to byte[]</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"bytes输出是："</span><span class="token operator">+</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>二、byte[]转化为string        </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Check converted string against original String</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Decoded String : "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="什么是隐式转换，什么是显式转换"><a href="#什么是隐式转换，什么是显式转换" class="headerlink" title="什么是隐式转换，什么是显式转换"></a>什么是隐式转换，什么是显式转换</h2><p>显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。</p><h2 id="Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型"><a href="#Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型" class="headerlink" title="Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型"></a>Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型</h2><p>Char类型可以隐式转成int,double类型，但是不能隐式转换成string（不能自动转换，一个是值类型，一个是引用类型 ）；如果char类型转成byte，short类型的时候，需要强转。</p><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h2><p>notify()只能唤醒一个wait()线程,然而notifyAll()可以唤醒多个wait()线程;</p><h2 id="Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="Java 中的 LinkedList 是单向链表还是双向链表？"></a>Java 中的 LinkedList 是单向链表还是双向链表？</h2><p>双向列表</p><h2 id="接口特征"><a href="#接口特征" class="headerlink" title="接口特征"></a>接口特征</h2><p>接口的特征有：1、接口使用interface关键字修饰；2、接口不可以实例化；3、实现类一定要实现接口的所有方法（抽象类除外）；4、实现类可以实现多个接口；5、接口中的常量都是静态常量</p><p><em>接口中</em>只能有static、final<em>变量</em>,不能有其他<em>变量</em>。</p><h2 id="什么是过滤器？怎么创建一个过滤器"><a href="#什么是过滤器？怎么创建一个过滤器" class="headerlink" title="什么是过滤器？怎么创建一个过滤器"></a>什么是过滤器？怎么创建一个过滤器</h2><p>个人理解，拦截并处理（可能是增强等等）</p><blockquote><p>如何创建过滤器</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210228215939362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWNzZ29hdA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>主要是实现过滤器接口，重写dofilter</p><h2 id="Java中各种数据默认值"><a href="#Java中各种数据默认值" class="headerlink" title="Java中各种数据默认值"></a>Java中各种数据默认值</h2><p><strong>1、</strong> Byte,short,int,long默认是都是0</p><p><strong>2、</strong> Boolean默认值是false</p><p><strong>3、</strong> Char类型的默认值是’’</p><p><strong>4、</strong> Float与double类型的默认是0.0</p><p><strong>5、</strong> 对象类型的默认值是null</p><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><p><strong>1、</strong> 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</p><p><strong>2、</strong> synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p><p><strong>3、</strong> synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p><p><strong>4、</strong> 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><p>5、 synchronized只支持非公平锁,lock支持非公平锁和公平锁;</p><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h2><p><img src="/../images/typora-user-images/image-20230524095109179.png" alt="image-20230524095109179"></p><p><img src="/../images/typora-user-images/image-20230524095302561.png" alt="image-20230524095302561"></p><h2 id="什么是Vector"><a href="#什么是Vector" class="headerlink" title="什么是Vector"></a>什么是Vector</h2><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多</p><p>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。</p><h2 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h2><p>不必须</p><p>1.如果一个类使用了<a href="https://so.csdn.net/so/search?q=abstract&amp;spm=1001.2101.3001.7020">abstract</a>关键字修饰，那么这个类就是一个抽象类。</p><p>2.抽象类可以没有<a href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95&amp;spm=1001.2101.3001.7020">抽象方法</a></p><p>3.一个类如果包含抽象方法，那么这个类必须是抽象类，否则编译就会报错。</p><p>4.最关键的一点就是如果一个类是抽象类，那么这个类是不能被实例化的。</p><blockquote><p>抽象类有构造方法吗</p></blockquote><p>可以有构造方法。构造方法的作用有两个，一个是初始化变量，另外一个是实例化对象，抽象类不能实例化，还可以做另外一个作用。</p><h2 id="能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h2><p>我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化， int 类型<br>的高 24 位将会被丢弃，因为 byte 类型的范围是从 -128 到 127</p><h2 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h2><p>1、抽象类可以有构造方法，接口中不能有构造方法。<br>2、接口的方法默认是 public，所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。<br>3、接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。<br>4、一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。<br>5、接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（不能使用 private 关键字修饰！）。<br>6、从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p><h2 id="如何合理配置线程池大小"><a href="#如何合理配置线程池大小" class="headerlink" title="如何合理配置线程池大小"></a>如何合理配置线程池大小</h2><p>1、CPU密集型<br>特点：更多的CPU在做计算，一直在工作，等待时间很少<br>推荐：线程数少一点<br>一般：CPU内核数+1</p><p>2、IO密集型<br>特点：更多的时候线程在等待响应<br>推荐：线程数多一些<br>一般：CPU内核数 * 2 或者（线程等待时间与线程CPU时间之比 + 1） * CPU数目</p><p>3、混合型<br>特点：啥任务都有<br>推荐：将CPU密集和IO密集的操作分成2个线程池去执行<br>一般：2个线程池</p><h2 id="直接缓冲区和非直接缓冲区的区别"><a href="#直接缓冲区和非直接缓冲区的区别" class="headerlink" title="直接缓冲区和非直接缓冲区的区别"></a>直接缓冲区和非直接缓冲区的区别</h2><p>1.直接缓冲区是建立在系统的物理内存的，而非直接缓冲区是建立在jvm内存，jvm内存是有上限的，所以速度会很慢</p><p>2使用直接缓冲区会对你的物理内存有一定的影响。而非直接缓冲区不会，但是会慢。</p><h2 id="如何决定使用-HashMap-还是TreeMap？"><a href="#如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是TreeMap？"></a>如何决定使用 HashMap 还是TreeMap？</h2><p>HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。<br>HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。<br>HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。<br>两个都是非线程安全</p><h2 id="ArrayList的优缺点"><a href="#ArrayList的优缺点" class="headerlink" title="ArrayList的优缺点"></a>ArrayList的优缺点</h2><blockquote><p>ArrayList的优点如下：</p></blockquote><p>  ArrayList底层以数组实现，是一种随机访问模式。ArrayList实现了RandomAccess接口，因此查找的时候非常快；<br>  ArrayList在顺序添加一个元素的时候非常方便；<br>  ArrayList 比较适合顺序添加、随机访问的场景；</p><blockquote><p>ArrayList的缺点如下：</p></blockquote><p>  删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；<br>  插入元素的时候，也需要做一次元素复制操作，缺点同上；</p><h2 id="构造方法能不能重写？能不能重载？"><a href="#构造方法能不能重写？能不能重载？" class="headerlink" title="构造方法能不能重写？能不能重载？"></a>构造方法能不能重写？能不能重载？</h2><p>不能重写但是可以重载，因为构造方法不能被继承。如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有super();语句,即调用父类不带参数的构造方法。如果类里定义一个或多个构造方法，那么java不提供默认的构造方法(不带参数的构造方法)。</p><h2 id="被引用的对象就一定能存活吗？"><a href="#被引用的对象就一定能存活吗？" class="headerlink" title="被引用的对象就一定能存活吗？"></a>被引用的对象就一定能存活吗？</h2><p>不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收</p><h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><blockquote><p>java.lang.NullPointerException(空指针异常)</p></blockquote><blockquote><p>java.lang.IllegalArgumentException( 方法的参数错误)</p></blockquote><p>比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。</p><blockquote><p>java.lang.ArithmeticException 数学运算异常</p></blockquote><p>当算术运算中出现了除以零这样的运算就会出这样的异常。</p><blockquote><p>java.lang.ClassCastException数据类型转换异常</p></blockquote><p>当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str <span class="token operator">=</span> obj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>java.lang.NoSuchMethodException方法不存在异常</p></blockquote><p>当程序试图通过来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常</p><blockquote><p>java.lang.OutOfMemoryException内存不足错误</p></blockquote><p>当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误</p><h2 id="抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？"><a href="#抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被synchronized修饰？" class="headerlink" title="抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？"></a>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</h2><p>都不能。抽象方法需要子类重写，而<strong>静态的方法是无法被重写</strong>的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p><h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><ul><li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</p></li><li><p>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法</p></li><li><p>使用interrupt方法中断线程</p></li></ul><h2 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h2><p>线程池的5种状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。</p><p>RUNNING：运行状态，线程池创建好之后就会进入此状态，如果不手动调用关闭方法，那么线程池在整个程序运行期间都是此状态。</p><p>SHUTDOWN：关闭状态，不再接受新任务提交，但是会将已保存在任务队列中的任务处理完。</p><p>STOP：停止状态，不再接受新任务提交，并且会中断当前正在执行的任务、放弃任务队列中已有的任务。</p><p>TIDYING：整理状态，所有的任务都执行完毕后（也包括任务队列中的任务执行完），当前线程池中的活动线程数降为 0 时的状态。到此状态之后，会调用线程池的 terminated() 方法。</p><p>TERMINATED：销毁状态，当执行完线程池的 terminated() 方法之后就会变为此状态。</p><h2 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h2><p><img src="https://img-blog.csdnimg.cn/fc1a5fd75ee04db89c4c11bea770e064.png" alt="img"></p><p>1.新建状态（New）：</p><p>创建一个新的线程对象。</p><p>2.就绪状态（Runnable）:</p><p>线程创建对象后，其他线程调用start()方法，该线程处于就绪状态，资源已经准备就绪，等待CPU资源。</p><p>3.运行状态（Running）：</p><p>处于就绪状态的线程获取到CPU资源后进入运行状态。</p><p>4.阻塞状态（Blocked）：</p><p>阻塞状态是线程由于某些原因放弃CPU使用，暂时停止运行。</p><p>（1）等待阻塞：线程调用start（）方法，JVM会把这个线程放入等待池中，该线程需要其他线程调用notify()或notifyAll()方法才能被唤醒。</p><p>（2）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入锁池中。</p><p>（3）其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p><p>5.终止状态（Terminated）：</p><p>线程run（）方法运行完毕，该线程结束。</p><h2 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h2><p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p><h2 id="Java-中用到的线程调度算法是什么？"><a href="#Java-中用到的线程调度算法是什么？" class="headerlink" title="Java 中用到的线程调度算法是什么？"></a>Java 中用到的线程调度算法是什么？</h2><p><strong>有两种调度模型：分时调度模型和抢占式（java默认使用）调度模型。</strong></p><ul><li><strong>分时调度模型：</strong> 平均分配每个线程占用的 CPU 的时间片。</li><li><strong>抢占式调度模型：</strong> 让优先级高的线程占用CPU，如果线程优先级相同，那么就随机选择一个线程。</li></ul><h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><h2 id="对象都是优先分配在年轻代上的吗？"><a href="#对象都是优先分配在年轻代上的吗？" class="headerlink" title="对象都是优先分配在年轻代上的吗？"></a>对象都是优先分配在年轻代上的吗？</h2><p>不是</p><p>平时代码创建出来的对象，一般分为两种：</p><p>​    一种是短期存活的，分配在Java<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">堆内存</a>之后，迅速使用完就会被垃圾回收，会分配到年轻代里。</p><p>​    另一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停地去使用，会分配到老年代里。</p><h2 id="JAVA如何判断两个类是否相等？"><a href="#JAVA如何判断两个类是否相等？" class="headerlink" title="JAVA如何判断两个类是否相等？"></a>JAVA如何判断两个类是否相等？</h2><p> 两个类是否相等，取决于他们是否由统一个<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&amp;spm=1001.2101.3001.7020">类加载</a>器来加载。如果他们来自不同的类加载器，哪么就算这两个类来自同一Class文件，他们也是不相等的。</p><p>同一个加载器，那么要判断两个类是否相等我们则可以简单的通过他们的Class对象是否是同一个对象即可。</p><h2 id="Integer和int的区别"><a href="#Integer和int的区别" class="headerlink" title="Integer和int的区别"></a>Integer和int的区别</h2><p>1、类型不同:Integer是对象类型,int是基本数据类型。Integer是int的包装类。</p><p>2、Integer变量需要实例化之后才能使用，int则不需要。</p><p>3、Integer的默认值是null,int的默认值是0</p><p>4、Integer是对象的引用，当new一个Integer对象时，实际上是生成一个指针指向这个对象；而int则是直接存储数据</p><blockquote><p>注意</p></blockquote><p>对于非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true；</p><p>如果两个变量的值不在这个区间，则比较结果为false。</p><h2 id="Java线程唤醒与阻塞的常用方法"><a href="#Java线程唤醒与阻塞的常用方法" class="headerlink" title="Java线程唤醒与阻塞的常用方法"></a>Java线程唤醒与阻塞的常用方法</h2><blockquote><p>sleep() 方法</p></blockquote><p>　　sleep(毫秒)，指定以毫秒为单位的时间，使线程在该时间内进入线程阻塞状态，期间得不到cpu的时间片，等到时间过去了，线程重新进入可执行状态。(暂停线程，不会释放锁)</p><blockquote><p>yield() 方法：</p></blockquote><p>　　会使得线程放弃当前分得的cpu时间片，但此时线程仍然处于可执行状态，随时可以再次分得cpu时间片。yield()方法只能使同优先级的线程有执行的机会。调用 yield()的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。(暂停当前正在执行的线程，并执行其他线程，且让出的时间不可知)</p><blockquote><p>wait() 和 notify() 方法</p></blockquote><p>两个方法搭配使用，wait()使线程进入阻塞状态，调用notify()时，线程进入可执行状态。wait()内可加或不加参数，加参数时是以毫秒为单位，当到了指定时间或调用notify()方法时，进入可执行状态。(属于Object类，而不属于Thread类，wait()会先释放锁住的对象，然后再执行等待的动作。由于wait()所等待的对象必须先锁住，因此，它只能用在同步化程序段或者同步化方法内，否则，会抛出异常IllegalMonitorStateException.)</p><h2 id="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"><a href="#如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？" class="headerlink" title="如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？"></a>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</h2><p><strong>1、</strong> 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。</p><p><strong>2、</strong> 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</p><h2 id="频繁fullGc"><a href="#频繁fullGc" class="headerlink" title="频繁fullGc"></a>频繁fullGc</h2><p> 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁gc)</p><p>是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了)</p><h2 id="为什么HashTable是线程安全的？"><a href="#为什么HashTable是线程安全的？" class="headerlink" title="为什么HashTable是线程安全的？"></a>为什么HashTable是线程安全的？</h2><p>HashMap是线程不安全的</p><p>Hashtable下面代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//get它搞成了同步方法，保证了get的安全性</span> <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>       ……    <span class="token punctuation">}</span><span class="token comment">//synchronized,同样</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>       ……    <span class="token punctuation">}</span><span class="token comment">//也是搞成了同步方法</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     ……    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？"><a href="#finalize-方法什么时候被调用？析构函数-finalization-的目的是什么？" class="headerlink" title="finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？"></a>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</h2><p>调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。 </p><p>  finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。</p><p>。finalize()方法允许被重写，一般在该方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><h2 id="用最有效率的方法计算2乘以8？"><a href="#用最有效率的方法计算2乘以8？" class="headerlink" title="用最有效率的方法计算2乘以8？"></a>用最有效率的方法计算2乘以8？</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">2&lt;&lt; 3，(左移三位)因为将一个数左移n位，就相当于乘以了2的n次方<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="什么是JDK-什么是JRE？"><a href="#什么是JDK-什么是JRE？" class="headerlink" title="什么是JDK?什么是JRE？"></a>什么是JDK?什么是JRE？</h2><p>JDK = JRE + Java 开发工具包 [Java,Javac,Javadoc,Javap等]</p><p>JRE = JVM + Java 的核心类库 [类]</p><p>JRE顾名思义是java运行时环境</p><p>JDK顾名思义是java开发工具包</p><p>JDK（Java Development Kit）是Java的开发工具包，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等</p><h2 id="如何通过获取和设置对象私有字段的值？"><a href="#如何通过获取和设置对象私有字段的值？" class="headerlink" title="如何通过获取和设置对象私有字段的值？"></a>如何通过获取和设置对象私有字段的值？</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">JsonProperty</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysUser</span> <span class="token punctuation">{</span>    <span class="token comment">// @JsonProperty("roleIdList")</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> roleIds<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getRoleIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> roleIds<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRoleIds</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> roleIds<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>roleIds <span class="token operator">=</span> roleIds<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是获取</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">JsonProperty</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">getFieldValueByObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token class-name">String</span> targetFieldName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token comment">// 获取该对象的Class</span><span class="token class-name">Class</span> objClass <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化返回值</span><span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 获取所有的属性数组</span><span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> objClass<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> field <span class="token operator">:</span> fields<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 属性名称</span><span class="token class-name">String</span> currentFieldName <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">// 获取属性上面的注解 import com.fasterxml.jackson.annotation.JsonProperty;</span><span class="token comment">/** * 举例： @JsonProperty("roleIds")              * private String roleIds; */</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token keyword">boolean</span> has_JsonProperty <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">JsonProperty</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>has_JsonProperty<span class="token punctuation">)</span> <span class="token punctuation">{</span>currentFieldName <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">JsonProperty</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>currentFieldName <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>currentFieldName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>targetFieldName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token comment">// 通过拿到该属性在此对象中的值(也可能是个对象)</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 安全性异常</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalArgumentException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 非法参数</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 无访问权限</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要的</p><p>Field[] fields = objClass.getDeclaredFields();</p><p>field.setAccessible(true);</p><h2 id="并发编程三要素"><a href="#并发编程三要素" class="headerlink" title="并发编程三要素"></a>并发编程三要素</h2><p><strong>1、原子性</strong></p><p>原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操</p><p>作打断，要么就全部都不执行。</p><p><strong>2、可见性</strong></p><p>可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他</p><p>线程可以立即看到修改的结果。</p><p><strong>3、有序性</strong></p><p>有序性，即程序的执行顺序按照代码的先后顺序来执行。</p><h2 id="讲讲什么情况下会出现内存泄漏？"><a href="#讲讲什么情况下会出现内存泄漏？" class="headerlink" title="讲讲什么情况下会出现内存泄漏？"></a>讲讲什么情况下会出现内存泄漏？</h2><p>内存泄漏的原因很简单：</p><p><strong>1、</strong> 对象是可达的(一直被引用)</p><p><strong>2、</strong> 但是对象不会被使用</p><blockquote><p>例子</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Object</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 设置为空，该对象不再使用</span>            object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 但是set集合中还维护object的引用，gc不会回收object对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。</p><h2 id="内存溢出常见原因及解决方法"><a href="#内存溢出常见原因及解决方法" class="headerlink" title="内存溢出常见原因及解决方法"></a>内存溢出常见原因及解决方法</h2><p>引起内存溢出的原因有很多种，常见的有以下几种：</p><p>1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据。</p><p>解决方法：检查对数据库查询中，是否有一次获得全部数据的查询；对于数据库查询尽量采用分页的方式查询。</p><p>2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收。</p><p>解决方法：检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。（内存泄露）</p><p>3.代码中存在死循环或循环产生过多重复的对象实体。</p><p>解决方法：检查代码中是否有死循环或递归调用；检查是否有大循环重复产生新对象实体。</p><p>4.使用的第三方软件中的BUG。</p><p>解决方法：使用内存查看工具动态查看内存使用情况。</p><p>5.启动参数内存值设定的过小；</p><p>解决方法：修改JVM启动参数(-Xms，-Xmx)，直接增加内存。</p><h2 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><p><strong>悲观锁：</strong></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p><strong>乐观锁：</strong></p><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h2 id="为什么-Thread-类的-sleep-和-yield-方法是静态的？"><a href="#为什么-Thread-类的-sleep-和-yield-方法是静态的？" class="headerlink" title="为什么 Thread 类的 sleep()和 yield ()方法是静态的？"></a>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</h2><h2 id="Java对象创建过程"><a href="#Java对象创建过程" class="headerlink" title="Java对象创建过程"></a>Java对象创建过程</h2><p>java创建对象的过程主要分为一下五个步骤：<br>（1）类加载检查<br>Java虚拟机（jvm）在读取一条new指令时候，首先检查能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化。如果没有，则会先执行相应的类加载过程。</p><p>（2）内存分配<br>在通过（1）后，则开始为新生的对象分配内存。该对象所需的内存大小在类加载完成后便可确定，因此为每个对象分配的内存大小是确定的。而分配方式主要有两种，分别为：</p><p>1.指针碰撞</p><p>应用场合：堆内存规整（通俗的说就是用过的内存被整齐充分的利用，用过的内存放在一边，没有用过的放在另外一边，而中间利用一个分界值指针对这两边的内存进行分界，从而掌握内存分配情况）。</p><p>即在开辟内存空间时候，将分界值指针往没用过的内存方向移动向应大小位置即可）。</p><p>将堆内存这样划分的代表的GC收集器算法有：Serial，ParNew</p><p>2.空闲列表</p><p>应用场合;堆内存不规整（虚拟机维护一个可以记录内存块是否可以用的列表来了解内存分配情况）</p><p>即在开辟内存空间时候，找到一块足够大的内存块分配给该对象即可，同时更新记录列表。</p><p>将堆内存这样划分的代表的GC收集器算法有：CMS</p><p>（3）初始化默认值<br>第（2）步完成后，紧接着，虚拟机需要将分配到的内存空间都进行初始化（即给一些默认值），这将做是为了保证对象实例的字段在Java代码中可以在不赋初值的情况下使用。程序可以访问到这些字段对用数据类型的默认值。</p><p>（4）设置对象头<br>初始化（3）完成后，虚拟机对对象进行一些简单设置，如标记该对象是那个类的实例，这个对象的hash码，该对象所处的年龄段等等（这些可以理解为对象实例的基本信息）。这些信息被卸载对象头中。jvm根据当前的运行状态，会给出不同的设置方式。</p><p>（5）执行初始化方法<br>在（4）完成后，最后执行由开发人员编写的对象的初始化方法，把对象按照开发人员的设计进行初始化，一个对象便创建出来了。</p><h2 id="会导致类初始化"><a href="#会导致类初始化" class="headerlink" title="会导致类初始化"></a>会导致类初始化</h2><blockquote><p><strong>会导致 类初始化 的情况</strong></p></blockquote><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的 静态变量 或 静态方法 时</li><li>子类初始化，如果父类还未初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><blockquote><p><strong>不会导致 类初始化 的情况</strong></p></blockquote><ul><li>访问 类的 static final 静态变量（基本类型和字符型）不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载的 loadClass 方法</li><li>Class.forName 的参数2 为 false 时</li></ul><h2 id="final不可变对象，它对写并发应用有什么帮助？"><a href="#final不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="final不可变对象，它对写并发应用有什么帮助？"></a>final不可变对象，它对写并发应用有什么帮助？</h2><p>不可变对象天生是线程安全的。</p><h2 id="Java中操作字符串使用哪个类？"><a href="#Java中操作字符串使用哪个类？" class="headerlink" title="Java中操作字符串使用哪个类？"></a>Java中操作字符串使用哪个类？</h2><p>操作字符串的类主要用三个,分别是String类,StringBuffer类和StringBuilder类.</p><h2 id="MyBatis中使用-和-书写占位符有什么区别？"><a href="#MyBatis中使用-和-书写占位符有什么区别？" class="headerlink" title="MyBatis中使用#和$书写占位符有什么区别？"></a>MyBatis中使用#和$书写占位符有什么区别？</h2><p>#将传入的数据都当成一个字符串，会对传入的数据自动加上引号；</p><blockquote><p>#</p></blockquote><p>使用#传入参数是，sql语句解析是会加上””,比如 select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是</p><p>select * from table where name = ‘小李’，</p><blockquote><p>$</p></blockquote><p>另外一种场景是，如果你要做动态的排序，比如 order by column，这个时候务必要用${},因为如果你使用了#{},那么打印出来的将会是</p><p>select * from table order by ‘name’ ,这样是没用，</p><blockquote><p>注意</p></blockquote><p>目前来看，能用#就不要用$,使用 $ 占位符可能会导致SQL注入攻击</p><h2 id="String、StringBuffer、StringBuilder的区别是什么"><a href="#String、StringBuffer、StringBuilder的区别是什么" class="headerlink" title="String、StringBuffer、StringBuilder的区别是什么"></a>String、StringBuffer、StringBuilder的区别是什么</h2><ul><li>String：不可变</li><li>StringBuffer：可变的，线程安全</li><li>StringBuilder：可变的，线程不安全</li></ul><blockquote><p>线程安全：</p></blockquote><p>String因为是不可变，也可理解为常量，因此是线程安全的。而StringBuffer 和 StringBuilder 继承自AbstractStringBuilder，而AbstractStringBuilder定义了一些基本字符操作，如append、insert、indexOf等，在StringBuffer的方法中加了同步锁，因此StringBuffer是线程安全的。而StringBuilder没有相应的锁，所以非线程安全。</p><blockquote><p>可变性：</p></blockquote><p>简单而言，String类使用Final关键字字符数组保存字符串，private final char[] value，所以String是不可变的。而StringBuffer 和 StringBuilder 都是继承自AbstractStringBuilder，而AbstractStringBuilder 也是使用使用字符s数组保护字符串，不过没有final关键字，char[] value，所以后两者是可变的</p><blockquote><p>对三者使用的总结：</p></blockquote><p>操作量少：String</p><p>单线程操作量大：StringBuilder</p><p>多线程操作量大：StringBuffer</p><h2 id="如何通过创建对象？"><a href="#如何通过创建对象？" class="headerlink" title="如何通过创建对象？"></a>如何通过创建对象？</h2><p><strong>1、</strong> 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()</p><p><strong>2、</strong> 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);</p><h2 id="运行时常量池溢出的原因？"><a href="#运行时常量池溢出的原因？" class="headerlink" title="运行时常量池溢出的原因？"></a>运行时常量池溢出的原因？</h2><p><strong>不断创建常量，比如字符串等。</strong></p><h2 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h2><p>json的全称为：JavaScript Object Notation，是一种轻量级的数据交互格式。</p><blockquote><p>优点</p></blockquote><p>1、方便于传输，较少冗余的字符。当然直接传二进制是最好的，但面临难解析的问题。亦可以是xml、纯字符串的方式，但json有其独到的好处。google有个自己的协议，叫protobuf，有兴趣可了解一下。2、方便转换。有很多的json api提供了json字符串转成对象、对象转换成json串的方法。3、易于阅读。json代码的良好结构，可以很直观地了解存的是什么内容。</p><h2 id="Minor-GC与Full-GC分别在什么时候发生？"><a href="#Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="Minor GC与Full GC分别在什么时候发生？"></a>Minor GC与Full GC分别在什么时候发生？</h2><blockquote><p><strong>Minor GC / Young GC</strong></p></blockquote><p>首先我们先来看下 Minor GC / Young GC，大家都知道，新生代(Young Gen)也可以称之为年轻代，这两个名词是等价的。那么在年轻代中的 Eden 内存区域被占满之后，实际上就需要触发年轻代的 GC，或者是新生代的 GC。</p><p>此时这个新生代 GC，其实就是所谓的 Minor GC，也可以称之为 Young GC，这两个名词，相信大家就理解了，说白了，就专门针对新生代的 GC。</p><blockquote><p><strong>Full GC</strong></p></blockquote><p>对于 Full GC，其实这里有一个更加合适的说法，就是说 Full GC 指的是针对新生代、老年代、永久代的全体内存空间的垃圾回收，所以称之为 Full GC。</p><p>从字面意思上也可以理解，Full 就是整体的意思，所以就是对 JVM 进行一次整体的垃圾回收，把各个内存区域的垃圾都回收掉。</p><blockquote><p>MajorGC</p></blockquote><p>老年代</p><h2 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h2><p>synchronized、ReentrantLock都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p><p>可<a href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%85%A5%E9%94%81&amp;spm=1001.2101.3001.7020">重入锁</a>，指的是以<strong>线程</strong>为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。<br>synchronized 和 ReentrantLock 都是可重入锁。</p><p>可重入锁的意义之一在于防止<strong>死锁</strong>。</p><blockquote><p><strong>Java常见的锁总结</strong></p></blockquote><p><strong>可重入锁、乐观锁、悲观锁、公平锁、非公平锁、自旋锁等</strong></p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程<a href="https://so.csdn.net/so/search?q=%E6%8C%82%E8%B5%B7&amp;spm=1001.2101.3001.7020">挂起</a>和恢复现场的花费可能会让系统得不偿失。</p><p>为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="https://img-blog.csdnimg.cn/510dac8af97145fd83c7e4c439df73e9.png" alt="img"></p><blockquote><p>缺点</p></blockquote><p>​    自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好；<br>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。<br>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置）</li></ul><p><strong>实现原理</strong></p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> getAndAddInt <span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token class-name">Long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> var5<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">{</span>var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程同步和线程异步有什么区别"><a href="#线程同步和线程异步有什么区别" class="headerlink" title="线程同步和线程异步有什么区别"></a>线程同步和线程异步有什么区别</h2><p>同步和异步的区别，比如说某一次测验：<br><strong>同步：</strong>老师派科代表去办公室拿试卷，然后一直等到拿回来试卷，没错就是干等什么都不做，然后发卷子。老师一直等到卷子都发完，才开始说明测验内容。等到说明完了之后，学生才开始做卷子。。。<br><strong>异步：</strong>老师派科代表去办公室拿试卷，然后老师简单的介绍测验内容（此时介绍测验内容和科代表拿试卷是同时进行的），科代表拿回试卷后“通知”老师试卷已经拿回来了。老师可以暂停讲解，让科代表发卷子并继续讲解（老师比较嘴碎）。发完卷子学生一遍开始做卷子一遍听老师讲解（老师比较嘴碎，讲了这么久都没讲完）。</p><h2 id="什么是线程同步和互斥"><a href="#什么是线程同步和互斥" class="headerlink" title="什么是线程同步和互斥"></a>什么是线程同步和互斥</h2><p>同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种<strong>特殊的线程同步</strong>（下文统称为同步）。</p><h2 id="OOP中的组合、聚合和关联有什么区别？"><a href="#OOP中的组合、聚合和关联有什么区别？" class="headerlink" title="OOP中的组合、聚合和关联有什么区别？"></a>OOP中的组合、聚合和关联有什么区别？</h2><p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的 关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指 一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在， 但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</p><p>理解</p><p>比如A类中包含B类的一个引用b，当A类的一个对象消亡时，b这个引用所指向的对象也同时消亡（没有任何一个引用指向它，成了垃圾对象），这种情况叫做组合，反之b所指向的对象还会有另外的引用指向它，这种情况叫聚合。</p><blockquote><p>在实际写代码时组合方式一般会这样写：<br>A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡。<br>聚合方式则是这样：<br>A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它<br>传给它的这个对象不是A类创建的。</p></blockquote><p>代码</p><p>聚合</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">{</span>       <span class="token comment">//使用成员变量形式实现聚合关系   </span>    <span class="token class-name">Car</span> mycar<span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           mycar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>组合(上面的代码加上这些)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Driver</span><span class="token punctuation">(</span><span class="token class-name">Car</span> car<span class="token punctuation">)</span><span class="token punctuation">{</span>       mycar <span class="token operator">=</span> car<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>自动装箱和自动拆箱<br>自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。JDK1.5后，Java引入了自动装箱(autoboxing)/拆箱(unboxing)。<br>自动装箱：基本类型的数据处于需要对象的环境中时，会自动转为“对象”。<br>自动拆箱：每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用<br>Integer</p><h2 id="设计模式六大原则："><a href="#设计模式六大原则：" class="headerlink" title="设计模式六大原则："></a><strong>设计模式六大原则：</strong></h2><p><strong>1、单一原则</strong>（Single Responsibility Principle）：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化；</p><p>　　a、业务对象（BO business object）、业务逻辑（BL business logic）拆分；</p><p><strong>2、里氏替换原则</strong>（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能；（本质其实就是c++的多态）</p><p>　　（目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p><p><strong>3、依赖倒置原则</strong>（dependence inversion principle）：面向接口编程；（通过接口作为参数实现应用场景）</p><p>　　抽象就是接口或者抽象类，细节就是实现类</p><p>　　含义：</p><p>　　　　上层模块不应该依赖下层模块，两者应依赖其抽象；</p><p>　　　　抽象不应该依赖细节，细节应该依赖抽象；</p><p>通俗点就是说变量或者传参数，尽量使用抽象类，或者接口；</p><p>【接口负责定义public属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】</p><p><strong>4、接口隔离原则</strong>（interface segregation principle）：建立单一接口；（扩展为类也是一种接口，一切皆接口）</p><p>　　　定义：</p><p>　　　　a.客户端不应该依赖它不需要的接口；</p><p>　　　　b.类之间依赖关系应该建立在最小的接口上；</p><p>简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用）</p><p>【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】　　　</p><p><strong>5、迪米特原则</strong>（law of demeter LOD）：最少知道原则，尽量降低类与类之间的耦合；</p><p>一个对象应该对其他对象有最少的了解</p><p><strong>6、开闭原则</strong>（open closed principle）：用抽象构建架构，用实现扩展原则；</p><h2 id="url一般有哪几部分组成？"><a href="#url一般有哪几部分组成？" class="headerlink" title="url一般有哪几部分组成？"></a>url一般有哪几部分组成？</h2><p>一般标准的URL由协议、主机名、路径及文件名三部分00组0成。</p><h2 id="comparable和comparator的区别"><a href="#comparable和comparator的区别" class="headerlink" title="comparable和comparator的区别"></a>comparable和comparator的区别</h2><blockquote><p>相同点：</p></blockquote><p>两个都是接口<br>都是实现比较的<br>返回值都是a&gt;b返回正整数,a=b返回0，a&lt;b返回负数。</p><blockquote><p>不同点：</p></blockquote><p>comparable位于java.lang包下面，而comparator位于java.util包下<br>comparable实现的是自连接（比如String类），就是将自己和指定的一个对象进行比较，而comparator是另外的一个类的一个方法将两个不相关的对象进行比较，很显然comparator的耦合性比comparable的耦合性要低。</p><blockquote><p>注意</p></blockquote><p>在一些集合里面要对类进行排序，而这些类在设计的时候没有考虑到要进行排序，那么这时候我们唯一的办法就是传递一个comparator的接口给他让他进行比较。</p><h2 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h2><p><strong>重排序的好处：提高处理速度</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f03ffb17b0e70afdd9f262453994eb78.png" alt="img"><img src="https://img-blog.csdnimg.cn/img_convert/483d2fc3b0d6b75a5cdc8d3d6c9ee018.png" alt="img"></p><h2 id="如何写一段简单的死锁代码？"><a href="#如何写一段简单的死锁代码？" class="headerlink" title="如何写一段简单的死锁代码？"></a>如何写一段简单的死锁代码？</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span> object1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> object2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"deadlock-demo-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>object1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"deadlock-demo-2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="float-f-3-4-是否正确？"><a href="#float-f-3-4-是否正确？" class="headerlink" title="float f=3.4;是否正确？"></a>float f=3.4;是否正确？</h2><p>答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</p><h2 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h2><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h2 id="我们可以在-hashcode-中使用随机数字吗？"><a href="#我们可以在-hashcode-中使用随机数字吗？" class="headerlink" title="我们可以在 hashcode() 中使用随机数字吗？"></a>我们可以在 hashcode() 中使用随机数字吗？</h2><ol><li><strong>为什么要有hashcode</strong><br>总结:如果一个对象 不往 与hash有关的集合中放 那么hashcode()方法 写不写无所谓, 否则必须写hashcode方法 ,hashcode能加快比较的速度 ,</li><li>equals 相等  hashcode  必须相等   hashcode不相等  equals 必不相等</li><li>因为如果两个对象相等，hashcode一定相同，不可能是个随机数</li></ol><h2 id="你所知道网络协议有那些？"><a href="#你所知道网络协议有那些？" class="headerlink" title="你所知道网络协议有那些？"></a>你所知道网络协议有那些？</h2><p>TCP/IP协议、UDP协议、HTTP协议、FTP协议、Telnet协议、SMTP协议、NFS协议等。</p><p> FTP：文件传输协议</p><p> SMPT：简单邮件协议</p><h2 id="程序的结构有那些？"><a href="#程序的结构有那些？" class="headerlink" title="程序的结构有那些？"></a>程序的结构有那些？</h2><p>由顺序结构、选择结构、循环结构</p><h2 id="如何打破双亲委派模型"><a href="#如何打破双亲委派模型" class="headerlink" title="如何打破双亲委派模型"></a>如何打破双亲委派模型</h2><p>自定义类加载器，重写loadclass方法。</p><h2 id="linkedlist和arraylist的区别是什么"><a href="#linkedlist和arraylist的区别是什么" class="headerlink" title="linkedlist和arraylist的区别是什么"></a>linkedlist和arraylist的区别是什么</h2><p><strong>1、数据结构不同</strong></p><p>ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。</p><p><strong>2、效率不同</strong></p><p>当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p><p>当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p><p><strong>3、自由性不同</strong></p><p>ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p><p><strong>4、主要控件开销不同</strong></p><p>ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。</p><h2 id="hashcode和equals如何使用"><a href="#hashcode和equals如何使用" class="headerlink" title="hashcode和equals如何使用"></a>hashcode和equals如何使用</h2><p>hashcode冲突了，jdk1.7是采用链式继续存，这时候用equals比较</p><h2 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h2><blockquote><p>string、包装类不可变性</p></blockquote><img src="../images/typora-user-images/image-20220708121919976.png" alt="image-20220708121919976" style="zoom:200%;"><p>例如上面的字符串s，它是指向与常量池，在传参后也是另一个方法也是指向与常量池。在另一个方法进行修改的时候，因为字符串的不可变性，它会产生一个新的字符串，然后把这个新的字符串重新赋值给这个参数，原来方法所指向的不变。（interger包装类也是一样的，它会产生一个新的，所以原来的不会改变，但注意interger 127这个范围）</p><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><p><img src="/../images/typora-user-images/image-20220708124316363.png" alt="image-20220708124316363"></p><p><img src="/../images/typora-user-images/image-20220708124135892.png" alt="image-20220708124135892"></p><p><img src="/../images/typora-user-images/image-20220708125114357.png" alt="image-20220708125114357"></p><blockquote><p>作用域</p></blockquote><p><img src="/../images/typora-user-images/image-20220708124537464.png" alt="image-20220708124537464"></p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><img src="/../images/typora-user-images/image-20220724100149487.png" alt="image-20220724100149487"></p><p>布隆过滤器是一个二进制数组，只有0和1.在存储的时候根据多个hash函数计算位置，把对应位置改成1.判断的时候也是这样判断，要查到所有hash函数对应的都是1才存在</p><blockquote><p>缺点</p></blockquote><p>第一个缺点是误判，哈希冲突</p><p>第二个是不适合删除，因为可能多个映射到一个位置，删除的话是把对应值改成0，这样把其他的也删除了</p><blockquote><p>优点</p></blockquote><p>安全，都是0和1，谁也不晓得是啥</p><p>快，数组随机存储，快的一批</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>指的是以<strong>线程</strong>为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，目的为了避免死锁<img src="/../images/typora-user-images/image-20220807180931028.png" alt="image-20220807180931028"></p><h2 id="java泛型"><a href="#java泛型" class="headerlink" title="java泛型"></a>java泛型</h2><p><img src="/../images/typora-user-images/image-20220812121440780.png" alt="image-20220812121440780"></p><h2 id="java的static方法无法被重写"><a href="#java的static方法无法被重写" class="headerlink" title="java的static方法无法被重写"></a>java的static方法无法被重写</h2><ol><li>静态方法是无法被重写（Override）的，如果强行加上 @Override 注解，编译时会报错 <strong>“java: 方法不会覆盖或实现超类型的方法”</strong>。<br>原因：重写的作用是为了父类和子类的相同签名的方法，具有不同的行为，从而实现了 <strong>多态</strong> 。但是静态方法是被类直接调用的，和对象无关，不存在父子类对象之间的相同方法不同行为，所以也没有多态。</li><li>子类可以直接调用父类的静态方法。<br>虽说子类无法重写父类的静态方法，但是却可以直接调用父类的静态方法，调用方式是 <strong>子类名.父类静态方法()</strong> ，当然，也可以 **子类对象.父类静态方法()**，不过没必要，也不建议。</li></ol><h2 id="字符串创建对象个数"><a href="#字符串创建对象个数" class="headerlink" title="字符串创建对象个数"></a>字符串创建对象个数</h2><p>面试题：String str4 = new String(“abc”) 创建多少个对象？</p><ol><li>在常量池中查找是否有“abc”对象<ul><li>有则返回对应的引用实例</li><li>没有则创建对应的实例对象</li></ul></li><li>在堆中 new 一个 String(“abc”) 对象</li><li>将对象地址赋值给str4,创建一个引用</li></ol><p>所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用</p><p>根据字面量，往往会提出这样的变式题：</p><p><strong>String str1 = new String(“A”+”B”) ; 会创建多少个对象?</strong><br><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong></p><p>str1：<br>字符串常量池：”A”,”B”,”AB” : 3个<br>堆：new String(“AB”) ：1个<br>引用： str1 ：1个<br>总共 ： 5个</p><p>str2 ：<br>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个</p><h2 id="运行时常量池和字符串常量池的区别"><a href="#运行时常量池和字符串常量池的区别" class="headerlink" title="运行时常量池和字符串常量池的区别"></a>运行时常量池和字符串常量池的区别</h2><p><strong>常量池</strong><br>每个class一份，存在于字节码文件中。常量池中有字面量(数量值、字符串值)和符号引用(类符号引用、字段符号引用、方法符号引用)，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><p><strong>运行时常量池</strong><br>每个class一份，存在于方法区中(元空间)。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是下面的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p><p><strong>字符串常量池</strong><br><u>每个JVM中只有一份</u>，存在于方法区中(堆)。全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串（用双引号括起来的引用而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份</p><h2 id="jdbc连接数据库的步骤是什么"><a href="#jdbc连接数据库的步骤是什么" class="headerlink" title="jdbc连接数据库的步骤是什么"></a>jdbc连接数据库的步骤是什么</h2><p>1、加载jdbc驱动程序；</p><p>​        在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），这通过java.lang.Class类的静态方法forName(String className)实现。</p><p>2、创建数据库的连接；</p><p>​    •要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。<br>​    •使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和密码来获得。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//连接MySql数据库，用户名和密码都是root    </span>     <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/test"</span> <span class="token punctuation">;</span>          <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token string">"root"</span> <span class="token punctuation">;</span>         <span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">"root"</span> <span class="token punctuation">;</span>         <span class="token keyword">try</span><span class="token punctuation">{</span>              <span class="token class-name">Connection</span> con <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url <span class="token punctuation">,</span> username <span class="token punctuation">,</span> password <span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">SQLException</span> se<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据库连接失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              se<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、创建preparedStatement；</p><p>•要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：<br>1、执行静态SQL语句。通常通过Statement实例实现。<br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。<br>3、执行数据库存储过程。通常通过CallableStatement实例实现。<br>•具体的实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Statement</span> stmt <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token class-name">PreparedStatement</span> pstmt <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token class-name">CallableStatement</span> cstmt <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">prepareCall</span><span class="token punctuation">(</span><span class="token string">"{CALL demoSp(? , ?)}"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>4、执行SQL语句；5、遍历结果集；6、处理异常，关闭JDBC对象资源。</p><h2 id="threadLocal应用场景"><a href="#threadLocal应用场景" class="headerlink" title="threadLocal应用场景"></a>threadLocal应用场景</h2><blockquote><p>链接数据库</p></blockquote><p><img src="/../images/typora-user-images/image-20230524112414644.png" alt="image-20230524112414644"></p><h2 id="hasmap扩容"><a href="#hasmap扩容" class="headerlink" title="hasmap扩容"></a>hasmap扩容</h2><h3 id="扩容容量"><a href="#扩容容量" class="headerlink" title="扩容容量"></a>扩容容量</h3><p>扩容容量就是2倍，因为容量是2 的幂次方，扩容也是左移一位，例如16&lt;&lt;1 = 32</p><blockquote><p>为啥用左移，不是乘法</p></blockquote><p>主要是提升cpu性能，因为cpu是不支持乘法运算的，所有的运算会转换成加法，移位可以提高效率</p><blockquote><p>理解</p></blockquote><p><img src="/../images/typora-user-images/image-20230604172936773.png" alt="image-20230604172936773"></p><p>不指定，就是16，可以在构造函数指定，但会转化为2的幂数（3变4）</p><blockquote><p>为啥要转换成2的幂数</p></blockquote><p>为了末尾是1</p><p>由于哈希值是和长度-1进行取余</p><p>例如16是10000，减一后变成01111，这样取余可以。</p><p>但15如果不变成最近的2的幂数，则15对应的是01111，减一后变成01110，这样15（1111）和14（1110）取余后的结果是一致的，增加了冲突</p><p><img src="/../images/typora-user-images/image-20230604173425101.png" alt="image-20230604173425101"></p><blockquote><p>参考</p></blockquote><p><a href="https://www.bilibili.com/video/BV1Yu411y7Jr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1Yu411y7Jr/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p><h3 id="啥时候扩容"><a href="#啥时候扩容" class="headerlink" title="啥时候扩容"></a>啥时候扩容</h3><p>负载因子和长度乘积决定</p><h3 id="扩容死循环"><a href="#扩容死循环" class="headerlink" title="扩容死循环"></a>扩容死循环</h3><p>只在1.7版本有，因为采取了头插法</p><p>在多线程扩容下</p><p><img src="/../images/typora-user-images/image-20230605101839418.png" alt="image-20230605101839418"></p><p><img src="/../images/typora-user-images/image-20230605101901953.png" alt="image-20230605101901953"></p><p>如上图所示，如果在扩容的时候T2线程休眠，这时候T1进行扩容</p><p><img src="/../images/typora-user-images/image-20230605101955335.png" alt="image-20230605101955335"></p><p>扩容完成之后T2的节点和next节点会反过来，这时候T2在进行扩容，会形成死循环</p><p><img src="/../images/typora-user-images/image-20230605102051736.png" alt="image-20230605102051736"></p><blockquote><p>如何解决</p></blockquote><p>在1.8改成了尾插法，直接解决了</p><p>在1.7，可以使用</p><p><img src="/../images/typora-user-images/image-20230605102150096.png" alt="image-20230605102150096"></p><blockquote><p>参考</p></blockquote><p><a href="https://www.bilibili.com/video/BV1oD4y1b7RF?p=2&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1oD4y1b7RF?p=2&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p><h2 id="如何扩容（数据迁移）"><a href="#如何扩容（数据迁移）" class="headerlink" title="如何扩容（数据迁移）"></a>如何扩容（数据迁移）</h2><p>主要分为四个种类状态，节点是null，只有一个节点，有一个链，有红黑树</p><blockquote><p>null</p></blockquote><p>不用处理</p><blockquote><p>只有一个节点</p></blockquote><p>只有一个节点，说明没有发生冲突，直接迁移就行，根据新表长度计算出在新表的位置，然后放进去就行</p><blockquote><p>只有一个链</p></blockquote><p>说明发生了冲突，需要把当前这个链表拆分成两类，分为高位链和低位链</p><p>由于冲突成链了，所以这个链表中低位都是相同的（都是和长度-1计算出来的）（例如16，减一后变成01111，低位是后4位，高位是第五位，目前链表的低位一定是相同的，高位不一样，有的是0，有的是1）</p><p>对于高位是1的，到新表扩容肯定是变多了，是老表的位置加老表的size，因为高位1就是老表的长度。（例如，表长度是16，8的位置扩容后在新表的位置应该是8+16=24这个位置）</p><blockquote><p>红黑树</p></blockquote><p>也是高低位（以后再看）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>spring</title>
    <link href="http://example.com/posts/7f1ae6sp.html"/>
    <id>http://example.com/posts/7f1ae6sp.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-06-04T03:13:03.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ioc"><a href="#ioc" class="headerlink" title="ioc"></a>ioc</h2><p>为了降低耦合度</p><blockquote><p>底层原理</p></blockquote><p><a href="https://so.csdn.net/so/search?q=xml&amp;spm=1001.2101.3001.7020">xml</a>解析、工厂模式、反射</p><blockquote><p>工厂模式</p></blockquote><p>它的出现就是为了解耦合</p><p><img src="/../images/typora-user-images/image-20220705110347937.png" alt="image-20220705110347937"></p><blockquote><p>ioc</p></blockquote><p><img src="/../images/typora-user-images/image-20220705110727980.png" alt="image-20220705110727980"></p><p>工厂不在new了，通过反射来创建对象，这样我们只需要修改xml就可以了</p><blockquote><p><strong>Spring提供的IOC容器实现的两种方式（两个接口）</strong></p></blockquote><p>BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。）</p><p>ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！</p><blockquote><p>注入</p></blockquote><p>set</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--（2）spring方式： set方法注入属性--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>book<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.Book<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--使用property完成属性注入        name：类里面属性名称        value：向属性注入的值    --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bname<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hello<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bauthor<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>World<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>construct</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--（2）spring方式：有参数构造注入属性--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>orders<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.Orders<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>oname<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hello<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>China！<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注入空值和特殊值</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>book<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.Book<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--（1）null值--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>null</span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--属性里边添加一个null标签--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--（2）特殊符号赋值--&gt;</span>     <span class="token comment">&lt;!--属性值包含特殊符号       a 把&lt;&gt;进行转义 &amp;lt; &amp;gt;       b 把带特殊符号内容写到CDATA      --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span><span class="token cdata">&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注入外部bean</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--1 service和dao对象创建--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.service.UserService<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--注入userDao对象        name属性：类里面属性名称        ref属性：创建userDao对象bean标签id值    --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDaoImpl<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.dao.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>xml 注入集合属性</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--（2）在 spring 配置文件进行配置--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stu<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.collectiontype.Stu<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--数组类型属性注入--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>courses<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>java课程<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>数据库课程<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--list类型属性注入--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>小三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--map类型属性注入--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>maps<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JAVA<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PHP<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>php<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--set类型属性注入--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sets<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>MySQL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>Redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在集合里面设置对象类型值</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--创建多个course对象--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>course1<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.collectiontype.Course<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cname<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Spring5框架<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>course2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.atguigu.spring5.collectiontype.Course<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cname<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyBatis框架<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--注入list集合类型，值是对象--&gt;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>courseList<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>course1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>course2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p><img src="/../images/typora-user-images/image-20220708215730998.png" alt="image-20220708215730998"></p><p>两个的弊端：byname必须名字一样，要不不行</p><p>bytype，两个同类型的容器不行，直接报错</p><blockquote><p>注解实现</p></blockquote><p>当然要首先开启注解的支持</p><p><img src="/../images/typora-user-images/image-20220708221048708.png" alt="image-20220708221048708"></p><p>@Autowired</p><p>@Qualifier</p><p>@Resource</p><h2 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h2><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。（单例）</li><li><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。（原型）</li><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><h2 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h2><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>(换成原型模式就安全了)（加锁当然也可以不过会降低效率）</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>这是spring aop的底层</p><h2 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h2><p>切面编程</p><p>AOP(Aspect Oriented Programming)：面向切面编程，一种编程范式，AOP弥补了OOP的不足，基于OOP基础之上进行横向开发。</p><p>OOP规定程序开发以类为主体模型，一切围绕对象进行，完成某个任务先构建模型；AOP程序开发主要关注基于OOP开发中的共性功能，一切围绕共性功能进行，</p><h2 id="springmvc的执行流程"><a href="#springmvc的执行流程" class="headerlink" title="springmvc的执行流程"></a>springmvc的执行流程</h2><p><img src="/../images/typora-user-images/springmvc" alt="img"></p><ol><li><p>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。（被它拦截，拦截什么可以配置，比如配置/nihao，就拦截/你好）(一般写/，全拦截就行了)</p></li><li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。（这个是根据url获取handler）</p><blockquote><p>url分为什么</p></blockquote><p><img src="/../images/typora-user-images/image-20220709100321845.png" alt="image-20220709100321845"></p><p><img src="/../images/typora-user-images/image-20220709100412682.png" alt="image-20220709100412682"></p><p><img src="/../images/typora-user-images/image-20220709100452962.png" alt="image-20220709100452962"></p></li><li><p>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</p><p>为什么要在 Spring MVC 中使用适配器模式？Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">MultiActionController</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">MultiActionController</span><span class="token punctuation">)</span>mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>xxx  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>mappedHandler<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> XXX<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样假设如果我们增加一个 HardController,就要在代码中加入一行 if(mappedHandler.getHandler() instanceof HardController)，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p></li><li><p><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p></li><li><p>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p></li><li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p></li><li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p></li><li><p>把 <code>View</code> 返回给请求者（浏览器</p></li></ol><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><p>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等<br>一类称为业务处理 Bean：指 <strong>Service 或 Dao 对象</strong>，专门用于处理业务逻辑和数据访问。<br>V：View，视图层，指工程中的<strong>html或jsp等页面</strong>，作用是与用户进行交互，展示数据</p><p>C：Controller，<strong>控制层</strong>，指工程中的<strong>servlet</strong>，作用是接收请求和响应浏览器</p><h2 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h2><p>1、请求次数</p><p>重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；</p><p>2、地址栏不同</p><p>重定向地址栏会发生变化，转发地址栏不会发生变化；</p><p>3、是否共享数据</p><p>重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；</p><p>4、跳转限制</p><p>重定向可以跳转到任意URL，转发只能跳转本站点资源；</p><p>5、发生行为不同</p><p>重定向是客户端行为，转发是服务器端行为；</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">请求转发：request.getRequestDispatcher(“info.html”).forward(request, response);请求重定向：response.sendRedirect(“1.html”);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><ol><li><p>先创建一个父工程</p><p>删除父工程src，因为用不到</p><p>导入自己知道的公共依赖</p></li><li><p>创建子工程，一个普通的maven即可</p></li></ol><h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><p>继承httpservlet，重写doGet、depost</p><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>过滤器解决乱码</p><p><img src="/../images/typora-user-images/image-20220709112043530.png" alt="image-20220709112043530"></p><p>配置文件配置</p><p><img src="/../images/typora-user-images/image-20220709112124129.png" alt="image-20220709112124129"></p><p>(上面的/换/*)</p><p>springmvc自带过滤器（在配置文件上配置就可以了）</p><p><img src="/../images/typora-user-images/image-20220709112323854.png" alt="image-20220709112323854"></p><h2 id="jison"><a href="#jison" class="headerlink" title="jison"></a>jison</h2><p>它是一种数据格式，现在都是前后端分离开放，需要这样一种格式约定</p><h2 id="requestbody"><a href="#requestbody" class="headerlink" title="requestbody"></a>requestbody</h2><p>了解http请求</p><p><img src="/../images/typora-user-images/image-20220806122904504.png" alt="image-20220806122904504"></p><p>第一行是请求url；包含请求类型，地址等</p><p>第二行是请求头；包含身份信息，请求内容的类型等</p><p>然后空行</p><p>第四行请求体：</p><p>get请求是url传参的，例如上面？后面的</p><p>post请求体传参的，比如上面两个，可能是json或者字符串（表单）等等</p><p>测试</p><blockquote><p>加上requestbody</p></blockquote><p><img src="/../images/typora-user-images/image-20220806123652430.png" alt="image-20220806123652430"></p><p>get请求不行，post请求表单不行，jsion可以</p><blockquote><p>不加requestbody</p></blockquote><p>get，post表单都可以。jsion不行</p><p>所以处理传来的是jison的时候加上requestbody</p><blockquote><p>注意</p></blockquote><p>用requestbody修饰字符串的时候，会接收整个jsion</p><p><img src="/../images/typora-user-images/image-20220806123958381.png" alt="image-20220806123958381"></p><p>所以requestbody尽量修饰一个实体参数，或者map</p><h2 id="requestparam"><a href="#requestparam" class="headerlink" title="requestparam"></a>requestparam</h2><p>其实这个在参数上加和不加是一样的，只不过加上可以解决前端和后端传递参数名不一致的情况</p><p><img src="/../images/typora-user-images/image-20220806124201767.png" alt="image-20220806124201767"></p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>1.使用注解 (局部跨域)</p><p><strong>在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@CrossOrigin</span><span class="token punctuation">(</span>origins <span class="token operator">=</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.手动设置响应头(局部跨域)</p><p>使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/index"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>     response<span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Allow-Control-Origin"</span><span class="token punctuation">,</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"index"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.使用自定义filter实现跨域</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>wideth<span class="token punctuation">.</span>aop</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">Filter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">FilterChain</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">FilterConfig</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletRequest</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ServletResponse</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span><span class="token punctuation">;</span> <span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCorsFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> res<span class="token punctuation">,</span>   <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>      <span class="token class-name">HttpServletResponse</span> response <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">)</span> res<span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Origin"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Methods"</span><span class="token punctuation">,</span> <span class="token string">"POST, GET, OPTIONS, DELETE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Max-Age"</span><span class="token punctuation">,</span> <span class="token string">"3600"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Access-Control-Allow-Headers"</span><span class="token punctuation">,</span> <span class="token string">"x-requested-with,content-type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h2><p>1.get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；<br>post请求一般是去提交数据。</p><p>2.get因为参数会放在url中，所以隐私性，安全性较差，请求的数据长度是有限制的，<br>不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；<br>post请求是没有的长度限制，请求数据是放在body中；</p><p>3.get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。</p><p>4.get请求可以被缓存，post请求不会被缓存。</p><p>5.get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能。它的参数不在url中。</p><p>6.get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。</p><h2 id="requestbody和RequestParam"><a href="#requestbody和RequestParam" class="headerlink" title="requestbody和RequestParam"></a>requestbody和RequestParam</h2><p>RequestBody注解的主要作用就是用于接收前端的参数，当我们使用post请求的时候，我们会将参数放在request body中，此时我们就需要在Controller的方法的参数前面加上@RequestBody用来接受到前端传过来的request body中的值，举个栗子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span>（“<span class="token operator">/</span>test”）<span class="token keyword">public</span> <span class="token keyword">class</span> test<span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">String</span> string<span class="token punctuation">)</span>"<span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个请求只能有一个RequestBody，也就是说，当一个方法中有两个参数的时候，最多只能有一个参数加@RequestBody注解用来接受request body中的参数；</p><p>@RequestParam接收的参数主要是来自request Header中，即请求头中。通常用于get请求中，我们都知道get请求的参数都是写在url中的，例如：<a href="http://localhost:8080/my/api/testMethod?name=%E9%9B%B7%E7%A5%9E&amp;age=3">http://localhost:8080/my/api/testMethod?name=雷神&amp;age=3</a>   该url我们可以看到有那么和age两种属性，那么当我们将此请求发送到后台服务以后，Controller写法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequesMapping</span>（“<span class="token operator">/</span>api”）<span class="token keyword">public</span> <span class="token keyword">class</span> test<span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMethod</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"name"</span><span class="token punctuation">,</span>required<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">,</span>defaultValue<span class="token operator">=</span><span class="token string">"雷神"</span><span class="token punctuation">)</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token class-name">Int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"年仅"</span><span class="token operator">+</span>age<span class="token operator">+</span>“岁肥宅”<span class="token operator">+</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意</p></blockquote><p>RequestBody的作用是将前端传来的json格式的数据转为自己定义好的javabean对象，需要注意的是传入数据的属性名称要和后端javabean中定义的一致，发送请求后可以看到在控制台中我们通过javabean对象的get方法打印出了前端传来的值，说明json数据已经成功被转换为了javabean对象，将对应的属性进行了赋值。</p><h2 id="SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#SpringBoot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解：</p><p>1，@SpringBootConfiguration:组合了@Configuration注解,实现配置文件的功能。</p><p>2，@EnableAotuConfiguration:打开自动配置功能，也可以关闭某些自动配置的选项 </p><p>3，@ComponentScan:Spring组件扫描功能，让SpringBoot扫描到Configuration类并把它加入到程序的上下文。</p><h2 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h2><blockquote><p>springboot启动流程</p></blockquote><p><img src="/../images/typora-user-images/image-20230527130031796.png" alt="image-20230527130031796"></p><p><img src="/../images/typora-user-images/image-20230527130250277.png" alt="image-20230527130250277"></p><blockquote><p>原理</p></blockquote><p><a href="https://blog.csdn.net/m0_46316970/article/details/125898849">https://blog.csdn.net/m0_46316970/article/details/125898849</a></p><h2 id="ComponentScan-扫描类，可以扫描很多个类还是只能一个类？"><a href="#ComponentScan-扫描类，可以扫描很多个类还是只能一个类？" class="headerlink" title="@ComponentScan 扫描类，可以扫描很多个类还是只能一个类？"></a>@ComponentScan 扫描类，可以扫描很多个类还是只能一个类？</h2><p>默认情况下,@<em>ComponentScan扫描</em>入口类同级及其子级包下的所有文件。</p><blockquote><p>扫描其他包</p></blockquote><p>动指定扫描包路径。</p><h2 id="springboot自动装配"><a href="#springboot自动装配" class="headerlink" title="springboot自动装配"></a>springboot自动装配</h2><blockquote><p>自动装配和自动配置</p></blockquote><p>自动装配是autowire</p><p>自动配置是auto-configuration</p><blockquote><p>自动配置</p></blockquote><p>这里用@ComponentScan来加载我们application路径下的包，用@EnableAutoConfiguration来用spring factory机制来加载第三方的jar包的配置类，所有加载好后，再去加载这些配置类用@Import，@Bean等注解去加载的别的配置类，此时所有需要加载的配置类都加载好了，再去实例化这些bean，将这些bean注册到IOC中</p><p><a href="https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p><h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><p><img src="/../images/typora-user-images/image-20230604105038260.png" alt="image-20230604105038260"></p><blockquote><p>用法</p></blockquote><p>1、直接填class数组方式<br>2、ImportSelector方式【重点】<br>3、ImportBeanDefinitionRegistrar方式</p><blockquote><p>普通</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span> 类名<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">,</span> 类名<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestDemo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ImportSelector</p></blockquote><p>分析实现接口的selectImports方法中的：<br>1、返回值： 就是我们实际上要导入到容器中的组件全类名【重点 】<br>2、参数： AnnotationMetadata表示当前被@Import注解给标注的所有注解信息【不是重点】<br>需要注意的是selectImports方法可以返回空数组但是不能返回null，否则会报空指针异常！</p><p>第一步：创建Myclass类并实现ImportSelector接口，这里用于演示就添加一个全类名给其返回值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Myclass</span> <span class="token keyword">implements</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">{</span><span class="token comment">//要实现ImportSelector接口</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"com.yc.Test.TestDemo3"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//这里是要导入的全限定名</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似注入多个，每个用它的全限定名</p><p>第二步：使用ImportSelector方式的Myclass类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Myclass</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>参考</p></blockquote><p><a href="https://blog.csdn.net/a14654/article/details/114398753">https://blog.csdn.net/a14654/article/details/114398753</a></p><p><a href="https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1NY411P7VX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://example.com/posts/7f1ae6dh.html"/>
    <id>http://example.com/posts/7f1ae6dh.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-05-28T11:01:04.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是存储过程？用什么来调用？"><a href="#什么是存储过程？用什么来调用？" class="headerlink" title="什么是存储过程？用什么来调用？"></a>什么是存储过程？用什么来调用？</h2><p>存储过程可以说是一个记录集吧，它是由一些T-<a href="https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&amp;spm=1001.2101.3001.7020">SQL语句</a>组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p><blockquote><p>用什么调用？</p></blockquote><p>可以用一个“execute 存储过程名 参数”命令来调用存储过程。</p><blockquote><p>好处</p></blockquote><p>由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。</p><h2 id="完整性约束包括哪些？"><a href="#完整性约束包括哪些？" class="headerlink" title="完整性约束包括哪些？"></a>完整性约束包括哪些？</h2><p>数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。</p><p>分为以下四类：</p><p>1、实体完整性：规定表的每一行在表中是惟一的实体。</p><p>2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。</p><p>3、参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。</p><p>4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。</p><p>与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。</p><h2 id="使用B树的好处"><a href="#使用B树的好处" class="headerlink" title="使用B树的好处"></a>使用B树的好处</h2><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p><h2 id="视图有哪些特点？哪些使用场景？"><a href="#视图有哪些特点？哪些使用场景？" class="headerlink" title="视图有哪些特点？哪些使用场景？"></a>视图有哪些特点？哪些使用场景？</h2><blockquote><p>什么是视图</p></blockquote><p>是虚拟的表</p><p>使用和普通的表一样</p><p>mysql5.1后出现的新特性，是通过表动态生成的</p><blockquote><p>特点</p></blockquote><p>临时</p><p>可重复用</p><blockquote><p>应用场景</p></blockquote><p>多个地方用到了同样的查询结果</p><p>该查询结果比较复杂</p><blockquote><p>好处</p></blockquote><p> 简化sql查询，提高开发效率，兼容老的表结构。</p><h2 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h2><p><strong>1、</strong> 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>2、</strong> 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><p><strong>3、</strong> 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><p><strong>4、</strong> 全文索引：是目</p><p>前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。</p><p><strong>5、</strong> 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</p><p><strong>6、</strong> 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</p><blockquote><p>好处</p></blockquote><p>提高数据的搜索速度</p><blockquote><p>坏处</p></blockquote><p>在我们建立数据库的时候，需要花费的时间去建立和维护索引，而且随着数据量的增加，需要维护它的时间也会增加。<br>在创建索引的时候会占用存储空间。<br>在我们需要修改表中的数据时，索引还需要进行动态的维护，所以对数据库的维护带来了一定的麻烦。</p><h2 id="MySQL自增主键用完了怎么办？"><a href="#MySQL自增主键用完了怎么办？" class="headerlink" title="MySQL自增主键用完了怎么办？"></a>MySQL自增主键用完了怎么办？</h2><p>一般都是int，一般用不完</p><p>用完了可以用bigint</p><p>可以考虑提前分库分表的。</p><h2 id="mysql如何显示前50行？"><a href="#mysql如何显示前50行？" class="headerlink" title="mysql如何显示前50行？"></a>mysql如何显示前50行？</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">在Mysql中，使用以下代码查询显示前50行： SELECT*FROMLIMIT 0,50;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sql执行速度慢怎么办"><a href="#sql执行速度慢怎么办" class="headerlink" title="sql执行速度慢怎么办"></a>sql执行速度慢怎么办</h2><p>可以加索引</p><blockquote><p>原因</p></blockquote><p>主要原因：</p><p>sql写的烂</p><p>索引失效</p><p>关联查询多，比如join这些</p><blockquote><p>加索引为啥快</p></blockquote><p>如果没有索引，需要在所有的数据一点点查，与磁盘i/o多。加上索引，大大减少I/O操作。</p><blockquote><p>二叉树</p></blockquote><p>缺点：有序的时候不行</p><blockquote><p>红黑树</p></blockquote><p>虽然他进行了平衡，但数太多了，高度也很大</p><h2 id="InnoDB和MyISAM有什么区别"><a href="#InnoDB和MyISAM有什么区别" class="headerlink" title="InnoDB和MyISAM有什么区别?"></a><u>In</u>no<u>D</u>B和My<u>I</u>SAM有什么区别?</h2><p><img src="/../images/typora-user-images/image-20220625094007548.png" alt="image-20220625094007548"></p><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p><img src="/../images/typora-user-images/image-20220625094730792.png" alt="image-20220625094730792"></p><p><img src="/../images/typora-user-images/image-20220625095014801.png" alt="image-20220625095014801"></p><p>默认索引是idx_开头</p><blockquote><p>什么时候建立索引</p></blockquote><p>对频繁使用的字段建立索引</p><blockquote><p>索引失效原因</p></blockquote><p>比如上面的name，email做了复合索引，这个是先按照name排序查在按照email查。如果查询语句没有name，只写了whare email = ？，这样就会失效</p><h2 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h2><p><img src="/../images/typora-user-images/image-20220625100133700.png" alt="image-20220625100133700"></p><p><img src="/../images/typora-user-images/image-20220625101815372.png" alt="image-20220625101815372"></p><blockquote><p>SQL语句中order by和group by一起使用的注意事项</p></blockquote><p>1.order by 的列，必须是出现在group by 子句里的列<br>2.order by 要 放在 group by的后面</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><blockquote><p>左连接</p></blockquote><p><img src="/../images/typora-user-images/image-20220625100418479.png" alt="image-20220625100418479"></p><p>两张表的高度要一致，不一致要补null</p><p>左边的全部查出来，根据on进行连接，右表没有的补null</p><blockquote><p>右链接</p></blockquote><p><img src="/../images/typora-user-images/image-20220625100729883.png" alt="image-20220625100729883"></p><blockquote><p>内链接</p></blockquote><p><img src="/../images/typora-user-images/image-20220625100533462.png" alt="image-20220625100533462"></p><p>on是跟的join的条件</p><blockquote><p>1</p></blockquote><p><img src="/../images/typora-user-images/image-20220625101031577.png" alt="image-20220625101031577"></p><p>去除AB公共部分，就是B.key is null</p><blockquote><p>1</p></blockquote><p><img src="/../images/typora-user-images/image-20220625101140785.png" alt="image-20220625101140785"></p><blockquote><p>全连接</p></blockquote><p><img src="/../images/typora-user-images/image-20220625101353322.png" alt="image-20220625101353322"></p><p><img src="/../images/typora-user-images/image-20220625101328813.png" alt="image-20220625101328813"></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>什么是索引</p></blockquote><p>索引是帮助mysql高效的获取数据的<strong>数据结构</strong></p><p>MySQL中，用的最多的是InnoDB存储引擎，InnoDB中的索引采用B+Tree这种s数据结构</p><p>(排好序的快速查找的数据结构)</p><p>会影响查找和排序（比如orderby）</p><p>一般来说，索引也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p><blockquote><p>有哪些索引</p></blockquote><p>单值索引</p><p>唯一索引</p><p>复合索引</p><blockquote><p>基本语法</p></blockquote><p><img src="/../images/typora-user-images/image-20220625111858845.png" alt="image-20220625111858845"></p><blockquote><p>哪些适合建立索引</p></blockquote><ol><li><p>主键自动建立唯一索引</p></li><li><p>频繁查询</p></li><li><p>查询中排序的字段，索引可以大大提升速度</p></li></ol><blockquote><p>不适合索引</p></blockquote><p>where用不到的字段</p><p>频繁更新的字段（因为更新也要更新索引）</p><p>表记录很少就算了</p><p>数据重复率高，又或者类别很少（比如说ture，false）就不建立了</p><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><img src="../images/typora-user-images/image-20220706104319297.png" alt="image-20220706104319297" style="zoom:200%;"><h2 id="并发情况下引发的问题"><a href="#并发情况下引发的问题" class="headerlink" title="并发情况下引发的问题"></a>并发情况下引发的问题</h2><ul><li><p>脏读：A事务还没提交，B事务就读到了A事务的结果。（破坏隔离性）</p><p>例如：<br>张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。<br>与此同时，<br>事务B正在读取张三的工资，读取到张三的工资为8000。<br>随后，<br>事务A发生异常，而回滚了事务。张三的工资又回滚为5000。<br>最后，<br>事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读</p></li><li><p>不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（破坏一致性，update，delete）<br>例如：<br>在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。<br>与此同时，<br>事务B把张三的工资改为8000，并提交了事务。<br>随后，<br>在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。</p></li><li><p>幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（破坏一致性，insert）<br>例如：<br>目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。<br>此时，<br>事务B插入一条工资也为5000的记录。<br>这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。</p></li></ul><blockquote><p>解决</p></blockquote><p>四种隔离级别，隔离程度不同，副作用也不同</p><ol><li>读未提交（Read uncommitted）：</li></ol><p>​    这种事务隔离级别下，select语句不加锁。</p><p>​    此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。</p><ol start="2"><li>读已提交（Read committed）：</li></ol><p>​    可避免 脏读 的发生。</p><p>​    在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。</p><p>3 .可重复读（Repeatable read）：</p><p>​    MySql默认隔离级别。</p><p>​    可避免 脏读 、不可重复读 的发生。</p><ol start="4"><li>串行化（Serializable ）：</li></ol><p>​    可避免 脏读、不可重复读、幻读 的发生。</p><img src="../images/typora-user-images/image-20220706105349661.png" alt="image-20220706105349661" style="zoom:150%;"><blockquote><blockquote><p>实现（innoDB）</p></blockquote></blockquote><p>隔离级别就是依赖锁和MVCC实现的。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p> InnoDB中的行锁</p><p>① 记录锁（Record Locks）</p><p>锁住某一条记录</p><p><img src="/../images/typora-user-images/%E8%AE%B0%E5%BD%95%E9%94%81" alt="img"></p><p>② 间隙锁（Gap Locks）</p><p>比如幻读，一开始没有数据，没办法加记录锁，可以加间隙锁</p><p><img src="/../images/typora-user-images/%E9%97%B4%E9%9A%99%E9%94%81" alt="img"></p><p>(3, 8)这个区间被锁</p><p>③ 临键锁（Next-Key Locks）</p><p>是上两个锁的组合，间隙锁是开区间（3，8），如果我们也想锁住8，那么用临键锁（3，8]</p><p>innodb默认的锁就是Next-Key locks。</p><p><img src="/../images/typora-user-images/%E4%B8%B4%E5%BB%BA%E9%94%81" alt="img"></p><p>④ 插入意向锁（Insert Intention Locks）</p><h2 id="为什么索引用b-不用b"><a href="#为什么索引用b-不用b" class="headerlink" title="为什么索引用b+不用b"></a>为什么索引用b+不用b</h2><p>b+数非叶子叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。<strong>IO次数更少</strong></p><p>b+高度为 3 的 B+ 树就能够存储千万级别的数据，实践中 B+ 树的高度最多也就 4 或者 5，</p><h2 id="为什么MySQL-没有用hash作为索引的数据结构呢？"><a href="#为什么MySQL-没有用hash作为索引的数据结构呢？" class="headerlink" title="为什么MySQL 没有用hash作为索引的数据结构呢？"></a><strong>为什么MySQL 没有用hash作为索引的数据结构呢？</strong></h2><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p><h2 id="数据库常用得命令"><a href="#数据库常用得命令" class="headerlink" title="数据库常用得命令"></a>数据库常用得命令</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><p>超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键</p><p>候选键(candidate key):不含有多余属性的超键称为候选键</p><p>主键(primary key):用户选作元组标识的一个候选键程序主键</p><p>外键(foreign key)如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。</p><blockquote><p>结合实例的具体解释：</p></blockquote><p>假设有如下两个表：</p><p>学生（学号，姓名，性别，身份证号，教师编号）</p><p>教师（教师编号，姓名，工资）</p><p>超键：</p><p>由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。</p><p>候选键：</p><p>候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。</p><p>主键：</p><p>主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。</p><p>外键：</p><p>外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。</p><h2 id="sql五种约束"><a href="#sql五种约束" class="headerlink" title="sql五种约束"></a>sql五种约束</h2><p><img src="/../images/typora-user-images/sql%E7%BA%A6%E6%9D%9F" alt="img"></p><p>主键约束：不重复、唯一、非空</p><p>设置主键的列不允许为空，</p><p>唯一约束用来保护表中某列数据不允许重复，</p><h2 id="char与varchar的区别"><a href="#char与varchar的区别" class="headerlink" title="char与varchar的区别"></a>char与varchar的区别</h2><ol><li>char的长度不可变，而varchar的长度可变</li></ol><ul><li><p>这就表示，存储字符串’abc’，使用char(10)，表示存储的字符将占10个字节（包括7个空字符）</p></li><li><p>使用varchar(10),则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储</p></li></ul><ol start="2"><li><p>char类型的效率比varchar的效率稍高</p></li><li><p>varchar比char节省空间，但是在效率上比char稍差些。既要获得效率即必须牺牲一点空间，这就是设计上的””以空间换时间””</p></li></ol><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><blockquote><p>一范式</p></blockquote><p>不重复，原子</p><p><img src="/../images/typora-user-images/image-20220804204838970.png" alt="image-20220804204838970"></p><p>数据冗余</p><p><img src="/../images/typora-user-images/image-20220804205033319.png" alt="image-20220804205033319"></p><blockquote><p>插入异常</p></blockquote><p>比如说你新建一个系，这个时候没有学生就插入不了</p><p>二范数</p><p>消除部分依赖，</p><p><img src="/../images/typora-user-images/image-20220804211346942.png" alt="image-20220804211346942"></p><p>完全依赖，通过一个候选码可以确定其他码</p><p>比如id可以确定姓名等但是id和课名才能确定分数</p><p>分数完全依赖于（id和课程），可以说（id和课程）就是候选码，但是name只需要id就可以，所以说name部分依赖于（id和课程）消除</p><p><img src="/../images/typora-user-images/image-20220804215100714.png" alt="image-20220804215100714"></p><p>解决了1范式的数据冗余，修改异常</p><blockquote><p>3范式</p></blockquote><p>消除传递依赖</p><p><img src="/../images/typora-user-images/image-20220804215430797.png" alt="image-20220804215430797"></p><p>插入和删除没问题</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性</p><p><img src="/../images/typora-user-images/image-20220805093409394.png" alt="image-20220805093409394"></p><p>undo log</p><p><img src="/../images/typora-user-images/image-20220805093308491.png" alt="image-20220805093308491"></p><p>持久性</p><p>redo log</p><p>mysql数据是写入磁盘的，但写入磁盘比较慢，所以出现了一个缓存buffer，再写的时候是先写入buffer，在慢慢同步到磁盘。找的时候也如此。如果这时候宕机，buffer嗝屁，不能持久性，这时候有个日志redo log，在放buffer时候也在redo log记录一下，它记录了修改，根据它回复</p><p>隔离性</p><p>写-写：锁</p><p>写-读：mvcc</p><h2 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h2><p>主要是处理读请求，是快照读而不是当前读</p><p>目的是读写得时候不用去竞争锁，提高性能</p><p>读已提交和可重复读的快照读都是基于mvcc实现的</p><p><img src="/../images/typora-user-images/image-20220805093702728.png" alt="image-20220805093702728"></p><p>基于三个实现</p><p>undo log 、版本连、ReadView</p><p><img src="/../images/typora-user-images/image-20220805100533341.png" alt="image-20220805100533341"></p><p>如图，把di为1的一直修改，有事务id，这个是自增的，然后回滚指针，指向之前修改的</p><p>undo log记录之前修改的</p><blockquote><p>readview啥用</p></blockquote><p>你看版本连里面这么多版本，不知道取哪一个啊</p><p><img src="/../images/typora-user-images/image-20220805100902370.png" alt="image-20220805100902370"></p><p>其实readview在代码里就是一个对象</p><p>m_ids 表示活跃的，啥是活跃的，就是没有commit</p><p>creator_trx_id 谁生成了这个readview</p><p><img src="/../images/typora-user-images/image-20220805101149874.png" alt="image-20220805101149874"></p><p>例子</p><p><img src="/../images/typora-user-images/image-20220805102423754.png" alt="image-20220805102423754"></p><p><img src="/../images/typora-user-images/image-20220805102346599.png" alt="image-20220805102346599"></p><p>读已提交RC：这个级别下每次select都会产生一个readview。</p><p>可重复读RR：这个级别下readview是以事务为单位，第一个select产生一个readview，后面不产生了</p><p><img src="/../images/typora-user-images/image-20220805164819209.png" alt="image-20220805164819209"></p><h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>保证持久性</p><p>当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。</p><blockquote><p>为啥不直接写入磁盘</p></blockquote><p>写入redolog快，写入的方式是在文件后面追加，不需要找位置。但是写入磁盘需要找的写入的具体位置，这个比较慢</p><blockquote><p>redolog写满怎么办</p></blockquote><p>它是写满了就从头开始写，像一个环状</p><h2 id="redolog和binlog区别"><a href="#redolog和binlog区别" class="headerlink" title="redolog和binlog区别"></a>redolog和binlog区别</h2><p><img src="/../images/typora-user-images/image-20220817102935850.png" alt="image-20220817102935850"></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>springboot怎么使用</p><p>springboot是自动装配的，你好几个数据库，它怎么知道链接哪一个</p><p>在aplication.apropeity里分别定义主从的密码，用户名，链接这些</p><p>然后这里仿照springboot配置文件自己定义了一个配置类，取出aprlicaotion中的文件</p><p><img src="/../images/typora-user-images/image-20230320124437651.png" alt="image-20230320124437651"></p><p>配置数据源</p><p><img src="/../images/typora-user-images/image-20230320124807566.png" alt="image-20230320124807566"></p><p><img src="C:\Users\14737\AppData\Roaming\Typora\typora-user-images\image-20230320124906227.png" alt="image-20230320124906227"></p><p>设置链接工厂这些</p><p><img src="/../images/typora-user-images/image-20230320124948508.png" alt="image-20230320124948508"></p><p><img src="/../images/typora-user-images/image-20230320151510636.png" alt="image-20230320151510636">    <img src="/../images/typora-user-images/image-20230320151616351.png" alt="image-20230320151616351"></p><h2 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h2><p>defult</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> students<span class="token punctuation">(</span>     student_id <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">100</span><span class="token punctuation">,</span>     name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>     age <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h2><p>uuid和雪花（snowflake）</p><blockquote><p>区别</p></blockquote><p>uuid是无序的不建议使用（因为无序在索引使用的时候影响较大）</p><blockquote><p>雪花算法</p></blockquote><p>它有64个bit位</p><p><img src="/../images/typora-user-images/image-20230523090621662.png" alt="image-20230523090621662"></p><p><img src="/../images/typora-user-images/image-20230523090655175.png" alt="image-20230523090655175"></p><p><img src="/../images/typora-user-images/image-20230523090812372.png" alt="image-20230523090812372"></p><p>配置也是通过shardingspere ，在properties中配置</p><h2 id="非聚集索引回表"><a href="#非聚集索引回表" class="headerlink" title="非聚集索引回表"></a>非聚集索引回表</h2><p>一般普通索引就是非聚集索引，需要回表。聚集索引一般为主键索引，根据这个再进行回表。</p><blockquote><p>为啥不都用聚集索引</p></blockquote><p>没必要，浪费空间，因为每一个创建一个索引，innodb都会创建一个索引树，如果叶子节点都放数据就会浪费空间</p><blockquote><p>具体参考</p></blockquote><p><a href="https://blog.csdn.net/weixin_38192427/article/details/111872683">https://blog.csdn.net/weixin_38192427/article/details/111872683</a></p><h2 id="不同类别索引创建"><a href="#不同类别索引创建" class="headerlink" title="不同类别索引创建"></a>不同类别索引创建</h2><blockquote><p>主键索引</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tbl_name <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>唯一索引</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tbl_name <span class="token keyword">ADD</span> <span class="token keyword">UNIQUE</span> index_name <span class="token punctuation">(</span>col_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这条语句创建索引的值必须是唯一的，索引值可以为null（null可重复出现）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>普通索引</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tbl_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>col_list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 添加普通索引，索引值可出现多次。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>删除</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tbl_name <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="索引失效原因"><a href="#索引失效原因" class="headerlink" title="索引失效原因"></a>索引失效原因</h2><p><a href="https://blog.csdn.net/qq_43460095/article/details/125538837">https://blog.csdn.net/qq_43460095/article/details/125538837</a></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>就是联合索引，在普通索引查询后，需要进行回表操作，但如果查的多，一直回表比较费时。</p><p>这时候可以采用覆盖索引进行解决</p><p><img src="/../images/typora-user-images/image-20230527162843019.png" alt="image-20230527162843019"></p><p>比如这里增加name、和age复合索引，这样在查name和age就不需要回表，但要注意索引失效</p><blockquote><p>参考链接</p></blockquote><p><a href="https://www.bilibili.com/video/BV1cv411P7Wb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1cv411P7Wb/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p><p><a href="https://blog.csdn.net/Aplumage/article/details/117015144">https://blog.csdn.net/Aplumage/article/details/117015144</a></p><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>Mysql5.6更新后一个重要特性，被问到要答出来</p><p><img src="/../images/typora-user-images/image-20230527192116893.png" alt="image-20230527192116893"></p><blockquote><p>参考</p></blockquote><p><a href="https://www.bilibili.com/video/BV1ks4y157CS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1ks4y157CS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>哲学</title>
    <link href="http://example.com/posts/7a46f35t.html"/>
    <id>http://example.com/posts/7a46f35t.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-06-25T10:01:21.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="哲学概述"><a href="#哲学概述" class="headerlink" title="哲学概述"></a>哲学概述</h2><p>哲学研究世界，主要分为自然界和人类社会，人类社会主要有认识世界（停留在思考）和改变世界，认识世界又分为世界观和方法论</p><blockquote><p>世界观</p></blockquote><p>主要解决世界是什么的问题（从哪里来，水来还是其他？上帝创造？）</p><blockquote><p>方法论</p></blockquote><p>怎么做的问题，用什么样的方式去处理问题</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230607210100055.png" alt="image-20230607210100055"></p><p>每个人都有自己的世界观和方法论，但一门学科需要统一，这时就出现了哲学，它是系统化的世界观和方法论。但不能说它是科学的（因为哲学很多，在我们国家，只有马克思哲学才称为科学的）</p><blockquote><p>世界观和方法论关系</p></blockquote><p>世界观决定方法论，方法论体现世界观</p><p>一个人对世界的看法就决定了它做事情的基本方法，通过这个人解决问题的方法就可以体现这个人的世界观。比如一个人世界观认为世界是上帝创建了，人不能改变世界，听天由命，这样在做事的时候就会摆烂。反过来老摆烂，可以体现出世界观。</p><blockquote><p>哲学是科学的？</p></blockquote><p>不对，只有马克思主义哲学才是科学的</p><h2 id="哲学与具体科学的关系"><a href="#哲学与具体科学的关系" class="headerlink" title="哲学与具体科学的关系"></a>哲学与具体科学的关系</h2><p>一般与特别，共性和特性的关系</p><p>比如物理学就是研究物理的，社会学就是研究社会的。但哲学是它们的概括，都有涉及到，范围广，研究是是共性</p><blockquote><p>联系</p></blockquote><p>哲学是以具体科学得成果为基础。比较好理解，因为哲学是共性，抽取其他自然科学的</p><p>哲学又为具体科学提供了引导（一般性的指导）（比如说你认为世界是物质的，这样就不用烧香拜佛了）</p><h2 id="哲学的基本问题"><a href="#哲学的基本问题" class="headerlink" title="哲学的基本问题"></a>哲学的基本问题</h2><p>思想和存在（精神与物质）</p><p>基本问题是<strong>恩格斯</strong>提出的</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615181403996.png" alt="image-20230615181403996"></p><p>第一性是先有谁的问题，先有物，就是唯物。</p><p>同一性就是思维能不能认识存在。比如你面前有个电脑，你看到它能不能知道它的用途等信息，能就是可知，反之不可知论</p><h2 id="唯物主义"><a href="#唯物主义" class="headerlink" title="唯物主义"></a>唯物主义</h2><h3 id="古代朴素"><a href="#古代朴素" class="headerlink" title="古代朴素"></a>古代朴素</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615182013065.png" alt="image-20230615182013065"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615182047383.png" alt="image-20230615182047383"></p><blockquote><p>注意</p></blockquote><p>出现荀子、范镇……，八成是古朴</p><blockquote><p>缺点</p></blockquote><p>太直观了，靠感觉，靠猜测。觉得啥重要啥就是本源</p><h3 id="形而上学"><a href="#形而上学" class="headerlink" title="形而上学"></a>形而上学</h3><p>认为是由原子和分子组成</p><blockquote><p>缺点</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615182724571.png" alt="image-20230615182724571"></p><p>机械性：认为人和机器一样，也是由零部件组成</p><p>形而上学：看到一课树，说这是树，看到一堆树，还说是树，明显是森林。这是看待问题片面（盲人摸象）。静止的眼光看问题（刻舟求剑）</p><p>老马是用<strong>联系、发展、前面</strong>的眼光看问题。</p><p>不彻底性：在自然领域是唯物的（比如问先见山后了解还是先了解后见山，他回答是先见山后了解（这里是唯物没问题）），但在社会领域不行（比如说，人类历史是谁创建的，形而上学认为是伟人、英雄或者神。老马认为是<strong>人民群众</strong>）</p><h2 id="唯心主义"><a href="#唯心主义" class="headerlink" title="唯心主义"></a>唯心主义</h2><h3 id="主观唯心"><a href="#主观唯心" class="headerlink" title="主观唯心"></a>主观唯心</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615185738628.png" alt="image-20230615185738628"></p><p>与人有关</p><h3 id="客观唯心"><a href="#客观唯心" class="headerlink" title="客观唯心"></a>客观唯心</h3><p>（比如老子的道）</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615191326704.png" alt="image-20230615191326704"></p><h3 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615191402647.png" alt="image-20230615191402647"></p><h2 id="马克思主义"><a href="#马克思主义" class="headerlink" title="马克思主义"></a>马克思主义</h2><blockquote><p>组成</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615191727280.png" alt="image-20230615191727280"></p><blockquote><p>产生</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615191830777.png" alt="image-20230615191830777"></p><p>其中，德国古典哲学是马哲的直接来源</p><p>黑格尔提供了辩证法</p><p>费尔巴哈提出了唯物论</p><blockquote><p>科学依据</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615192201221.png" alt="image-20230615192201221"></p><p>进化论是达尔文提出</p><blockquote><p>基本特征</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615192321763.png" alt="image-20230615192321763"></p><p>马克思墓在<strong>伦敦</strong></p><p>老马为啥科学，因为他<strong>与时俱进</strong></p><blockquote><p>一元论</p></blockquote><p>世界本原有几个，有一个就是一元论，两个就是二元论</p><h2 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h2><p>讲的物质是什么</p><h3 id="物质"><a href="#物质" class="headerlink" title="物质"></a>物质</h3><p>物质的唯一特性：客观实在性（不以人的意志而转移）</p><p>物质是<strong>列宁</strong>提出的</p><blockquote><p>物质怎样存在</p></blockquote><p>物质的存在形式和根本属性是<strong>运动</strong>（有变化就是运动）</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615194502657.png" alt="image-20230615194502657"></p><p>社会运动最复杂</p><blockquote><p>物质和运动关系</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615194617616.png" alt="image-20230615194617616"></p><p>世界上所有的物质都是运动的</p><p>离开运动谈物质，形而上学（刻舟求剑）</p><p>反过来，唯心（比如风吹的帆动，老和尚认为不是风动，也不是帆动，是心在动）</p><blockquote><p>静止</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230615195051294.png" alt="image-20230615195051294"></p><p>动是绝对的，无条件的。静是相对的，有条件的。</p><p>静中有动，动中有静</p><p>否认运动，形而上学</p><p>否认静止，诡辩论（借钱不还，方生方死，太阳永远不会在正中央那一刻）</p><h3 id="意识"><a href="#意识" class="headerlink" title="意识"></a>意识</h3><blockquote><p>产生条件</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230616092342330.png" alt="image-20230616092342330"></p><p>无生命物质比如化学反应</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230616092728159.png" alt="image-20230616092728159"></p><p>只有人有意识，要有人脑，但狼人不是，它虽然有人脑，但没有社会活动</p><p>人脑是产生意识的器官，但不是意识的源泉，客观世界才是源泉。（大脑不是产生意识的器官）</p><blockquote><p>本质</p></blockquote><p>是人脑对客观存在的主观映像</p><p>内容是客观的，形式是主观的</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617095830982.png" alt="image-20230617095830982"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617095914848.png" alt="image-20230617095914848"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617100400687.png" alt="image-20230617100400687"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617100543947.png" alt="image-20230617100543947"></p><h3 id="物质与意识"><a href="#物质与意识" class="headerlink" title="物质与意识"></a>物质与意识</h3><p>物质决定意识</p><p>巧妇难为无米之炊（体现了米的重要性）</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617100845193.png" alt="image-20230617100845193"></p><p>物质第一性，客观规律第一性</p><h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617101135556.png" alt="image-20230617101135556"></p><p>主观符合客观一般考政策，比如国家推选垃圾分类，先看看实用不</p><h2 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h2><p>讲的物质是怎样存在的</p><h3 id="两大特征"><a href="#两大特征" class="headerlink" title="两大特征"></a>两大特征</h3><p>普遍联系和永恒发展</p><blockquote><p>联系</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617103135937.png" alt="image-20230617103135937"></p><p>运气是违背联系客观性的，封建迷信也是，属相不和、喜鹊报喜，乌鸦报丧、666、888</p><p>普遍性：冒起不沾边的也有联系。比如蝴蝶效应、6度空间、唇亡齿寒、城门失火，殃及池鱼、连锁反应</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617103734316.png" alt="image-20230617103734316"></p><blockquote><p>整体和部分</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617104006111.png" alt="image-20230617104006111"></p><blockquote><p>发展</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617104252740.png" alt="image-20230617104252740"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617104417261.png" alt="image-20230617104417261"></p><p>发展是不能只看眼前，要看的远</p><h3 id="三大规律"><a href="#三大规律" class="headerlink" title="三大规律"></a>三大规律</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617105515996.png" alt="image-20230617105515996"></p><blockquote><p>质量互变</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617105652636.png" alt="image-20230617105652636"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617105849181.png" alt="image-20230617105849181"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617105905412.png" alt="image-20230617105905412"></p><p>要把握时机</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230617110250452.png" alt="image-20230617110250452"></p><p>拔苗助长，学习也得劳逸结合</p><blockquote><p>对立统一</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618095938396.png" alt="image-20230618095938396"></p><p>相互依存，比如你的丑衬托出我的美，丑美依存</p><p>相互转化，比如整容了，从丑变美，转换（考试重点，反义词相互转换）</p><p>事物发展的源泉是内部矛盾</p><blockquote><p>相互转化的词</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618100635542.png" alt="image-20230618100635542"></p><blockquote><p>内外因</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618100740101.png" alt="image-20230618100740101"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618100920823.png" alt="image-20230618100920823"></p><blockquote><p>矛盾特征</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618101057933.png" alt="image-20230618101057933"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618101703461.png" alt="image-20230618101703461"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618101853253.png" alt="image-20230618101853253"></p><blockquote><p>主要矛盾和次要矛盾</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618102041845.png" alt="image-20230618102041845"></p><p>多个矛盾，怎么做</p><blockquote><p>主要方面与次要方面</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618102234055.png" alt="image-20230618102234055"></p><p>单个矛盾，怎么看</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618102543636.png" alt="image-20230618102543636"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618102701026.png" alt="image-20230618102701026"></p><blockquote><p>否定之否定</p></blockquote><p>扬弃了两次</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618103532731.png" alt="image-20230618103532731"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618103600399.png" alt="image-20230618103600399"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104044325.png" alt="image-20230618104044325"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104326472.png" alt="image-20230618104326472"></p><h3 id="五队范畴"><a href="#五队范畴" class="headerlink" title="五队范畴"></a>五队范畴</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104421903.png" alt="image-20230618104421903"></p><p>讲课准备的充分，滔滔不绝。反之，磕磕绊绊（内容决定形式）</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104524121.png" alt="image-20230618104524121"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104635168.png" alt="image-20230618104635168"></p><p>电闪雷鸣不是，四季交替也不是</p><p>吃的多导致肥胖是</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104756658.png" alt="image-20230618104756658"></p><p>可能性，比如说考试，每个人都可能考上，但现实惨目忍睹。</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618104858847.png" alt="image-20230618104858847"></p><p>守株待兔</p><h2 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h2><p>我们能不能认识客观存在这个物质</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618105512971.png" alt="image-20230618105512971"></p><p>蜜蜂筑巢不是，必须是人</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618105833520.png" alt="image-20230618105833520"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618110040937.png" alt="image-20230618110040937"></p><p>生产实践是最基本的，也是其他实践的基础和前提（民以食为天，填饱肚子再说其他的）</p><p>科学实验起到杠杆作用</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618110324730.png" alt="image-20230618110324730"></p><h3 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618181707968.png" alt="image-20230618181707968"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618181909090.png" alt="image-20230618181909090"></p><blockquote><p>感性认识</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618182123353.png" alt="image-20230618182123353"></p><p>感觉：比如你买衣服，看到后感觉如何</p><p>知觉：摸摸，看看料子怎么样，穿上试试</p><p>表象：比如一说香蕉，就能回忆起来长啥样</p><blockquote><p>理性认识</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618182456764.png" alt="image-20230618182456764"></p><blockquote><p>感性和理性的关系</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618182610396.png" alt="image-20230618182610396"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618182851687.png" alt="image-20230618182851687"></p><p>感性和理性相互包含、相互渗透。是同时存在的（比如，你看你就是卷王。这里看是感性，卷王被定义了，是理性）</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618183424116.png" alt="image-20230618183424116"></p><p>第二次更加重要，因为理论是指导实践的</p><h3 id="实践和认识的关系"><a href="#实践和认识的关系" class="headerlink" title="实践和认识的关系"></a>实践和认识的关系</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618213727938.png" alt="image-20230618213727938"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618213755583.png" alt="image-20230618213755583"></p><h3 id="真理"><a href="#真理" class="headerlink" title="真理"></a>真理</h3><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618213933622.png" alt="image-20230618213933622"></p><p>内容是客观，形式是主观的</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618214044226.png" alt="image-20230618214044226"></p><p>比如你说三角形内角和不是180，这是谬论。但在球面上就符合了，变成了真理，可以相互转化</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230618214238856.png" alt="image-20230618214238856"></p><p>认识的本质是主题对客体的反映（不是实践，实践决定认识）</p><h2 id="历史唯物主义"><a href="#历史唯物主义" class="headerlink" title="历史唯物主义"></a>历史唯物主义</h2><p>人民群众创造历史，不是杰出人物</p><blockquote><p>社会存在</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619110007241.png" alt="image-20230619110007241"></p><p>低碳出行（这就是社会存在决定社会意识，先是车太多了，才弄这个）计划生育也是</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619110538139.png" alt="image-20230619110538139"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619110738265.png" alt="image-20230619110738265"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619111016206.png" alt="image-20230619111016206"></p><p>生产力是人类改造自然行不行，是人和自然的关系，是衡量社会进步的尺度</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619111214977.png" alt="image-20230619111214977"></p><p>生产工具可以看出发展好不好</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619111406978.png" alt="image-20230619111406978"></p><p>生产关系是人与人之间的，比如你卖货，我买货</p><p>所有制是基础，我国的所有制是公有制</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619111729538.png" alt="image-20230619111729538"></p><p>要适应，先进生产关系促进生产力这是错的，适应才行</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619112844298.png" alt="image-20230619112844298"></p><p>经济基础：我们国家公有制为主题，多种所有制总和。这个总的就是经济基础</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619112919785.png" alt="image-20230619112919785"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619113008307.png" alt="image-20230619113008307"></p><blockquote><p>关系</p></blockquote><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619113212102.png" alt="image-20230619113212102"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619113257065.png" alt="image-20230619113257065"></p><p>人民群众</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230619113510301.png" alt="image-20230619113510301"></p><p>所有人都是历史主题，是错误的。还有敌人呢</p><p>人民群众创造历史不能随心所欲，受制约的</p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230625174904201.png" alt="image-20230625174904201"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230625175612140.png" alt="image-20230625175612140"></p><p><img src="/../images/%E5%93%B2%E5%AD%A6/image-20230625180116843.png" alt="image-20230625180116843"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="公共知识" scheme="http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://example.com/posts/7f1ae6fg.html"/>
    <id>http://example.com/posts/7f1ae6fg.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-04-25T12:31:23.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h2><p>动态语言是在运行的时候可以改变其结构的语言，比如说c#、javascript、PHP、Python等</p><p>静态比如说C、JAVA、C++</p><p>java不是动态语言，但java可以有一定的动态性，可以通过反射机制获得类似动态语言的特性，让编程更加灵活。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>java reflection</p><p><img src="/../images/typora-user-images/image-20220701094937127.png" alt="image-20220701094937127"></p><h2 id="反射获得类的class对象三种方式"><a href="#反射获得类的class对象三种方式" class="headerlink" title="反射获得类的class对象三种方式"></a>反射获得类的class对象三种方式</h2><p>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> clazz <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>已知某个类的实例，调用该实例的getClass()方法获取Class对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span> clazz <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>已知一个类的全类名，且该类在路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> aclass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"绝对路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>内置基本类型可以通过类名.Type(例 Integer、Long)</li><li>还可以利用ClassLoader</li></ul><h2 id="哪些类型有可以有class对象？"><a href="#哪些类型有可以有class对象？" class="headerlink" title="哪些类型有可以有class对象？"></a>哪些类型有可以有class对象？</h2><ul><li>Object //类</li><li>Comparable //接口</li><li>String[] //一维数组</li><li>int[] [] // 二维数组</li><li>Override //注解</li><li>ElementType //枚举</li><li>Integer //基本数据类型</li><li>void //void</li><li>Class //class</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>alt可以竖着复制多行，方便快捷</p><p>要遍历的时候直接（遍历对象）.for</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>   <img src="/../images/typora-user-images/image-20220701102016230.png" alt="image-20220701102016230"></p><h2 id="什么时候类会初始化"><a href="#什么时候类会初始化" class="headerlink" title="什么时候类会初始化"></a>什么时候类会初始化</h2><p><img src="/../images/typora-user-images/image-20220701102647557.png" alt="image-20220701102647557"></p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="/../images/typora-user-images/image-20220701103851839.png" alt="image-20220701103851839"></p><h2 id="通过反射能够获取到什么"><a href="#通过反射能够获取到什么" class="headerlink" title="通过反射能够获取到什么"></a>通过反射能够获取到什么</h2><p><img src="/../images/typora-user-images/image-20220701104201218.png" alt="image-20220701104201218"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>text</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Constructor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> test32 <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchFieldException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span>        <span class="token comment">//获取Class类</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.text.Animal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取类名</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------获取类名--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类名"</span> <span class="token operator">+</span> c1<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"包名+类名:"</span> <span class="token operator">+</span> c1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//包名+类名</span>         <span class="token comment">//获取类的属性</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------获取类的属性--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//只能获取公共的字段表示属性</span>        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredFields <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取所以的字段属性(包括私有的等等)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> declaredField <span class="token operator">:</span> declaredFields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>declaredField<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment">//获取指定属性的值</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------获取指定属性的值--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Field</span> name <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//获取方法</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------获取类的方法--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得本类全部方法(无关修饰符)</span>        <span class="token class-name">Method</span><span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获得本类及父类的全部public方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Method</span> method <span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment">//获取指定方法</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------获取指定方法--------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Method</span> getNames <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getName"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>getNames<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//获取Class全部的公有构造方法</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------获取所有公共的构造函数---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> constructors <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">:</span> constructors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment">//获取Class全部的构造方法</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------获取所有全部的构造函数(包括：公共的,默认的,受保护的,私有的)---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredConstructors <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> declaredConstructor <span class="token operator">:</span> declaredConstructors<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>declaredConstructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment">//获取公共构造方法v</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------获取公共无参构造方法---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> constructor <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里必须是一个参数类型的class,默认为null</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Object</span> o <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用构造方法</span><span class="token comment">//        System.out.println("o:"+o.toString());</span><span class="token comment">//        User user=(User)o;</span><span class="token comment">//        user.user2();</span>         <span class="token comment">//获取私有构造放</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------获取私有构造方法---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> declaredConstructor <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>         declaredConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> test <span class="token operator">=</span> declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//获取指定构造方法</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------获取指定构造方法---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> declaredConstructor1 <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>declaredConstructor1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>     <span class="token comment">//这个是测试</span>    <span class="token keyword">private</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token punctuation">}</span>     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"私有方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Animal{"</span> <span class="token operator">+</span>                <span class="token string">"age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小狗"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"猫"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h2><p><img src="/../images/typora-user-images/image-20220701110602661.png" alt="image-20220701110602661"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>text</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Constructor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Field</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> test34 <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchFieldException</span> <span class="token punctuation">{</span>        <span class="token comment">//1.创建class对象</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.text.personnel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.获取构造方法</span>        <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> declaredConstructor <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.通过构造方法new类(这里知道是什么类就可以强行转换了)</span>        personnel o <span class="token operator">=</span> <span class="token punctuation">(</span>personnel<span class="token punctuation">)</span><span class="token punctuation">(</span>declaredConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4.这里获取字段(也可以获取方法全看需要)</span>        <span class="token class-name">Field</span> id <span class="token operator">=</span> c1<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5.因为是私有的属性所以关闭安全检测</span>        id<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//6.设置属性，参数是(设置属性的对象,属性值)</span>        id<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span><span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//7.查看调用方法查看是否设置成功</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment">//账号类</span><span class="token keyword">class</span> personnel<span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> password<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>算法思想</title>
    <link href="http://example.com/posts/7f1ae6sf.html"/>
    <id>http://example.com/posts/7f1ae6sf.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-04-25T12:41:17.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="搜索二叉树遍历数组重建树"><a href="#搜索二叉树遍历数组重建树" class="headerlink" title="搜索二叉树遍历数组重建树"></a>搜索二叉树遍历数组重建树</h2><ol><li><p>最后得节点是整棵树得头，然后想着左右树建立出来，搜索左边小右边大无重复值</p><p>（进阶：不需要一直遍历，可以二分）</p><p>（无序怎么二分？这个我们可以分后与最后一个节点比较，看他大概在哪个区间。毕竟有这样一个简单得规律，后面一大堆比前面一大堆大）</p><p><img src="/../images/typora-user-images/image-20220714104106809.png" alt="image-20220714104106809"></p></li><li><p>左小右大，直接与根节点（最后一个节点）比较就行了</p></li><li><p>怎么确立左右树呢，一样得道理</p></li></ol><p>复杂的（遍历得最差是o（n^2）（什么时候最差，单支，每一层都遍历，共n层），二分得最差是o(nlogn)）</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p><img src="/../images/typora-user-images/image-20220715164330316.png" alt="image-20220715164330316"></p><p>代码里每个节点有pass代表经过几次，还有end代表是不是结尾。</p><p>查询的时候只需要从上往下查，怎么加入的就怎么查，看end有没有</p><p>根节点的pass代表着一共多少字符串，根节点end代表空串数量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">class07</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code01_TrieTree</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> path<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nexts<span class="token punctuation">;</span><span class="token comment">//这个是用数组代表路，如果字符种类特别多，那可以用hash表</span><span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>path <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">TrieNode</span> root<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//插入</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>node<span class="token punctuation">.</span>path<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span>node<span class="token punctuation">.</span>end<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>node<span class="token punctuation">.</span>end<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//查找加入的次数</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> node<span class="token punctuation">.</span>end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//查有多少字符串以***作为前缀</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">prefixNumber</span><span class="token punctuation">(</span><span class="token class-name">String</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> pre<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> node<span class="token punctuation">.</span>path<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">Trie</span> trie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuoa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuoac"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuoab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string">"zuoad"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>trie<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"zuoa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span><span class="token string">"zuoa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trie<span class="token punctuation">.</span><span class="token function">prefixNumber</span><span class="token punctuation">(</span><span class="token string">"zuo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到 </p><p>一个答案的算法，叫作贪心算法。 </p><p>也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解</p><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间<span class="token punctuation">(</span>给你一个数 组，里面是一个个具体的项目<span class="token punctuation">)</span>，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。 返回这个最多的宣讲场次<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>思考</p><p>我们先想按时间最早分配，显然，如果有一个项目最早开始，但贯穿一天，这种策略不行。然后考虑按时间最短分配，经过思考，也不行，比如下面中间的最短，但是他的开始时间和结束时间卡住了其他</p><p><img src="/../images/typora-user-images/image-20220715172156319.png" alt="image-20220715172156319"></p><p>最后我们按照结束时间最早分配，每次把不符合的给删除（因为我们的目的就是数量最多）</p><p><img src="/../images/typora-user-images/image-20220715172739615.png" alt="image-20220715172739615"></p><p>代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">class07</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code04_BestArrange</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Program</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Program</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ProgramComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Program</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Program</span> o1<span class="token punctuation">,</span> <span class="token class-name">Program</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> o1<span class="token punctuation">.</span>end <span class="token operator">-</span> o2<span class="token punctuation">.</span>end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bestArrange</span><span class="token punctuation">(</span><span class="token class-name">Program</span><span class="token punctuation">[</span><span class="token punctuation">]</span> programs<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>programs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ProgramComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> programs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> programs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token punctuation">{</span>result<span class="token operator">++</span><span class="token punctuation">;</span>start <span class="token operator">=</span> programs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>给一个字符串数组，然后进行拼接成一个，要求拼接后的字典序最小</p><p>思考</p><p>每次都把最小字典序的字符串放前面，经过举例这个不对，例如。b的字典序小于ba，如果谁小谁在前，那么是bba，但是很明显bab更小。</p><p><img src="/../images/typora-user-images/image-20220715174101216.png" alt="image-20220715174101216"></p><p> 代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">class07</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code02_LowestLexicography</span> <span class="token punctuation">{</span>   <span class="token comment">// 定义一个比较器，比较策略</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">lowestString</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token comment">//怎么比较排序，自己定义下 </span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>res <span class="token operator">+=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"jibw"</span><span class="token punctuation">,</span> <span class="token string">"ji"</span><span class="token punctuation">,</span> <span class="token string">"jp"</span><span class="token punctuation">,</span> <span class="token string">"bw"</span><span class="token punctuation">,</span> <span class="token string">"jibw"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">lowestString</span><span class="token punctuation">(</span>strs1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"ba"</span><span class="token punctuation">,</span> <span class="token string">"b"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">lowestString</span><span class="token punctuation">(</span>strs2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p> <img src="/../images/typora-user-images/image-20220715190500785.png" alt="image-20220715190500785"></p><p>哈夫曼树解决</p><p>例题3</p><p>给一堆项目，有他的花费和利润，然后你有启动资金去投资它，怎么获利最大</p><p><img src="/../images/typora-user-images/image-20220715192934109.png" alt="image-20220715192934109"></p><p>解题思路：</p><p>如上面所示，先建立一个小根堆，这个小根堆按照所需投资钱数排，它的目的是根据我们的启动资金找出可以投资哪些项目。然后再建立一个大根堆，根据小根堆筛选出来的放进大根堆，大根堆按照利润排序，毕竟在钱够的情况下做利润大的，得到利润的钱后，在去小根堆瞅瞅哪些现在可以做了，筛选出来放大根堆，以此类推</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">class07</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Comparator</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">PriorityQueue</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code05_IPO</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">int</span> p<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>p <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//小根堆比较器</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MinCostComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Node</span> o1<span class="token punctuation">,</span> <span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> o1<span class="token punctuation">.</span>c <span class="token operator">-</span> o2<span class="token punctuation">.</span>c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//大根堆比较器</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MaxProfitComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Node</span> o1<span class="token punctuation">,</span> <span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> o2<span class="token punctuation">.</span>p <span class="token operator">-</span> o1<span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//w是启动资金，k是最多处理几个项目</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findMaximizedCapital</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">W</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">Profits</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">Capital</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token class-name">Profits</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">Profits</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Profits</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">Capital</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//定义堆，通过比较器来看大小</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> minCostQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MinCostComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> maxProfitQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MaxProfitComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//所有节点放在小根堆里</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>minCostQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minCostQ<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> minCostQ<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>c <span class="token operator">&lt;=</span> <span class="token class-name">W</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>maxProfitQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>minCostQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>            <span class="token comment">//剩下的都做不了了，提前</span><span class="token keyword">if</span> <span class="token punctuation">(</span>maxProfitQ<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token class-name">W</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">W</span> <span class="token operator">+=</span> maxProfitQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token class-name">W</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>啥是动态规划</p></blockquote><p>空间换时间</p><p>如何你发现计算中有重复的部分，就把重复的给记录下来，下次不用重复算</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>集合常用api</title>
    <link href="http://example.com/posts/7f1ae6ui.html"/>
    <id>http://example.com/posts/7f1ae6ui.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-04-25T12:39:05.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><p>1）length():获取字符串的长度，其实也就是字符个数<br>2）charAt(int index):获取指定索引处的字符</p><p>3）indexOf(String str):获取str在字符串对象中第一次出现的索引<br>4）substring(int start):从start开始截取字符串<br>5）String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end</p><h3 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h3><p>1）equals(Object obj):比较字符串的内容是否相同</p><p>2）isEmpty()：判断指定字符串是否为空</p><p>3）compareTo(String anotherString)：比较字符串的大小，前者大返回整数，后者大返回负数，相等返回0</p><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>1）toCharArray():把字符串转换为字符数组</p><p>2）toLowerCase():把字符串转换为小写字符串</p><p>3）toUpperCase():把字符串转换为大写字符串</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>1）replace(char oldChar, char newChar)：将指定字符替换成另一个指定的字符</p><p>2）replaceAll(String regex,String replasement)：用新的内容替换全部旧内容</p><blockquote><p>replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\d”, “*”)把个字符串所有的数字字符都换成星号;</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> src <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab43a2c43d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">=</span><span class="token operator">&gt;</span>ab4f2c4fd<span class="token punctuation">.</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">=</span><span class="token operator">&gt;</span>ab4f2c4fd<span class="token punctuation">.</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\\d"</span><span class="token punctuation">,</span><span class="token string">"f"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">=</span><span class="token operator">&gt;</span>abffafcffd<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3）replaceFirst(String regex,String replacement)：替换首个满足条件的内容</p><p>4）contains(CharSequence s)：查看字符串中是都含有指定字符</p><p><img src="/../images/typora-user-images/string" alt="img"></p><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1</span>：put方法：<span class="token function">put</span><span class="token punctuation">(</span>key，value<span class="token punctuation">)</span>，我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为<span class="token keyword">null</span>。<span class="token number">2</span>：get方法：<span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>，主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回<span class="token keyword">null</span>。<span class="token number">3</span>：remove方法：<span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>，主要用来删除map中对应的key及其value值。<span class="token number">4</span>：clear方法，用法：<span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，会清空map中的数据。<span class="token number">5</span>：<span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>，判断map集合中是否包含某个key。<span class="token number">6</span>：<span class="token function">containsKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>，判断map集合中是否包含某个value。<span class="token number">7</span>：<span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：hashmap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，<span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的效率比<span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。<span class="token number">8</span>：<span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：hashmap<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>来取到value的值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li>TreeMap()：创建一个空TreeMap，keys按照自然排序</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>TreeMap(Comparator comparator)：创建一个空TreeMap，按照指定的comparator排序</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {5=val, 4=val, 3=val, 2=val, 1=val}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>TreeMap(Map m)：由给定的map创建一个TreeMap，keys按照自然排序</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"val"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>TreeMap(SortedMap m)：由给定的有序map创建TreeMap，keys按照原顺序排序</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>：将指定映射放入该<span class="token class-name">TreeMap</span>中<span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：清空<span class="token class-name">TreeMap</span>中的所有元素<span class="token class-name">V</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>：从<span class="token class-name">TreeMap</span>中移除指定key对应的映射<span class="token class-name">V</span> <span class="token function">replace</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>：替换指定key对应的value值<span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span>：判断该<span class="token class-name">TreeMap</span>中是否包含指定key的映射<span class="token keyword">boolean</span> <span class="token function">containsValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span>：判断该<span class="token class-name">TreeMap</span>中是否包含有关指定value的映射<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：返回由该<span class="token class-name">TreeMap</span>中的所有映射组成的<span class="token class-name">Set</span>对象<span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：返回该<span class="token class-name">TreepMap</span>中包含的映射的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><blockquote><p>for循环</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span> entry <span class="token operator">:</span> treeMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>迭代器循环</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Iterator</span> iterator <span class="token operator">=</span> treeMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> o2 <span class="token operator">-</span> o1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1、add-Object-element-方法"><a href="#1、add-Object-element-方法" class="headerlink" title="1、add(Object element) 方法"></a>1、add(Object element) 方法</h3><p>add(Object element) 方法用于向ArrayList集合中的添加元素。</p><h3 id="2、size-方法"><a href="#2、size-方法" class="headerlink" title="2、size() 方法"></a>2、size() 方法</h3><p>size()方法用于返回ArrayList集合中元素个数</p><h3 id="3、get-int-index-方法"><a href="#3、get-int-index-方法" class="headerlink" title="3、get(int  index)  方法"></a>3、get(int  index)  方法</h3><p>get(int index)方法用于返回集合中对应位置的元素</p><h3 id="4、add-int-index-Object-element-方法"><a href="#4、add-int-index-Object-element-方法" class="headerlink" title="4、add(int index, Object element) 方法"></a>4、add(int index, Object element) 方法</h3><p>add(int index, Object element) 方法用于在集合指定位置添加元素，原集合中从指定位置开始的元素全部后置</p><h3 id="5、set-int-i-Object-element-方法"><a href="#5、set-int-i-Object-element-方法" class="headerlink" title="5、set(int i, Object element) 方法"></a>5、set(int i, Object element) 方法</h3><p>set(int i, Object element) 方法用于将索引i位置元素替换为元素element并返回被替换的元素</p><h3 id="6、clear-方法"><a href="#6、clear-方法" class="headerlink" title="6、clear() 方法"></a>6、clear() 方法</h3><p>clear() 方法用于清空集合中元素</p><h3 id="7、isEmpty-方法"><a href="#7、isEmpty-方法" class="headerlink" title="7、isEmpty() 方法"></a>7、isEmpty() 方法</h3><p>isEmpty() 方法用于判断集合容器是否为空，如果为空，则返回true，否则返回false。 </p><h3 id="8、iterator"><a href="#8、iterator" class="headerlink" title="8、iterator()"></a>8、iterator()</h3><p>iterator（）不是一个方法而是一个用于返回按适当顺序在列表的元素上进行迭代的迭代器可以用它遍历集合元素</p><h3 id="9、contains-Object-o-方法"><a href="#9、contains-Object-o-方法" class="headerlink" title="9、contains(Object o) 方法"></a>9、contains(Object o) 方法</h3><p>contains(Object o) 方法用以判断集合容器中是否含有指定元素，有返回值，且为boolean型。</p><h3 id="10、remove-int-index-方法"><a href="#10、remove-int-index-方法" class="headerlink" title="10、remove(int index) 方法"></a>10、remove(int index) 方法</h3><p>remove（int index）方法用于移除列表中指定位置的元素，并返回被删元素</p><h3 id="11、remove-Object-o-方法"><a href="#11、remove-Object-o-方法" class="headerlink" title="11、remove(Object o) 方法"></a>11、remove(Object o) 方法</h3><p>remove(Object o) 方法用于移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。</p><h3 id="转字符串数组"><a href="#转字符串数组" class="headerlink" title="转字符串数组"></a>转字符串数组</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">方法一、<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时arr就有了list中的值了`</span>方法二、<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造一个具有指定初始容量的空列表。</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><h3 id="StringBuffer对象的初始化"><a href="#StringBuffer对象的初始化" class="headerlink" title="StringBuffer对象的初始化"></a>StringBuffer对象的初始化</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuffer</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">StringBuffer</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“abc”<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="StringBuffer对象和String对象之间的互转"><a href="#StringBuffer对象和String对象之间的互转" class="headerlink" title="StringBuffer对象和String对象之间的互转"></a>StringBuffer对象和String对象之间的互转</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span><span class="token class-name">StringBuffer</span> sb1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“<span class="token number">123</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">StringBuffer</span> sb2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//String转换为StringBuffer</span><span class="token class-name">String</span> s1 <span class="token operator">=</span> sb1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//StringBuffer转换为String</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1、append方法"><a href="#1、append方法" class="headerlink" title="1、append方法"></a>1、append方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> user <span class="token operator">=</span> “test”<span class="token punctuation">;</span><span class="token class-name">String</span> pwd <span class="token operator">=</span> “<span class="token number">123</span>”<span class="token punctuation">;</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>“select <span class="token operator">*</span> from userInfo where username<span class="token operator">=</span>“<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>“ and pwd<span class="token operator">=</span>”<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样对象sb的值就是字符串“select * from userInfo where username=test and pwd=123”</p><h4 id="2、deleteCharAt方法"><a href="#2、deleteCharAt方法" class="headerlink" title="2、deleteCharAt方法"></a>2、deleteCharAt方法</h4><p>该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“<span class="token class-name">Test</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>sb<span class="token punctuation">.</span> <span class="token function">deleteCharAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该代码的作用删除字符串对象sb中索引值为1的字符，也就是删除第二个字符，剩余的内容组成一个新的字符串。所以对象sb的值变为”Tst”</p><h4 id="3、delete方法"><a href="#3、delete方法" class="headerlink" title="3、delete方法"></a>3、delete方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">StringBuffer</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“<span class="token class-name">TestString</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>sb<span class="token punctuation">.</span> delete <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4、insert方法"><a href="#4、insert方法" class="headerlink" title="4、insert方法"></a>4、insert方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">StringBuffer</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">boolean</span> b<span class="token punctuation">)</span><span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“<span class="token class-name">TestString</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>sb<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该示例代码的作用是在对象sb的索引值4的位置插入false值，形成新的字符串，则执行以后对象sb的值是”TestfalseString”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>马哲</title>
    <link href="http://example.com/posts/7a46f93c.html"/>
    <id>http://example.com/posts/7a46f93c.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-04-25T10:24:16.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p><strong>立德树人</strong>是教育之本</p><p>民主党派成员最多的是<strong>民盟</strong></p><p>新民主革命的动力包括：<strong>工人、农民、小资产阶级、民族阶级</strong></p><p>马克思主义哲学是<strong>无产阶级世界观</strong></p><p>我党把马列主义和中国实际相结合的最初成果：<strong>《中国社会各阶级的分析》、《湖南农民运动考察报告》</strong></p><p>1956年4月，毛泽东同志提出<strong>“百花齐放，百家争鸣”</strong>是我国发展科学、繁荣文学艺术的方针</p><p>习近平外交思想始终坚持<strong>实践第一</strong>的观点</p><p><strong>古田会议</strong>决议了中心思想是要用<strong>无产阶级思想进行军队和党的建设</strong>（第九次党代表大会）</p><p><strong>八七会议</strong>结束了<strong>陈独秀右倾投降主义</strong>在中央的统治，确立了<strong>土地革命和武装反抗国民党反动派</strong>的总方针，并发动了农民进行<strong>秋收起义</strong>（大革命失败后）</p><p><strong>洛川会议</strong>为了动员一切力量抗日，并具体指定、建立党领导抗战的纲领和政府。</p><p><strong>遵义会议</strong>是中国共产党<strong>第一次独立自主地运用马克思列宁主义解决自己路线</strong>、方针和政策的会议。<strong>挽救党、挽救红军、挽救新中国</strong>，是<strong>生死攸关转折点</strong>，提出红军应该采取<strong>积极防御</strong>的战略方针</p><p><strong>邓小平</strong>提出了<strong>一国两制</strong></p><p><strong>陈独秀</strong>上海创办<strong>《青年杂志》</strong>，后改名<strong>《新青年》</strong><u>（它也是中国共产党第一个公开性机关刊物</u>），迁往<strong>北京成为新文化运动的主要阵</strong>地，标志着<strong>新文化运动的兴起</strong>，口号为<strong>民主</strong>和<strong>科学</strong>，没有参加中共一大</p><p><strong>董必武</strong>参加了上海兴业路一大会址<strong>纪念馆</strong>。为纪念馆写下了“<strong>作始也简，将毕也钜</strong>”。他<strong>出席了中共一大</strong></p><p><strong>李大钊</strong>是中国传播马克思主义<strong>最早</strong>的革命先驱，被称为<strong>“引来天火的人”</strong>，没有参加中共一大     </p><p><strong>《中国革命和中国共产党》</strong>一文中，毛泽东指出现阶段的敌人是<strong>帝国主义和封建地主阶级</strong>，主要任务也是干这两个，但<strong>最主要</strong>的是干帝国主义</p><p>党员开除党籍，<strong>五年内</strong>不得重新入党</p><p>生产实践、社会实践、科学实践，最基础的最重要的是<strong>生产实践</strong></p><p><strong>两个务必</strong>是毛泽东提出来的，在<strong>七届二中</strong>全会（务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续地保持艰苦奋斗的作风）</p><p><strong>三湾改编</strong>首次提出官兵平等</p><p><strong>毛泽东思想</strong>初步形成的标志是<strong>农村包围城市</strong></p><p>1927年8月1号，八一<strong>南昌起义</strong>，让南昌获得了<strong>英雄城市</strong>的美誉</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p><strong>十三大</strong>概况“<strong>一个中心、两个基本点</strong>”基本路线（一个中心，指以经济建设为中心；两<em>个基本点</em>，指坚持四项基本原则，坚持改革开放。），<strong>第一次</strong>比较系统地概述了<strong>社会主义初级阶段理论</strong>。</p><p>十二大提中特</p><p>十五大邓小平指导</p><p>十六大三个代表</p><p>十七大科学发展观</p><p>十八大全面建成小康</p><p>一大建党，二大立岗</p><p>三大国共合作</p><p>一大立党二立纲，三大国共要合作。<br>四大领导工农忙，五大批评陈独秀。<br>六大苏联求帮忙，南昌打响第一枪。<br>八七枪杆出政权，三湾军队要听党。<br>古田军队建新军，遵义军事与组织。<br>瓦統洛后。<br>毛六六论马🐎，七大确定毛指导。<br>七届二中转城市，八大主矛和建设。<br>十一三中要开放，十二小平提中特。<br>十三阶段路线定，南方三猫论本质。<br>十四目标在市场，十五小平成指导。<br>十六提出三代表，十七科学发展观。<br>十八科学成指导，十九走进新时代。</p><p>党的一大在<strong>莫斯科召开</strong></p><p><strong>陈独秀和李大钊</strong>都未参加一大</p><p>我国<strong>对资本主义工商业</strong>进行社会改造的基本政策是<strong>“和平赎买”</strong></p><p>科学发展观<strong>第一要义</strong>是发展，<strong>核心</strong>是以人为本，<strong>基本要求</strong>是全面协调可持续性，<strong>根本方法</strong>是统筹兼备</p><p>马克思主义中国化的<strong>第一个重要理论</strong>成果是毛泽东思想</p><p>我国经济已经由<strong>高速增长</strong>转向<strong>高质量发展</strong></p><p><strong>红船精神</strong>是敢为人先的首创精神</p><p><strong>长征精神</strong>是把全国人民和中华民族的根本利益看得高于一切</p><p>意识反作用于物质的基本途径是<strong>实践</strong></p><p>我国进行<strong>土地改革</strong>的基本原因是封建土地制度阻碍了农村经济和社会的发展</p><p>社会主义的根本方向是<strong>消灭剥削、消灭两级分化</strong></p><p>《实践论》《矛盾论》标志着毛泽东哲学思想形成</p><p>邓小平邓小平<strong>南方谈话</strong>内容是<strong>‘三个有利于标志’</strong>（两力一平）（是否提高生产力、综合国力、生活水平）（黑猫白猫，能抓老鼠就好）</p><p><strong>一国两制</strong>是邓小平提出来的</p><p>十五大将邓小平理论写入党章</p><p>《星星之火可以燎原》毛主席回复林彪的，林彪问毛主席红旗还需要打多久</p><p>《论联合政府》是<strong>七大提出</strong>的，主要弄了<strong>三大作风</strong>，（理论和实践相结合，与人民群众紧密联系在一起，自我批评）</p><p>实践决定意识，是因为实践具有<strong>直接现实性</strong>（通过实践，直接可以变成现实，比如盖一个房子，直接就有了）</p><p>实践具有<strong>主观能动性</strong>，因为它是有目的有意思的去实践，这是和动物区分的，比如动物也会盖房子，它们没有目的和意识</p><p>实践具有<strong>社会历史性</strong>，具有社会性受到历史条件的制约，比如你实践割麦子，有条件用机器，没条件用手</p><p>意识是对客观世界的主观反映，意识的内容是客观的，表现形式是主观的</p><p>所有的意识都要来源于客观存在</p><p>无产阶级领导的<strong>中心问题</strong>是农民问题（农民也是最多的，主力军）</p><p>外因要通过内因起作用（比如说你妈妈天天唠叨你好好学习，这是个外因，但如果你不听，也起不到作用）</p><p>党的性质是先进性和纯洁性</p><p>毛泽东最先提出马克思主义中国化（马66论马）</p><p>社会的基本矛盾是<strong>社会发展的基本动力</strong>（社会基本矛盾包括：生生经上。生产力和生产关系，经济基础和上层建筑）</p><p>生产力决定生产关系，生产关系反作用于生产力（反作用是两面的，好的促进，坏的抑制）</p><p>生产力是人类改造自然的能力（人与自然），生产关系是人们之间的关系（人与人）</p><p>马克思的两大发现：唯物史观、剩余价值学说</p><p>红船精神包括：开天辟地、敢为人先的<strong>首创</strong>精神，坚定理想、百折不挠的<strong>奋斗</strong>精神，立党为公、忠诚为民的<strong>奉献</strong>精神</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>神州十号载人飞船，男的有<strong>聂海胜、张晓光</strong>，女的有<strong>王亚平</strong>，其中，聂海胜担任指令长</p><p><strong>中华名族</strong>由危亡走向振兴的转折点是<strong>抗日战争的胜利</strong>（党的是遵义会议）</p><p>主次矛盾与矛盾的主要方面（主次矛盾讲的是不同的事情，<strong>至少是两件事</strong>，比如发展面对经济、环境、人口问题等）（矛盾的主要方面是<strong>讲的一件事情</strong>，例如科技是把双刃剑）</p><p>群众路线的<strong>核心</strong>是一切为了群众，一切依靠群众</p><p>延安精神的<strong>核心</strong>是自力更生、艰苦奋斗</p><p>中共七大还没有建国，八大规模大</p><p>机械唯物主义（形而上学）（原子是事物的属性）</p><p>朴素唯物主义（看到的）</p><p>物质的唯一<strong>特性</strong>是客观实在性（不随人的意志改变），唯一<strong>属性</strong>是运动</p><p>实践是认识的来源，一切认识归根到底是从实践中获得（实践是认识的唯一源泉）（但实践不是认识的唯一途径，也可通过视频、图片等认识）</p><p>实践是认识的发展动力。实践中遇到的新问题需要新认识去解决，从而推动认识的发展</p><p><strong>（前两个实践：先有实践。后面两个是先有认识。这样来做题）</strong></p><p>实践是认识的目的，从实践中来，到实践中去，认识的目的是改造世界，到实践中去</p><p>实践是检验真理的唯一标志</p><p>毛泽东中国革命最后一个农村根据地是<strong>西柏坡</strong>（七届二中，提出了两个务必，进京赶考），像北平进发，进了北平<strong>香山</strong>，标志着中国革命重心从农村转向城市</p><p>意识具有目的性和计划性（比如想上岸，一天计划做多少题）</p><p>意识具有主动创造性（比如龙）</p><p>意识能指导实践改造世界（指导是中心词，包含正确和错误，考的时候要都说）</p><p><strong>意识对人体的生理活动具有调节和控制作用</strong>（比如笑一笑十年少）（望梅止渴）</p><p>意识只有人有</p><p>意识没有客观实在性，物质才有</p><p>意识受到主题的影响（比如不同人看到同一个问题意识不同）</p><p>发展是<strong>前进性和曲折性</strong>的统一</p><p>发展有其<strong>自身的客观规律</strong>，不以人的意志为转移（种啥得啥）</p><p>毛泽东思想和中国特色社会主义的区别：<strong>毛不改革，中特不革命</strong></p><p>建设现代化经济体系，<strong>着力点</strong>放在实体经济上</p><p>中华苏维埃第一次在<strong>瑞金</strong>召开</p><p>一国两制 ”<strong>爱国者治港</strong>“</p><p>毛泽东思想围绕的主题是<strong>革命和建设</strong></p><p>邓小平理论主题是<strong>什么是社会主义，怎样建设社会主义</strong></p><p>十九大报告：以<strong>人民安全</strong>为宗旨，以<strong>政治安全</strong>为根本</p><p>三大规律：对立统一；质量互变规律；否定之否定规律</p><p>辩证否定的实质是扬弃。矛盾是事物发展的源泉和动力。辩证否定是事物联系和发展的环节。</p><p>大革命失败后，中国共产党建立的<strong>第一个农村根据地</strong>是<strong>井冈山</strong>根据地</p><p>中国革命农村包围城市、武装夺取政权根本在于处理好<strong>土地革命、武装斗争、农村革命</strong>根据地之间的关系</p><p>新民主主义的三大法宝：<strong>统一战线、武装斗争、党的建设</strong></p><p>人民统一战线：<strong>工人阶级、农民阶级、名族资产阶级</strong>三者之间的关系</p><p>抗战统一战线：<strong>进步势力、中间势力、顽固势力</strong></p><p><strong>瓦窑堡会议</strong>确定了建立抗日民族统一战线方针</p><p>1938年<strong>《论持久战》</strong>提出了<strong>民兵是胜利之本</strong></p><p><strong>延安整风</strong>：反对主观主义以整顿<strong>学风</strong>（中心任务）、反对宗派主义以整顿<strong>党风</strong>、反对党八股文以整顿<strong>文风</strong></p><p>意识对于客观事物的反映是<strong>主动的、有选择的</strong>（每个人看同一件事物的意识不同，比如蛋糕，艺术家看到的和普通人不一样）</p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>十八届三中全会提出<strong>市场</strong>在配置中发挥决定性作用（2013年习总书记主持）</p><p>十八届四中（2014）提出了依法治国</p><p>十八大（一选举，二宪法，三改革，四法律，五经济，六党建）</p><p>毛泽东思想灵魂包括：实事求是（根本点，出发点），群众路线（工作路线），独立自主（立足点）。</p><p><img src="/../images/%E9%A9%AC%E5%93%B2/image-20230411165003291.png" alt="image-20230411165003291"></p><p>本本主义也是教条主义，就是做什么事情都不从实际出发，生搬硬套</p><p>在党的纪律中，<strong>政治纪律</strong>最重要、最根本、最关键</p><p><strong>画梅不能止渴反映了</strong>观念东西不能代替物质东西</p><p>精神和物质的<strong>同一性</strong>，这个是你认为这个世界是否是可知的，如果你认为是可知的，就是同一的，这也是可知论</p><p>精神对物质的<strong>相对独立性</strong>：意识可能超前，也可能落后</p><p>精神可以转化成物质，通过实践</p><p>小康：邓小平提出放入国家。十二大提出，十六大建设，十八大建成</p><p>家庭是道德建设的<strong>起点</strong>，学校是道德建设的<strong>阵地</strong></p><p><img src="/../images/%E9%A9%AC%E5%93%B2/image-20230412130413064.png" alt="image-20230412130413064"></p><p><strong>经济特区：生下三头猪（深圳、厦门、汕头、珠海）去海南度假，结果去了新疆喀什（kā shí）霍尔果斯</strong></p><p><img src="/../images/%E9%A9%AC%E5%93%B2/image-20230412131157200.png" alt="image-20230412131157200"></p><p>伟大载人航天精神：淡泊名利，默默奉献</p><p>实践高于理论认识，是因为实践具有直接现实性</p><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p><strong>主要矛盾</strong>对事物发展起决定性作用</p><p><img src="/../images/%E9%A9%AC%E5%93%B2/image-20230412153659558.png" alt="image-20230412153659558"></p><p><strong>中国精神</strong>包括民族精神（核心爱国主义）和时代精神（核心改革创新）</p><p><strong>爱国主义</strong>始终是把中华民族坚强团结在一起的精神力量，<strong>改革创新</strong>始终是鞭策我们在改革开放中与时俱进的精神力量</p><p><img src="/../images/%E9%A9%AC%E5%93%B2/image-20230412153725939.png" alt="image-20230412153725939"></p><p><strong>整体与部分关系</strong>：1.整体居于<strong>主导地位</strong>              2.关键部分对整体起决定性作用         3.整体是各部分的有机构成，具有部分没有的功能（比如说钟表，有计时功能，但是拆开后每个指针没有该功能）</p><p>中国共产党主题就是为了实现中华民族伟大复兴</p><p>实事求是的“是”为规律性</p><p><img src="/../images/%E9%A9%AC%E5%93%B2/image-20230412153736095.png" alt="image-20230412153736095"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="公共知识" scheme="http://example.com/categories/%E5%85%AC%E5%85%B1%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>秋招</title>
    <link href="http://example.com/posts/7f1ae999.html"/>
    <id>http://example.com/posts/7f1ae999.html</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-06-04T03:43:11.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>jmeter</p><p>请求组</p><p>http请求</p><p>结果在监听器显示</p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>引入redis</p><p><img src="/../images/typora-user-images/image-20221013163430720.png" alt="image-20221013163430720"></p><h4 id="setIfAbsent-和-setnx"><a href="#setIfAbsent-和-setnx" class="headerlink" title="setIfAbsent 和 setnx"></a>setIfAbsent 和 setnx</h4><p>setIfAbsent 是java中的方法<br>setnx 是 redis命令中的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BoundValueOperations</span> boundValueOperations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span>redisKey<span class="token punctuation">)</span><span class="token punctuation">;</span>flag <span class="token operator">=</span> boundValueOperations<span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// flag 表示的是否set</span>boundValueOperations<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>seconds<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 重复</span>    repeatSerial<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>serialNo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">// 没有重复</span>    norepeatSerial<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>serialNo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../images/typora-user-images/image-20221013165816022.png" alt="image-20221013165816022"></p><p>问题</p><p>b线程释放a线程的锁</p><p>可以在value随机值，然后删的时候判断一下还是原来的随机值吗，但是这个是一个过程，先查是不是原来的，再删，这不是一个原子操作。用lua脚本、</p><p>如何用lua</p><p>可以在服务器写好，然后调用，优点是方便，但是修改了或者调用有资源消耗了</p><p>在java代码里直接写麻烦</p><p>java代码里写</p><ol><li><p>先在resources中创建一个lock.lua（要和application.yml同级目录）</p><p><img src="/../images/typora-user-images/image-20221013170654850.png" alt="image-20221013170654850"></p><p><img src="/../images/typora-user-images/image-20221013170921548.png" alt="image-20221013170921548"></p><p><img src="/../images/typora-user-images/image-20221013171136417.png" alt="image-20221013171136417"></p></li><li><p>在测试</p></li></ol><h2 id="threadlocal和synchronized区别"><a href="#threadlocal和synchronized区别" class="headerlink" title="threadlocal和synchronized区别"></a>threadlocal和synchronized区别</h2><p><img src="/../images/typora-user-images/image-20221014150057568.png" alt="image-20221014150057568"></p><p>threadlocal原理</p><p><img src="/../images/typora-user-images/image-20221014151907121.png" alt="image-20221014151907121"></p><p>  <img src="/../images/typora-user-images/image-20221014152237474.png" alt="image-20221014152237474"></p><h2 id="spring-bean生命周期"><a href="#spring-bean生命周期" class="headerlink" title="spring bean生命周期"></a>spring bean生命周期</h2><p>1.创建前准备，比如调用工厂的后置处理器<br>2.对象实例化，根据bean定义，找到类信息，使用反射创建对象（默认用无参构造，如果没有无参(有一个有参，则用有参；如果有多个有参，报错)（有参参数是在spring容器里面找，先bytype后byname））</p><p><img src="/../images/typora-user-images/image-20221015165359033.png" alt="image-20221015165359033"></p><p>3.对象属性装填，装填成员变量，如果成员变量有其他bean，则加载其他bean（比如autoware resource这些）<br>4.执行初始化，某些对象可能有初始化方法，在此时调用</p><p><img src="/../images/typora-user-images/image-20221015170145611.png" alt="image-20221015170145611"></p><p>5.销毁</p><p><img src="/../images/typora-user-images/image-20221015163903568.png" alt="image-20221015163903568"></p><p>首先初始化，因为spring容器中都是存放的一个个对象。这个初始化是用反射创建，默认使用无参构造，（如果没有看上面）。然后对对象进行属性填充（依赖注入），比如autowire、resource等。然后某些对象可能有初始化方法，比如实现initiallizingbean方法，实现afterproperitiesset进行初始化。然后判断是否存在aop切入点，如果有，则创建aop代理类，放进spring容器里的也是aop代理类。最后销毁。</p><h2 id="单例bean和单例模式"><a href="#单例bean和单例模式" class="headerlink" title="单例bean和单例模式"></a>单例bean和单例模式</h2><p>不是一回事</p><p><img src="/../images/typora-user-images/image-20221015165701876.png" alt="image-20221015165701876"></p><h2 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h2><p>加这样一个注解</p><p><img src="/../images/typora-user-images/image-20221015171856706.png" alt="image-20221015171856706"></p><h2 id="数据库表设计规范"><a href="#数据库表设计规范" class="headerlink" title="数据库表设计规范"></a>数据库表设计规范</h2><ol><li><p>字段</p><p>加注释</p><p>3范式</p><p>建议有创建时间和修改时间</p><p>固定的用char</p></li></ol><h2 id="线程同步的四种方式"><a href="#线程同步的四种方式" class="headerlink" title="线程同步的四种方式"></a>线程同步的四种方式</h2><p>一，什么是<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5&amp;spm=1001.2101.3001.7020">线程同步</a>和互斥</p><p>同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。这里的同步千万不要理解成那个同时进行，应是指协同、协助、互相配合。线程同步是指多线程通过特定的设置（如互斥量，事件对象，临界区）来控制线程之间的执行顺序（即所谓的同步）也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。</p><blockquote><p>解决 </p></blockquote><p>方法一：使用synchronized关键字</p><p>方法二：wait和notify</p><h2 id="线程间通信的几种实现方式"><a href="#线程间通信的几种实现方式" class="headerlink" title="线程间通信的几种实现方式"></a><a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1&amp;spm=1001.2101.3001.7020">线程间通信</a>的几种实现方式</h2><p>方式一：使用 <em>volatile</em> 关键字</p><p>方式二：使用Object类的wait() 和 notify() 方法</p><h2 id="Session的执行流程"><a href="#Session的执行流程" class="headerlink" title="Session的执行流程"></a>Session的执行流程</h2><p>浏览器发起一个请求到服务器，服务器先检查是否携带了一个叫做JSEESIONID的Cookie。</p><p>如果有携带，会将此cookie值取出来（比如abc），然后从服务器的session池中找到ID为abc的session返回给调用者。<br>如果没有携带JSESSIONID 这个Cookie，服务器就会自动创建一个session对象并且生成一个随机字符串（abc）作为此sessionID保存到session池中，在服务器为客户端响应时会自动创建一个键为“JSESSIONID”，值为“abc”的cookie对象让浏览器存储起来，以便下次访问的时候带着</p><h2 id="怎么看走没走索引"><a href="#怎么看走没走索引" class="headerlink" title="怎么看走没走索引"></a>怎么看走没走索引</h2><p><img src="/../images/typora-user-images/index" alt="img"></p><p><img src="/../images/typora-user-images/image-20221020201624756.png" alt="image-20221020201624756"></p><p>解释Explain得到的结果</p><ol><li>type 反应查询语句的性能<br>我们主需要注意一个最重要的的 type 的信息很明显地体现出是否用到了索引：</li></ol><p>type 结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p><img src="/../images/typora-user-images/image-20230527193514898.png" alt="image-20230527193514898"></p><p>一般来说，得保证查询至少达到 range 级别，最好能达到 ref 级别，否则就可能出现性能问题。</p><p><img src="/../images/typora-user-images/image-20230527193537509.png" alt="image-20230527193537509"></p><blockquote><p>解析</p></blockquote><p>反映用什么样的方式查询数据的</p><ol start="2"><li>possible_keys: SQL查询时用到的索引。<br>可以看到，没加索引时，possible_keys 的值为 NULL，加了索引后的值为 address，即用到了索引address(索引默认为(column_list)中的第一个列的名字).</li></ol><ol start="3"><li>key 显示SQL实际决定查询结果使用的键(索引)。如果没有使用索引，值为NULL<br>可以看到，没加索引时，key 的值为 NULL，加了索引后的值为 address，即决定查询结果用到了索引address</li></ol><ol start="4"><li>rows 显示MySQL认为它执行查询时必须检查的行数<br>可以看到，没加索引时，rows 的值为17，即数据表student中所有数据，说明没加索引时的SQL查询是全表扫描；</li></ol><p>加了索引后，rows 的值为6，数据库表中address以“北京市”开头的一共也就6条，SQL在执行查询操作时，一共也检查了6行，不必进行全表扫描查询，可以很容易得出结论：加索引的SQL查询性能远高于不加索引的情况。</p><p>5）extra</p><p><img src="/../images/typora-user-images/image-20230527194416449.png" alt="image-20230527194416449"></p><h2 id="模糊查询不走怎么解决"><a href="#模糊查询不走怎么解决" class="headerlink" title="模糊查询不走怎么解决"></a>模糊查询不走怎么解决</h2><ol><li><p>通过业务手段避免，举个实际栗子，博主之前做了一个汽车仓储项目，需求要求汽车表查询时候，车架号要有模糊查询操作，但是实际上对于车架号这个东西有个特殊的业务属性，就是车架号的后六位，基本可以在全省锁定到某一台车，全国不会超过三台车。所以业务人员在实际使用系统的时候，也只是输入后六位进行模糊查询，因此，在表设计的时候就将车架号字段<strong>冗余了一个字段</strong>，用于存储倒序的车架号，在进行模糊查询的时候，使用这个倒序字段进行<strong>右模糊查询</strong>，从而达到走索引的目的。有些时候，通过业务手段是可以达到一个优化要求的。</p></li><li><p>内连接<img src="/../images/typora-user-images/image-20221020202930285.png" alt="image-20221020202930285"></p><p><img src="/../images/typora-user-images/image-20221020202950716.png" alt="image-20221020202950716"></p></li></ol><p>解决地址<a href="https://www.cnblogs.com/Marydon20170307/p/15866354.html">https://www.cnblogs.com/Marydon20170307/p/15866354.html</a></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><a href="https://blog.csdn.net/m0_53474063/article/details/112389756">https://blog.csdn.net/m0_53474063/article/details/112389756</a></p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p><img src="/../images/typora-user-images/image-20221020212040900.png" alt="image-20221020212040900"></p><p>（属性相互赋值）</p><p>自己写出来的比较好解决</p><p><img src="/../images/typora-user-images/image-20221020212105183.png" alt="image-20221020212105183"></p><p>ioc的话比较难解决，主要有两个问题</p><p><img src="/../images/typora-user-images/image-20221020212201492.png" alt="image-20221020212201492"></p><p><img src="/../images/typora-user-images/image-20221020212458191.png" alt="image-20221020212458191"></p><p>从单例池中，属性注入b，由于b没有，去创建b，创建的过程有需要注入a。此时a没有，死循环了</p><p>解决方法</p><p>半成品池</p><p><img src="/../images/typora-user-images/image-20221020212734135.png" alt="image-20221020212734135"></p><p>a一旦被实例化，就把他放在半成品池中（二级缓存解决，为啥用三级缓存，因为解决不了aop代理）</p><p>aop代理问题</p><p><img src="/../images/typora-user-images/image-20221020213021498.png" alt="image-20221020213021498"></p><p><img src="/../images/typora-user-images/image-20221020213517906.png" alt="image-20221020213517906"></p><p>等于说有一个前置方法，在调用的时候提前创建这个代理类</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>1、轮询法</p><p>轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。</p><p>2、随机法</p><p>随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子[5]。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。</p><p>3、最小连接法</p><p>最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。</p><p>Ribbon是Netflix发布的开源项目，主要功能是提供<strong>客户端的软件负载均衡算法和服务调用</strong></p><h3 id="Ribbon默认负载轮询算法原理"><a href="#Ribbon默认负载轮询算法原理" class="headerlink" title="Ribbon默认负载轮询算法原理"></a>Ribbon默认负载轮询算法原理</h3><p><strong>默认负载轮训算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始</strong>。</p><p>注解LoadBalancer</p><h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><h3 id="1-查看系统内存free"><a href="#1-查看系统内存free" class="headerlink" title="1 查看系统内存free"></a>1 查看系统内存free</h3><p>netstat -anp |grep 端口号</p><p>top 查看进程 cup使用情况   内存的使用情况</p><p>**        Load Average**load average: 1.79, 2.10, 2.28  系统负载，三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。如1.79，表示最近一分钟平均负载。</p><p>free -h</p><p>ps  可以看pid 这个杀死用，也可以看cup使用情况内存使用情况</p><h2 id="断开通信除了四次挥手还有什么方式？"><a href="#断开通信除了四次挥手还有什么方式？" class="headerlink" title="断开通信除了四次挥手还有什么方式？"></a>断开通信除了四次挥手还有什么方式？</h2><p>  如果主机需要尽快关闭连接（或连接超时，或端口、主机不可达）时，发送RST包（RST表示复位）强制关闭TCP连接。</p><p>发送RST包关闭连接时，可以丢弃缓存区的包直接发送RST包，而接收端收到RST包后，也不必发送ACK包来确认。</p><h2 id="线程池场景"><a href="#线程池场景" class="headerlink" title="线程池场景"></a>线程池场景</h2><p><a href="https://www.bilibili.com/video/BV1dt4y1i7Gt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc%EF%BC%88B%E7%AB%99%EF%BC%89">https://www.bilibili.com/video/BV1dt4y1i7Gt/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc（B站）</a></p><p><a href="https://www.bilibili.com/video/BV1ca411B78i/?spm_id_from=333.880.my_history.page.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1ca411B78i/?spm_id_from=333.880.my_history.page.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p><p>报警那块</p><p><img src="/../images/typora-user-images/image-20230321084249317.png" alt="image-20230321084249317"></p><p>我是把每个传感器作为一块子的，每一个子的都用线程池</p><p>这里设置了一个计数器来阻止主线程继续，让主线程等线程池中弄完再走</p><p>CountDownLatch</p><p>这个是同步工具类中的计数器，有几组（我这里是传感器的数量（这里就16了））设置初始值为多少</p><blockquote><p>CountDownLatch原理</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/95835099">https://zhuanlan.zhihu.com/p/95835099</a></p><blockquote><p>池化思想</p></blockquote><p>线程池、数据库连接池、字符串常量池都是这样，池化思想，目的是为了提高资源利用率</p><blockquote><p>常见知识点</p></blockquote><p><a href="https://blog.csdn.net/tumu6889/article/details/125257712">https://blog.csdn.net/tumu6889/article/details/125257712</a></p><blockquote><p>阻塞队列</p></blockquote><p><img src="/../images/typora-user-images/image-20230523110757497.png" alt="image-20230523110757497"></p><p><img src="/../images/typora-user-images/image-20230527201623595.png" alt="image-20230527201623595"></p><p><img src="/../images/typora-user-images/image-20230527201705475.png" alt="image-20230527201705475"></p><blockquote><p>线程池方法</p></blockquote><p><img src="/../images/typora-user-images/image-20230523112337372.png" alt="image-20230523112337372"></p><p>这些本质也是调用的threadpool</p><blockquote><p>拒绝策略</p></blockquote><ul><li>AbortPolicy中止策略：丢弃任务并抛出异常。比较关键的业务推荐使用该策略，这样在系统不能承载更大并发量的时候就能通过异常发现</li><li>DiscardPolicy丢弃策略：丢弃任务不抛异常。一些无关紧要的任务可以使用这个策略</li><li>DiscardOldestPolicyi弃老策略：根据实际业务来决定是否允许丢弃老任务</li><li>CallerRunsPolicy：由调用者处理。一般在不允许失败、对性能要求不高、并发量小的场景使用</li></ul><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><blockquote><p>node</p></blockquote><p><img src="/../images/typora-user-images/image-20230527210346149.png" alt="image-20230527210346149"></p><p>有一个内部类node，如上图所示，每个node都有prev、next、waitstatus（记录上一个节点是谁，下个节点，状态（这个状态是上面那两个标志exclusive、signal））</p><p><img src="/../images/typora-user-images/image-20230527210659192.png" alt="image-20230527210659192"></p><p>还有这一个属性，记录当前绑定的线程</p><blockquote><p>头和尾节点</p></blockquote><p><img src="/../images/typora-user-images/image-20230527210936511.png" alt="image-20230527210936511"></p><blockquote><p>state</p></blockquote><p><img src="/../images/typora-user-images/image-20230527211520544.png" alt="image-20230527211520544"></p><p>只要不是0，说明拿到锁</p><blockquote><p>结构图</p></blockquote><p><img src="/../images/typora-user-images/image-20230527211050638.png" alt="image-20230527211050638"></p><h2 id="Renntralock"><a href="#Renntralock" class="headerlink" title="Renntralock"></a>Renntralock</h2><blockquote><p>非公平锁</p></blockquote><p><img src="/../images/typora-user-images/image-20230527211636401.png" alt="image-20230527211636401"></p><p>通过cas，如果把0修改成1，说明成功获取到了锁（这里通过cas怕别人并发拿到）</p><p><img src="/../images/typora-user-images/image-20230527212234968.png" alt="image-20230527212234968"></p><p><img src="/../images/typora-user-images/image-20230527213852700.png" alt="image-20230527213852700"></p><p><img src="/../images/typora-user-images/image-20230527214030885.png" alt="image-20230527214030885"></p><blockquote><p>锁重入</p></blockquote><p><img src="/../images/typora-user-images/image-20230527213255789.png" alt="image-20230527213255789"></p><blockquote><p>参考资料</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/45305463">https://zhuanlan.zhihu.com/p/45305463</a></p><p><a href="https://zhuanlan.zhihu.com/p/540999126">https://zhuanlan.zhihu.com/p/540999126</a></p><p><img src="https://img-blog.csdnimg.cn/20201111200435712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="redis-1"><a href="#redis-1" class="headerlink" title="redis"></a>redis</h2><blockquote><p>数据类型</p></blockquote><p><img src="/../images/typora-user-images/image-20230603205850759.png" alt="image-20230603205850759"></p><blockquote><p>zset数据结构</p></blockquote><p>压缩链表和跳表</p><blockquote><p>压缩列表</p></blockquote><p>压缩列表本质上就是一个数组，只不过增加了一些节点</p><p><img src="/../images/typora-user-images/image-20230603205736235.png" alt="image-20230603205736235"></p><p>如上图所示，黄色是增加的部分</p><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><blockquote><p>跳表</p></blockquote><p>之前只能从头一个一个遍历，时间复杂度为 O(N) </p><p>跳表是增加了多级索引</p><p>例如每隔一个数据就建立一层索引，建立多层就类似于二分查找了，时间复杂度 O(logN) </p><p><img src="/../images/typora-user-images/image-20230603210045950.png" alt="image-20230603210045950"></p><blockquote><p>什么时候用压缩列表，什么时候用跳表？</p></blockquote><p>有序集合保证元素数量小于128个时，用压缩列表</p><blockquote><p>红黑树的时间复杂度也是O（logn），为啥 不用它，而选择跳表</p></blockquote><p>首先，跳表可以查范围数据，比如上述查22-27，这样可以找到22后直接遍历即可</p><p>其次，跳表是通过多层索引，结构比较简单，更加容易实现。红黑树还要调节点</p><blockquote><p>参考资料</p></blockquote><p><a href="https://www.bilibili.com/video/BV1kh411x7Jc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc">https://www.bilibili.com/video/BV1kh411x7Jc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c2eaa7091973b76eb57f77f9dfc9eecc</a></p><blockquote><p>Redis为什么不用b+树？MySQL为什么不用跳表？</p></blockquote><ol><li>这个问题在于 <strong>Redis是直接操作内存的并不需要磁盘io而MySQL需要去读取io</strong>，所以mysql要使用b+树的方式减少磁盘io，B+树的原理是 叶子节点存储数据，非叶子节点存储索引，每次读取磁盘页时就会读取一整个节点,每个叶子节点还有指向前后节点的指针，为的是最大限度的降低磁盘的IO;因为数据在内存中读取耗费的时间是从磁盘的IO读取的百万分之一</li><li>而Redis是 内存中读取数据，不涉及IO，因此使用了跳表，跳表明显是更<strong>快更简单</strong>的方式。</li></ol><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><blockquote><p>原理</p></blockquote><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>简单来说就是准备一个长度为 m 的位数组并初始化所有元素为 0，用 k 个散列函数对元素进行 k 次散列运算跟 len(m)取余得到 k 个位置并将 m 中对应位置设置为 1。<br><img src="/../images/typora-user-images/bab5a3609761d1673465184227161021.png" alt="img"></p><blockquote><p>优点</p></blockquote><ol><li>空间占用极小，因为本身不存储数据而是用比特位表示数据是否存在，某种程度有保密的效果。</li><li>插入与查询时间复杂度均为 O(k)，常数级别，k 表示散列函数执行次数。</li><li>散列函数之间可以相互独立，可以在硬件指令层加速计算。</li></ol><blockquote><p>缺点</p></blockquote><p>可能存在误判</p><h2 id="redis为啥快"><a href="#redis为啥快" class="headerlink" title="redis为啥快"></a>redis为啥快</h2><p>1.在内存</p><p>2.数据结构多，找到对应的</p><p>3.单线程，没有啥切换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="PicGo" scheme="http://example.com/tags/PicGo/"/>
    
    <category term="GitHub图床" scheme="http://example.com/tags/GitHub%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
</feed>
